<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="queries">
 <title>Query</title>

 <indexterm zone="queries">
  <primary>query</primary>
 </indexterm>

 <indexterm zone="queries">
<primary>SELECT</primary>
 </indexterm>

 <para>
Nei capitoli precedenti è stato spiegato come create tabelle, come 
riempirle di dati, e come manipolare i dati. Adesso finalmente verrà discusso
come recuperare i dati dal database.
 </para>


 <sect1 id="queries-overview">
  <title>Panoramica</title>

  <para>
Il processo di recupero o il comando per ottenere dati da un database
è chiamato <firstterm>query</firstterm>.  In SQL, per realizzare una query,
si usa il comando <xref linkend="sql-select"/>. La sintassi generale
del comando <command>SELECT</command> è
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
Le sezioni seguenti descrivono i dettagli riguardo all'elenco di selezione, all'espressione di tabella 
e alla specifica di tipo. Le query <literal>WITH</literal> sono trattate per ultime
dato che sono una caratteristica avanzata.
  </para>

  <para>
Un tipo semplice di query ha la forma:
<programlisting>
SELECT * FROM table1;
</programlisting>
Assumendo che ci sia una tabella chiamata <literal>table1</literal>,
questo comando restituisce tutte le righe e tutte le colonne da 
<literal>table1</literal>. (Il metodo di reperimento dipende dall'applicazione client.
Per esempio, il programma <application>psql</application> mostrerà sullo schermo una tabella
in ASCII-art, mentre librerie client offriranno funzioni per 
estrarre valori individuali dal risultato della query). <literal>*</literal>  
come elenco di selezione significa "tutte le colonne che soddisfano l'elenco di selezione". 
Un elenco di selezione può anche selezionare un sottoinsieme delle colonne disponibili
o fare calcoli usando le colonne. Per esempio, se
<literal>table1</literal> ha colonne chiamate <literal>a</literal>,
<literal>b</literal> e <literal>c</literal> (e magari altre) è possibile eseguire
la query seguente:
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
(assumendo che <literal>b</literal> e <literal>c</literal> siano tipi di dato numerici).
Si veda <xref linkend="queries-select-lists"/> per maggiori dettagli.
 </para>

 <para>
<literal>FROM table1</literal> è un tipo semplice di espressione di tabella:
legge semplicemenete una tabella. In generale, le espressioni di tabella possono essere
costrutti complessi di tabelle, join e sottoquery. Ma è possibile anche omettere interamente l'espressione
di tabella e usare il comando <command>SELECT</command> come una calcolatrice:
<programlisting>
SELECT 3 * 4;
</programlisting>
Questo è maggiormente utile se le espressioni nell'elenco di selezione restituiscono 
risultati mutevoli.
<programlisting>
SELECT random();
</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
  <title>Expressioni di tabella</title>

  <indexterm zone="queries-table-expressions">
   <primary>espressione di tabella</primary>
  </indexterm>

  <para>
Un'<firstterm>espressione di tabella</firstterm> calcola  una tabella. L'espressione
di tabella contiene una clausola <literal>FROM</literal> che opzionalmente è seguita dalle clausole
da <literal>WHERE</literal>,  <literal>GROUP BY</literal> e
<literal>HAVING</literal>.  Espressioni di tabella insignificanti si riferiscono semplicemente
a una tabella su disco, chiamata tabella base, ma espressioni più complesse
possono essere usate per modificare o combinare tabelle base in diversi modi.
  </para>

  <para>
Le clausole opzionali <literal>WHERE</literal>, <literal>GROUP BY</literal> e
<literal>HAVING</literal> nell'espressione di tabella specificano una pipeline di 
successive trasformazioni eseguite sulla tabella
derivata nella clausola <literal>FROM</literal> Tutte queste trasformazioni
producono una tabella virtuale che fornisce le righe passate all'elenco di selezione
per ricavare le righe di output della dquery.
  </para>

  <sect2 id="queries-from">
   <title>La clausola <literal>FROM</literal></title>

   <para>
    The <xref linkend="sql-from" endterm="sql-from-title"/> derives a
La <xref linkend="sql-from" endterm="sql-from-title"/> ricava una tabella da uno o più riferimenti di tabella
fornite in un elenco separato da virgole.
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

Un riferimento di tabella può essere il nome di una tabella (possibilimente qualificato dallo schema),
o una tabella derivata come una sottoquery, una join di tabella, o combinazioni complesse di queste.
Se viene elencato più di un riferimento di tabella nella clausola 
<literal>FROM</literal> vengono sottoposti a "cross-join" (si veda sotto)
per formare la tabella virtuale intermedia che può essere soggetto di 
trasformazioni da parte di clausole <literal>WHERE</literal>, <literal>GROUP BY</literal>,
e <literal>HAVING</literal> e sarà finalmente il risultato dell'espressione di tabella globale.
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
Quando un riferimento di tabella nomina una tabella genitore di una 
gerarchia di ereditarietà, il riferimento di tabella produce righe 
non solo di quella tabella, ma anche di tutte le tabelle discendenti, a meno che la 
parola chiave <literal>ONLY</literal> preceda il nome della tabella. Comunque, 
il riferimento produce solo colonne che appaiono nella tabella nominata -
ogni colonna aggiunta nelle sotto-tabelle  viene ignorata.
   </para>

   <sect3 id="queries-join">
    <title>Tabelle Join</title>

    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>

    <para>
Una tabella join è una tabella derivata da altre due tabelle (reali o derivate)
seguendo le regole del particolare tipi di join. Sono disponibili inner join, outer join e 
cross join.
    </para>

    <variablelist>
     <title>Tipi di join</title>

     <varlistentry>
      <term>Cross join</term>

      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>

      <indexterm>
       <primary>cross join</primary>
      </indexterm>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
Per ogni possibile combinazione di righe provenienti da
<replaceable>T1</replaceable> e 
<replaceable>T2</replaceable> (per es., un prodotto cartesiano),
la tabella risultante conterrà una riga 
comprendente tutte le colonne di <replaceable>T1</replaceable>
seguite da tutte le colonne di <replaceable>T2</replaceable>. Se 
le tabelle hanno rispettivamente N e M righe, la tabella risultante  
avrà N * M righe.
       </para>

       <para>
<literal>FROM <replaceable>T1</replaceable> CROSS JOIN
<replaceable>T2</replaceable></literal> è equivalente a 
<literal>FROM <replaceable>T1</replaceable>, <replaceable>T2</replaceable></literal>.
È anche equivalente a <literal>FROM <replaceable>T1</replaceable> INNER JOIN
<replaceable>T2</replaceable> ON TRUE</literal> (si veda sotto).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Join qualificate</term>

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
Le parole <literal>INNER</literal> e
<literal>OUTER</literal> sono opzionali in tutte le forme.
<literal>INNER</literal> è il predefinito;
<literal>LEFT</literal>, <literal>RIGHT</literal>, e
<literal>FULL</literal> implicano una outer join.
       </para>

       <para>
La <firstterm>condizione di join</firstterm> viene specificata nella clausola <literal>ON</literal>
o <literal>USING</literal>, o implicitamente dalla parola <literal>NATURAL</literal>.
La condizione di join determina quali righe delle due tabelle sorgente sono considerate
<quote>corrispondere</quote>, come spiegato in dettaglio sotto.
       </para>

       <para>
La clausola <literal>ON</literal> è il tipo più generale di condizione join:
essa prende un espressione di valore booleano dello stesso tipo usato  
in una clausola <literal>WHERE</literal>. una coppia di righe
di <replaceable>T1</replaceable> e <replaceable>T2</replaceable> corrisponde se 
l'espressione <literal>ON</literal> risulta true per loro.
       </para>

       <para>
<literal>USING</literal> è una notazione abbreviata: accetta elenchi di nomi di colonna 
separati da virgole, che le tabelle sottoposte a join devono avere in comune, 
e forma una condizione di join specificando
l'uguaglianza di ognuna di queste coppie di colonne. Inoltre, l'output 
di <literal>JOIN USING</literal> ha una colonna per ognuna delle coppie 
delle colonne di input messe in relazione. Così, <literal>USING (a, b, c)</literal> 
è equivalente a <literal>ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c)</literal>
ad eccezione del fatto che se viene usato <literal>ON</literal> ci saranno due colonne
<literal>a</literal>, <literal>b</literal>, e <literal>c</literal> nel risultato,
mentre con <literal>USING</literal> ce ne sarà solo una per ognuna 
(e appariranno per prime se viene usato <command>SELECT *</command>).
       </para>

       <para>
        <indexterm>
         <primary>join</primary>
         <secondary>natural</secondary>
        </indexterm>
        <indexterm>
         <primary>natural join</primary>
        </indexterm>
Infine, <literal>NATURAL</literal> &egrave; una forma abbreviata di
<literal>USING</literal>: essa forma una lista <literal>USING</literal> consistente
esattamente di quei nomi di colonna che compaiono in entrambe le
tabelle di ingresso. Come con <literal>USING</literal>, queste colonne
compaiono soltanto una volta nella tabella di output.
       </para>

       <para>
I tipi possibili di join qualificate sono:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
Per ogni riga R1 di T1, la tabella sottoposta a join ha una riga per ogni
riga di T2 che soddisfa la condizione di join con R1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal></term>

         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>

         <listitem>
          <para>
Prima viene eseguita una inner join. Quindi, per ogni riga in T1 che non soddisfa
la condizione di join con qualsiasi riga in T2,
una riga sottoposta a join viene aggiunta con valori null nelle colonne di T2.
Così, la tabella risultante avrà almeno una riga
per ogni riga in T1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal></term>

         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>

         <listitem>
          <para>
Prima viene eseguita una inner join. Quindi, per ogni riga in 
T2 che non soddisfa  la condizione di join con una qualsiasi riga in T1,
una riga sottoposta a join viene aggiunta con valori null nelle colonne di T1.
Questo è il contrario di una left join: la tabella risultante avrà sempre una 
riga per ogni riga di T2.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
Prima viene eseguita una inner join. Quindi, per ogni riga in 
T1 che non soddisfa la condizione di join con una qualsiasi riga in 
T2, una riga sottoposta a join viene aggiunta con valori null nelle colonne di 
T2. Inoltre, per ogni riga di T2 che non soddisfa la condizione 
join con un qualsiasi riga in T1, viene aggiunta una riga join con valori null
nelle colonne di T1.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
Join di tutti i tipi possono essere concatenate o annidate: <replaceable>T1</replaceable>
e/o <replaceable>T2</replaceable> possono essere tabelle sottoposte a join. 
Possono essere usate parentesi attorno alle clausole <literal>JOIN</literal>
per controllare l'ordine della join. In assenza di parentesi, clausole <literal>JOIN</literal>
vanno da sinistra a destra.
    </para>

    <para>
Per mettere insieme tutto questo, assumiamo di avere le tabelle <literal>t1</literal>:
<programlisting>
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
     e <literal>t2</literal>:
<programlisting>
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
per i diversi tipi di join, otterremo i seguenti risultati:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>

    <para>
La condizione di join specificata con <literal>ON</literal> può contenere anche
condizioni che non si riferiscono direttamente alla join. Questo può tornare utile
per alcune query ma deve essere progettato con attenzione. Per esempio:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
Si noti che posizionare la restrizione nella clausola <literal>WHERE</literal>
produce un risultato diverso:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</screen>
Questo perchè una restrizione posizionata nella clausola <literal>ON</literal>
viene processata <emphasis>prima</emphasis> della join, mentre una restrizione 
posta nella clausola <literal>WHERE</literal> viene processata 
<emphasis>dopo</emphasis> la join.
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
    <title>Alias di tabella e colonna</title>

    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>nella clausola FROM</secondary>
    </indexterm>

    <indexterm>
     <primary>etichetta</primary>
     <see>alias</see>
    </indexterm>

    <para>
Un nome temporaneo può essere dato a tabelle e riferimenti complessi di tabella
per essere usato come riferimento nel resto della query.
Questo prende il nome di <firstterm>alias di tabella</firstterm>
    </para>

    <para>
Per creare un alias di tabella, scrivere
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
o
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
La parola chiave <literal>AS</literal> è superflua. 
<replaceable>alias</replaceable> può essere qualsiasi identificatore.
    </para>

    <para>
Una tipica applicazione degli alias di tabella è quando si vuole assegnare 
identificatori a nomi di tabella lunghi per mantere leggibili le clausole join.
Per esempio:
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>

    <para>
L'alias diventa il nuovo nome del riferimento alla tabella per quanto concerne la query corrente -
non è permesso fare riferimento alla tabella col nome originale altrove nella query.
Per questo, questo non è valido:
<programlisting>
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- sbagliato
</programlisting>
    </para>

    <para>
Gli alias di tabella sono principalmente comodità di notazione, ma è necessario usarle
quando si effettua il join di una tabella con sè stessa, per es.:
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
In più, è richiesto un alias se il riferimento alla tabella è una sottoquery
(si veda <xref linkend="queries-subqueries"/>).
    </para>

    <para>
Per risolvere le ambiguità vengono usate le parentesi. Nell'esempio seguente,
la prima istruzione assegna l'alias <literal>b</literal> alla seconda istanza di 
<literal>my_table</literal>, ma la seconda istruzione assegna l'alias al risultato della join:
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>

    <para>
Un altra forma di alias per le tabelle fornisce un nome temporaneo alle colonne della
tabella, nello stesso modo fatto per le tabelle:
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
Se sono specificati alias per un numero di colonne inferiori rispetto a quelle
contenute nella tabella, le restanti colonne non verranno rinominate. Questa
sintassi è utilizzata specialmente per self-join o sottoquery.
    </para>

    <para>
Quando un alias è applicato all'output di una clausula <literal>JOIN</literal>,
utilizzando una di queste forme, l'alias nasconde i nomi originali
dentro la <literal>JOIN</literal>. Per esempio:
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
è SQL valido, ma:
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
non è valido; l'alias di tabella <literal>a</literal> non è visibile
al di fuori dell'alias <literal>c</literal>.
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
    <title>Sottoquery</title>

    <indexterm zone="queries-subqueries">
     <primary>sottoquery</primary>
    </indexterm>

    <para>
Le subquery che specificano una tabella derivata devono essere racchiuse tra
parentesi e <emphasis>devono</emphasis> essere assegnate ad un nome
alias di tabella. (Vedere <xref linkend="queries-table-aliases" />). Per
esempio:
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>

    <para>
Questo esempio &egrave; equivalente a <literal>FROM tabella1 AS
nome_alias</literal>. Casi pi&ugrave; interessanti, che non si
riducono ad una semplice join, si presentano quando la subquery
coinvolge raggruppamenti o aggregazioni.
    </para>

    <para>
     A subquery can also be a <command>VALUES</command> list:
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
Di nuovo, è richiesto un alias di tabella. Assegnare alias alle colonne  
dell'elenco <command>VALUES</command> è opzionale, ma comunque una buona pratica.
Per maggiori informazioni si veda <xref linkend="queries-values"/>.
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
    <title>Funzioni di tabella</title>

    <indexterm zone="queries-tablefunctions"><primary>funzione di tabella</primary></indexterm>

    <indexterm zone="queries-tablefunctions">
     <primary>funzione</primary>
     <secondary>nella clausola FROM</secondary>
    </indexterm>

    <para>
Funzioni di tabella sono funzioni che producono un insieme di righe, fatte sia da
tipi di dato di base (tipi scalari) che da tipi di dato composti 
(righe di tabella). Sono usate come tabella, vista, o sottoquery nella clausola
<literal>FROM</literal> di una query. Le colonne restituite dalle funzioni tabella
possono essere incluse nelle <literal>SELECT</literal>, 
<literal>JOIN</literal> o nelle clausole <literal>WHERE</literal> allo stesso modo di una tabella,
una vista, o una colonna di sottoquery.
    </para>

    <para>
Se una funzione di tabella restituisce un tipo di dato di base, il nome della
singola colonna risultante corrisponde al nome della funzione. Se la funzione restituisce un 
tipo composto, le colonne risultanti avranno gli stessi nomi degli attributi del tipo.
    </para>

    <para>
Una funzione di tabella può essere sottoposta ad alias nella clausola <literal>FROM</literal>,
ma può anche essere lasciata senza alias. Se una funzione viene usata nella clausola 
<literal>FROM</literal> senza alias, il nome della funzione viene usato 
come nome della tabella risultante.
    </para>

    <para>
Alcuni esempi:
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>

    <para>
In alcuni casi è utile definire funzioni di tabella che possono 
restituire insiemi di colonne diversi dipendentemente da come sono invocate.
Per realizzare questo, la funzione di tabella può essere dichiarata che ritorni 
lo pseudotipo <type>record</type>. Quando una funzione di questo tipo viene usata
in una query, la struttura di riga aspettata dev'essere specificata nella query stessa,
così che il sistema possa sapere come eseguire il parsing e il plan della query. 
Considerare l'esempio:
<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
La funzione <literal>dblink</literal> esegue una query remota (di veda
<filename>contrib/dblink</filename>). È dichiarata per restiruire 
<type>record</type> dato che potrebbe essere usata per qualsiasi tipo di query.
L'insieme di colonne deve essere specificato nella query chiamante così che il 
il parser sappia, per esempio, come <literal>*</literal> dovrebbe espandersi.
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
   <title>La clausola <literal>WHERE</literal></title>

   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

   <para>
La sintassi della <xref linkend="sql-where"
endterm="sql-where-title"/> è
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
Dove <replaceable>search_condition</replaceable> è qualsiasi espressione di valore 
(si veda <xref linkend="sql-expressions"/>) che restituisce 
un valore di tipo <type>boolean</type>.
   </para>

   <para>
Dopo che è terminata l'elaborazione della clausola <literal>FROM</literal> , ogni
riga della tabella virtuale derivata viene confrontata alla condizione di ricerca.
Se il risultato della condizione è true, la riga viene 
mantenuta nella tabella di output, altrimenti viene scartato (per es., se il risultato è
false o null). La condizione di ricerca tipicamente si riferisce almeno ad una colonna
della tabella generata nella clausola <literal>FROM</literal>;
questo non è richiesto, ma altrimenti la clausola <literal>WHERE</literal>
sarà abbastanza inutile.
   </para>

   <note>
    <para>
La condizione di join di una inner join può essere scritta o nella clausola 
<literal>WHERE</literal> o nella clausola <literal>JOIN</literal>.
Per esempio, queste espressioni di tabella sono equivalenti:
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
e:
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
o forse anche:
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
Quale si voglia usare di questi è principalmente una questione di stile. La
sintassi <literal>JOIN</literal> nella clausola <literal>FROM</literal> probabilmente non è
portabile verso altri sistemi di gestione di database SQL,
anche se è nello standard SQL. Per outer join non c'è possibilità 
di scelta: devono essere nella clausola <literal>FROM</literal>.
Le clausole <literal>ON</literal> o <literal>USING</literal>
di una outer join <emphasis>non</emphasis> è equivalente a una condizione 
<literal>WHERE</literal>, perchè corrisponde all'aggiunta 
di righe (per righe di input non corrispondenti) così come la rimozione di righe
nel risultato finale.
    </para>
   </note>

   <para>
Ecco alcuni esempi di clausole <literal>WHERE</literal>:
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
<literal>fdt</literal> è la tabella derivata nella clausola <literal>FROM</literal>.
Le righe che non soddisfano la condizione di ricerca della clausola <literal>WHERE</literal>
sono eliminate da <literal>fdt</literal>. Si noti l'uso di sottoquery scalari come
valori di espressione. Esattamente come qualsiasi altra query, le sottoquery possono
impiegare espressioni di tabella complesse. Notare inoltre come 
<literal>fdt</literal> viene referenziato nelle sottoquery.
Qualificare <literal>c1</literal> come <literal>fdt.c1</literal> è necessario solo
se <literal>c1</literal> è anche il nome di una colonna nella tabella di input derivata 
della sottoquery. In ogni caso, qualificare il nome della colonna aggiunge chiarezza
anche quando non è necessario. Questo esempio mostra come lo scope di nomi di una query outer
si estende nelle sue query inner.
   </para>
  </sect2>


  <sect2 id="queries-group">
   <title>Le clausole <literal>GROUP BY</literal> e <literal>HAVING</literal></title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>raggruppamento</primary>
   </indexterm>

   <para>
Dopo che si è passato il filtro <literal>WHERE</literal>, la tabella di input derivata
potrebbe essere soggetta a raggruppamento, usando la clausola <literal>GROUP BY</literal>,
ed eliminazione di righe usando la clausola <literal>HAVING</literal>.
   </para>

<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>

   <para>
La <xref linkend="sql-groupby" endterm="sql-groupby-title"/> è
usata per raggruppare insieme quelle righe in una tabella che hanno gli stessi
valori in tutte le colonne elencate. L'ordine con il quale le colonne
sono elencate non è importante. L'effetto è quello di combinare ogni elenco di righe
aventi valori in comune in una riga-gruppo che rappresenta 
tutte le righe del gruppo. Questo viene fatoo per eliminare
la ridondanza in output e/o eseguire calcoli aggregati su questi gruppi.
Per esempio:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>

   <para>
Nella seconda query, potevamo non aver scritto <literal>SELECT *
FROM test1 GROUP BY x</literal>, dato che non c'è un singolo valore
per la colonna <literal>y</literal> che può essere associato con ogni 
gruppo. La colonne raggruppate possono essere referenziate nell'elenco select dato che 
hanno un singolo valore in ogni gruppo.
   </para>

   <para>
In generale, se una tabella è raggruppata, colonne che non sono elencate
in <literal>GROUP BY</literal> non possono essere referenziate eccetto in espressioni
aggregate. Un esempio con un'espressione aggregata è:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
Qui  <literal>sum</literal> è una funzione aggregata che 
calcola un valore singolo dell'intero gruppo. Maggiori informazioni
sulle funzioni disponibili possono essere trovate in <xref
linkend="functions-aggregate"/>.
   </para>

   <tip>
    <para>
Ragggruppare senza espressioni aggregate effettivamente calcola l'insieme
dei valori distinti in una colonna. Questo può essere ottenuto anche
usando la clausola <literal>DISTINCT</literal>(si veda <xref 
linkend="queries-distinct"/>).
    </para>
   </tip>

   <para>
Ecco un altro esempio: calcola le vendite totali per ogni
prodotto (piuttosto che le vendite totali di tutti i prodotti):
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
In questo esempio, le colonne <literal>product_id</literal>,
<literal>p.name</literal> e <literal>p.price</literal> devono essere 
nella clausola <literal>GROUP BY</literal> dato che sono referenziate nell'elenco select 
della query (ma si veda sotto). La colonna
<literal>s.units</literal> non dev'essere nell'elenco <literal>GROUP
BY</literal> dato che è usato solo in un'espressione aggregata
(<literal>sum(...)</literal>), che rappresenta le vendite 
di un prodotto. Per ogni prodotto, la query restituisce una riga di riassunto
su tutte le vendite del prodotto.
   </para>

   <para>
Se la tabella dei prodotti è impostat per, 
diciamo, avere <literal>product_id</literal> come chiave primaria, allora 
dovrebbe essere sufficiente raggruppare per <literal>product_id</literal> nell'esempio
sopra, dato che nome e prezzo dovrebbero essere 
<firstterm>funzionalmente dipendenti</firstterm>.

<indexterm>
    <primary>functional dependent</primary>
</indexterm>
<indexterm>
    <primary>functional dependency</primary>
</indexterm> 
sull'ID di prodotto, e così non ci dovrebbe essere ambiguità su  quale valore di nome 
e prezzo restituire per ogni ID di gruppo di prodotti.
   </para>

   <para>
In SQL stretto, <literal>GROUP BY</literal> può raggruppare solo colonne della tabella  
sorgente ma <productname>PostgreSQL</productname> lo estende 
per permettere alla <literal>GROUP BY</literal>  di raggruppare per  colonne nell'elenco
select. È possibili anche raggruppare per espressioni di valori invece di semplici nomi
di colonna. 
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
Se una tabella è stata raggruppata usando <literal>GROUP BY</literal>,
ma interessano solo certi gruppi, può essere usata la clausola <literal>HAVING</literal>,
simile per la maggior parte alla  <literal>WHERE</literal>, per eliminare 
gruppi dal risultato.
La sintassi è:
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
Espressioni nella clausola  <literal>HAVING</literal> possono riferirsi sia a 
espressioni raggruppate che a espressioni non raggruppate (che necessariamente
coinvolgono una funzione aggregata).
   </para>

   <para>
Esempio:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>

   <para>
Di nuovo, un esempio più realistico:
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
Nell'esempio sopra, la clausola <literal>WHERE</literal> seleziona righe 
da una colonna che non è raggruppata (l'esprezzione è true solo per vendite
durante le ultime quattro settimane), mentre la clausola <literal>HAVING</literal>
restringe l'output per gruppi con vendite totali maggiori di 5000.
Si noti che le espressioni aggregate non hanno necessariamente bisogno di 
essere le stesse in tutte le parti della query.
   </para>

   <para>
Se una query contiene chiamate a funzioni aggregate, ma non clausole <literal>GROUP BY</literal>,
il raggrumento avviene comunque: il risultato è una singola riga-gruppo (o 
magari nessuna riga, se la riga singola è poi eliminata da 
<literal>HAVING</literal>).
Lo stesso è true se contiene una clausola <literal>HAVING</literal>, anche 
senza nessuna chiamata a funzione aggregata o clausola <literal>GROUP BY</literal>.
   </para>
  </sect2>

  <sect2 id="queries-window">
   <title>Elaborazione di funzioni window</title>

   <indexterm zone="queries-window">
    <primary>funzione window</primary>
    <secondary>ordine di esecuzione</secondary>
   </indexterm>

   <para>
Se la query contiene funzioni window (si veda 
<xref linkend="tutorial-window"/>,
<xref linkend="functions-window"/> e
<xref linkend="syntax-window-functions"/>), queste funzioni sono valutate 
dopo che qualsiasi raggruppamento, aggregazione, e filtro <literal>HAVING</literal>
venga svolto. Così, se la query usa qualsiasi aggregata, <literal>GROUP
BY</literal>, o <literal>HAVING</literal>, allora le righe viste dalle funzioni window
solo le righe-gruppo invece delle righe originali della tabella
provenienti dalla <literal>FROM</literal>/<literal>WHERE</literal>.
   </para>

   <para>
Quando sono usate molteplici funzioni window, tutte le funzioni window aventi 
clausole <literal>PARTITION BY</literal> e <literal>ORDER BY</literal>
sintatticamente equivalenti nelle loro definizioni di windowè garantito siano valutate in un singolo
passo sui dati. Perciò vedranno lo stesso ordinamento,
anche se la <literal>ORDER BY</literal> non determina unicamente un ordinamento. 
Comunque, non sono assicurate garanzie sulla valutazione di funzioni aventi 
diverse specificazioni di  <literal>PARTITION BY</literal> o <literal>ORDER BY</literal>.
(In qualche caso un certo passo è tipicamente richiesto tra i passi di 
valutazione di funzioni window, e non è garantita la preservazione
di ordinamento di righe che il suo <literal>ORDER BY</literal> vede come equivalente).
   </para>

   <para>
Attualmente, le funzioni window richiedono sempre dati preordinati, e così 
l'output della query sarà ordinato in accordo all'una o l'altra delle clausole
<literal>PARTITION BY</literal>/<literal>ORDER BY</literal> delle funzioni 
window.
Non è raccomandabile contare su questo, in ogni caso. Usare una clausola 
<literal>ORDER BY</literal> di livello superiore se si vuole essere sicuri che 
i risultati siano ordinati in modo particolare.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
  <title>Elenchi di selezione</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>elenco di selezione</secondary>
  </indexterm>

  <para>
Come visto nella sezione precedente,
l'espressione di tabella nel comando <command>SELECT</command>
costruisce una tabella virtuale intermedia combinando possibilmente 
tabelle, viste, eliminando righe, raggruppamenti, ecc. Questa tabella 
viene infine passata all'elaborazione dall'<firstterm>elenco di selezione</firstterm>. L'elenco di 
selezione determina quali <emphasis>colonne</emphasis> della tabella 
intermedia sono mostrate in output.
  </para>

  <sect2 id="queries-select-list-items">
   <title>Elementi dell'elenco di selezion</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
Il tipo più semplice di elenco di selezione è <literal>*</literal> che
rappresenta tutte le colonne che l'espressione di tabella produce. Altrimenti,
un elenco di selezione è un elenco separato da virgole di valori (come definito in
<xref linkend="sql-expressions"/>).  Per esempio, potrebbe essere 
un elenco di nomi di colonna:
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
I nomi di colonna <literal>a</literal>, <literal>b</literal>, e <literal>c</literal>
sono o i nomi attuali delle colonne delle tabelle referenziate nella 
clausola <literal>FROM</literal> o gli alias a loro forniti, come spiegato in 
<xref linkend="queries-table-aliases"/>. Il namespace 
disponibile nell'elenco di selezione è lo stesso che nella clausola 
<literal>WHERE</literal>, a meno che sia usato il raggruppamento, nel qual caso
è lo stesso che nella clausola <literal>HAVING</literal>.
   </para>

   <para>
Se più di una tabella ha una colonna con lo stesso nome, 
deve essere specificato anche il nome della tabella, quindi:
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
Quando si lavora con molteplici tabelle, può anche essere utile usarlo per 
tutte le colonne di una tabella: 
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
(Si veda inoltre <xref linkend="queries-where"/>).
   </para>

   <para>
Se un valore arbitrario vien usato nell'elenco di selezione, esso concettualmente
aggiunge una nuova colonna virtuale alla tabella restituita. Il valore 
è valutato una volta per ogni riga del risultato, con i valori della riga sostituiti
per ogni riferimento di colonna. Le espressioni nell'elenco di selezione 
non devono fare riferimento a qualsiasi colonna nell'espressione di tabella della clausola 
<literal>FROM</literal>;
questi possono essere espressioni di costanti aritmetiche, per esempio.
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
   <title>Etichette di colonna</title>

   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>nell'elenco di selezione</secondary>
   </indexterm>

   <para>
Le voci dell'elenco di selezione possono essere assegnate per elaborazioni successive,
come per l'uso  in una clausola <literal>ORDER BY</literal> o
per essere  visualizzati dall'applicazione client. Per esempio:
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>

   <para>
Se non viene specificato un nome di colonna di output usando <literal>AS</literal>,
il sistema assegna unome di colonna predefinito. Per riferimenti di solonna semplici, 
questo sarà il nome della colonna a cui si fà riferimento. Per chiamate di funzione, 
sarà il nome della funzione. Per espressioni complesse, 
il sistema genererà un nome generico.
   </para>

   <para>
La parola chiave <literal>AS</literal> è opzionale, ma solo se il nome della nuova colonna
non corrisponde a nessuna parola chiave di
<productname>PostgreSQL</productname> (si veda <xref
linkend="sql-keywords-appendix"/>). Per evitare una corrispondenza accidentale 
con una parola chiave, è possibile mettere il nome della colonna tra doppi apici. Per esempio,
<literal>VALUE</literal> è una parola chiave, quindi questo non funzionerà:

<programlisting>
SELECT a value, b + c AS sum FROM ...
</programlisting>
ma questo si:
<programlisting>
SELECT a "value", b + c AS sum FROM ...
</programlisting>
Per protezione rispetto a possibili future aggiunte di parole chiave,  
si raccomanda di scrivere sempre o <literal>AS</literal> o 
mettere tra doppi apici il nome della colonna.
   </para>

   <note>
    <para>
La nomenclature delle colonne di output è diversa da quella della 
clausola <literal>FROM</literal> (si veda <xref
linkend="queries-table-aliases"/>). È possibile 
rinominare la stessa colonna due volte, ma il nome assegnato nell'elenco di 
selezione è quello che verrà passato.
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

   <indexterm zone="queries-distinct">
    <primary>duplicati</primary>
   </indexterm>

   <para>
Dopo che l'elenco di selezione è stato elaborato, la tabella risultante puà
essere opzionalmente soggetta a eliminazione di righe duplicate. Per specificare questo, la parola chiave 
<literal>DISTINCT</literal> viene scritta direttamente dopo 
<literal>SELECT</literal>:
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
(Invece di <literal>DISTINCT</literal>, la parola chiave <literal>ALL</literal>
può essere usata per specificare il comportamento predefinito di restituire tutte le righe).
   </para>

   <para>
<indexterm><primary>valore null</primary><secondary sortas="DISTINCT">in
DISTINCT</secondary></indexterm>
Ovviamente, due righe sono considerate distinte se differiscono in almeno
un valore di colonna. Valori null sono considerati uguali in questo confronto.
   </para>

   <para>
Alternativamente, un'espressione arcbitraria può determinare quali righe devono essere consiferate
distinte:
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
Qui <replaceable>expression</replaceable> è un valore arbitrario
che viene valutato per tutte le righe. Un insieme di righe per
il quale tutte le espressioni sono uguali sono considerate duplicate, e 
solo la prima riga dell'insieme è mantenuta in output. Notare che
la <quote>prima riga</quote> di un insieme è imprevedibile a meno che la query  non sia
ordinata rispetto ad abbastanza colonne da garantire un ordinamento unico
delle righe in arrivo al filtro <literal>DISTINCT</literal>.
(L'elaborazione di <literal>DISTINCT ON</literal> avviene dopo l'ordinamento  <literal>ORDER
BY</literal>).
   </para>

   <para>
La clausola <literal>DISTINCT ON</literal> non fa parte dello standard SQL
e qualche volta è considerata cattivo stile data la natura potenzialmente
indeterminata dei suoi risultati. Con un uso giudizioso di 
<literal>GROUP BY</literal> e sottoquery nella <literal>FROM</literal>, questo costrutto 
può essere evitato, ma spesso è l'alternativa più
conveniente.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
  <title>Query di combinazione</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>insieme unione</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>insieme intersezione</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>insieme differenza</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>insieme operazione</primary>
  </indexterm>

  <para>
I risultati di due query possono essere combinati usando le operazioni sugli insiemi
unione, intersezione, e differenza. La sintassi è
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
<replaceable>query1</replaceable> e
<replaceable>query2</replaceable> sono query che possono usare qualsiasi 
delle caratteristiche discusse fino a questo punto. Operazioni sugli insiemi possono
anche essere annidate o concatenate, per esempio
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> UNION <replaceable>query3</replaceable>
</synopsis>
che viene eseguito come:
<synopsis>
(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) UNION <replaceable>query3</replaceable>
</synopsis>
  </para>

  <para>
<literal>UNION</literal> effettivamente aggiunge il risultato di 
<replaceable>query2</replaceable> al risultato di 
<replaceable>query1</replaceable> (anche se non c'è garanzia 
che questo sia l'ordine nel quale le righe sono effettivamente restituite).
Inoltre, esso elimina righe duplicate dal suo risultato, nello stesso modo di
<literal>DISTINCT</literal>, a meno che non sia usata <literal>UNION ALL</literal>.
  </para>

  <para>
<literal>INTERSECT</literal> restituisce tutte le righe che sono sia nel risultato 
di <replaceable>query1</replaceable> che nel risultato di 
<replaceable>query2</replaceable>. Le righe duplicate sono eliminate
a meno che sia usata <literal>INTERSECT ALL</literal>. 
  </para>

  <para>
<literal>EXCEPT</literal> restituisce tutte le righe che sono nel risultato di 
<replaceable>query1</replaceable> ma non nel risultato di 
<replaceable>query2</replaceable>. (A volte questa viene chiamata 
<firstterm>differenza</firstterm> tra due query). Di nuovo, i duplicati vengono
eliminati a meno che sia usata <literal>EXCEPT ALL</literal>.
  </para>

  <para>
Per calcolare l'union, l'intersezione o la differenza di due query,
le due query devono essere <quote>compatibili alla union</quote>,
che significa che restituiscono lo stesso numero di colonne e
le colonne corrispondenti hanno tipi di dato compatibili, come 
descritto in <xref linkend="typeconv-union-case"/>.
  </para>
 </sect1>


 <sect1 id="queries-order">
  <title>Classificazione di righe</title>

  <indexterm zone="queries-order">
   <primary>classificazione</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>

  <para>
Dopo che una query ha prodotto una tabella di output (dopo che l'elenco di selezione
è stato elaborato) può eventualmente essere classificata. Se la classificazione non viene
scelta, le righe saranno restituite in ordine sparso. L'ordine attuale 
in quel caso dipenderà dai tipi di plan di scansione e di join e 
dall'ordine du disco, ma non bisogna contarci. Un particolare ordine 
si output puà essere garantito solo se il passo di ordinamento viene scelto esplicitamente.
  </para>

  <para>
La clausola <literal>ORDER BY</literal> specifica l'ordine di classificazione:
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
L'espressione/i di classificazione puà essere qualsiasi espressione che dovrebbe essere valida 
nell'elenco di selezione della query. Un esempio è:
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
Quando viene specificata più di un'espressione,
i valori successivi sono usati per classificare righe che sono uguali in accordo ai
valori precedenti. Ogni espressione può essere seguita da una parola chiave 
<literal>ASC</literal> o <literal>DESC</literal> per impostare la direzione d'ordinamento come
ascendente o discendente. L'ordinamento <literal>ASC</literal> è il predefinito.
Ordinamento ascendente mette valori più piccoli prima, dove
<quote>più piccoli</quote> sono definiti dall'operatore 
<literal>&lt;</literal>. Similmente, ordinamento discendente è
determinato con l'operatore <literal>&gt;</literal>.
    <footnote>
     <para>
Attualmente, <productname>PostgreSQL</productname> usa la <firstterm>classe operatore B-tree
predefinita</firstterm> per i tipi di dato delle espressioni per determinare l'ordinamento 
per <literal>ASC</literal> e <literal>DESC</literal>. Convenzionalmente, 
i tipi di dato saranno impostati in modo che gli operatori <literal>&lt;</literal> e 
<literal>&gt;</literal> corrispondano a questo ordinamento,
ma per quanto riguarda un tipo di dato definito dall'utente si potrebbe scegliere
di fare qualcosa di diverso.
     </para>
    </footnote>
  </para>

  <para>
Le opzioni <literal>NULLS FIRST</literal> e <literal>NULLS LAST</literal> possono essere
usate per determinare se i null appaiono prima o dopo i valori non-null nell'ordinamento.
In modo predefinito, valori null sono considerati maggiori di qualsiasi valore non-null;
perciò, <literal>NULLS FIRST</literal> è il modo predefinito per ordinameni
<literal>DESC</literal>, altrimento <literal>NULLS LAST</literal>.
  </para>

  <para>
Si noti come le opzioni di ordinamento sono considerateindipendentemente per ogni colonna.
Per esempio <literal>ORDER BY x, y DESC</literal> significa
<literal>ORDER BY x ASC, y DESC</literal>, che non è la stessa cosa di 
<literal>ORDER BY x DESC, y DESC</literal>.
  </para>

  <para>
Una <replaceable>sort_expression</replaceable> può essere anche l'etichetta di colonna il numero di
una colonna di output, come in:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
entrambe ordinano usando la prima colonna di output. Notare che un nome di colonna di output 
deve essere isolato, quindi, non può essere usato in una espressione -
per esempio, questo <emphasis>non</emphasis> è corretto:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- wrong
</programlisting>
Questa restrizione serve a ridurre l'ambiguità. C'è sempre ambiguità
se un elemento <literal>ORDER BY</literal> è un nome semplice che
potrebbe corrispondere al nome di una colonna di output o una colonna della tabella
espressione. La colonna di output viene usata in quei casi. Questo causerebbe solo
confusione se si usa  <literal>AS</literal> per rinominare una colonna di output 
per corrispondere ad altri nomi di colonne.
  </para>

  <para>
<literal>ORDER BY</literal> può essere applicato al risultato di una combinazione di
<literal>UNION</literal>, <literal>INTERSECT</literal>, o <literal>EXCEPT</literal>,
ma in questo caso è permesso solo ordinare per nomi o numeri di colonne di output, 
non per espressioni.
  </para>
 </sect1>


 <sect1 id="queries-limit">
  <title><literal>LIMIT</literal> e <literal>OFFSET</literal></title>

  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

  <para>
<literal>LIMIT</literal> e <literal>OFFSET</literal> permettono di ricavare giusto
una porzione delle righe che sono generate dal resto della query:
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>

  <para>
Se viene specificato un limite, non più di quelle righe saranno restituite
(ma possibilmente meno, se la query stessa produce meno righe).
<literal>LIMIT ALL</literal> è lo stesso che omettere la clausola <literal>LIMIT</literal>.
  </para>

  <para>
<literal>OFFSET</literal> dice di saltare quel numero di righe prima di iniziare 
a restituire righe. <literal>OFFSET 0</literal> è lo stesso che omettere la clausola 
<literal>OFFSET</literal>, e <literal>LIMIT NULL</literal> è lo stesso di
omettere la clausola <literal>LIMIT</literal>. Se sia <literal>OFFSET</literal>
che <literal>LIMIT</literal> appaiono, allora <literal>OFFSET</literal> righe sono
saltate prima di cominciare a contare le <literal>LIMIT</literal> righe che 
sono restituite.
  </para>

  <para>
Quando si usa <literal>LIMIT</literal>, è importante usare una clausola 
<literal>ORDER BY</literal> che costringe le righe risultanti ad avere un ordinamento
unico. Altrimenti si otterrà un sottoinsieme imprevedibile di
righe della query. Si potrebbero volere dalla decima alla ventesima
riga, ma dalla decima alla ventesima in quale ordine? L'ordinamento è sconosciuto,
a meno che non sia specificato con <literal>ORDER BY</literal>.
  </para>

  <para>
L'ottimizzatore della query prende in considerazione <literal>LIMIT</literal> quando
genera un piano della query, per cui è molto probabile ottenere diversi
piani (contenenti diversi ordinamenti delle righe) in funzione di cosa viene dato
a <literal>LIMIT</literal> e <literal>OFFSET</literal>.  Quindi, usando
differenti valori di <literal>LIMIT</literal>/<literal>OFFSET</literal> per selezionare
diversi sottoinsiemi del risultato di una query  <emphasis>si otterrenno
risultati inconsistenti</emphasis> a meno che non si imponga un risultato
prevedibile ordinando con <literal>ORDER BY</literal>. Questo non è un bug; è
una conseguenza relativa al fatto che SQL non promette di consegnare
il risultato di una query in un particolare ordine a meno che non venga utilizzato
<literal>ORDER BY</literal> per vincolare l'ordine.
  </para>

  <para>
Le righe saltate da una clausola <literal>OFFSET</literal> devono sempre essere 
calcolate all'interno del server; altrimento un <literal>OFFSET</literal> grande
potrebbe essere inefficiente.
  </para>
 </sect1>


 <sect1 id="queries-values">
  <title>Elenci <literal>VALUES</literal></title>

  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>

  <para>
<literal>VALUES</literal> fornisce un modo per generare una <quote>tabella costante</quote>
che possa essere usata in una query senza dovere effettivamente creare e popolare 
una tabella su disco. La sintassi è
<synopsis>
VALUES ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) [, ...]
</synopsis>
Ogni elenco tra parentesi di espressioni genera una riga nella tabella.
Gli elenchi devono avere lo stesso numero di elementi (per es., il numero
di colonne nella tabella), e le voci corrispondenti in ogni elenco devono
avere tipi di dato compatibili. L'effettivo tipo di dato assegnato ad ogni colonna
del risultato viene determinato usando le stesse regole della <literal>UNION</literal>
(si veda <xref linkend="typeconv-union-case"/>).
  </para>

  <para>
   As an example:
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

restituirà una tabella di due colonne e tre righe. È effettivamente equivalente a:
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

In maniere predefinita, <productname>PostgreSQL</productname> assegna i nomi
<literal>column1</literal>, <literal>column2</literal> ecc. alle colonne di una tabella
<literal>VALUES</literal>. I nomi delle colonne non sono specificati dallo standard SQL
e sistemi di database diversi lo fanno in maniera diversa, per questo di solito è preferibile
sovrascrivere i nomi predefiniti con un elenco di alias di tabella.
  </para>

  <para>
Sintatticamente,  <literal>VALUES</literal> seguito da elenchi di espressioni viene trattato come equivalente a:
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
e può apparire ovunque possa una <literal>SELECT</literal>. Per esempio, è possibile usarlo
come parte di una <literal>UNION</literal>, o aggiungerci una 
<replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>,
<literal>LIMIT</literal>, e/o <literal>OFFSET</literal>). <literal>VALUES</literal>
è usato comunemente come sorgente di dati in un comando <command>INSERT</command>,
ed anche come sottoquery.
  </para>

  <para>
Per maggiori informazioni si veda <xref linkend="sql-values"/>.
  </para>

 </sect1>


 <sect1 id="queries-with">
  <title>Query <literal>WITH</literal></title>

  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>

  <indexterm>
   <primary>espressione comune di tabella</primary>
   <see>WITH</see>
  </indexterm>

  <para>
<literal>WITH</literal> fornisce un modo di scrivere sottoquery per l'uso in una query
<literal>SELECT</literal> più grande. Le sottoquery possono essere pensate come la definizione
di tabelle temporanee che esistono solo per questa query. Un uso di questa funzionalità
è di suddividere query complicate in parti più semplici. Un esempio è:

<programlisting>
WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

che mostra le vendite totali per prodotto solo nelle regioni con vendite maggiori.
Questo esempio pooteva essere scritto senza la <literal>WITH</literal>,
ma avremmo avuto bisogno di due livelli di sotto-SELECT annidati. È un po' più semplice 
seguire questa strada.
  </para>

  <para>
Il modificatore opzionale <literal>RECURSIVE</literal> trasforma <literal>WITH</literal>
da una mera convenienza sintattica a una caratteristica che realizza cose
altrimenti non possibili nello standard SQL. Usando
<literal>RECURSIVE</literal>, una query <literal>WITH</literal> può riferirsi al proprio 
output. Un esempio molto semplice è la query per sommare interi da 1 
a 100:

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

La forma generale di una query  <literal>WITH</literal> ricorsiva è sempre un 
<firstterm>termine non-ricorsivo</firstterm>, quindi <literal>UNION</literal> (o
<literal>UNION ALL</literal>) e poi un 
<firstterm>termine ricorsivo</firstterm>, dove solo il termine ricorsivo può contenere
un riferimento all'output proprio della query. Questo ti query viene esegito nel seguente modo:
  </para>

  <procedure>
   <title>Valutazione di query ricorsive</title>

   <step performance="required">
    <para>
Valutare il termine non-ricorsivo. Per <literal>UNION</literal> (ma non per 
<literal>UNION ALL</literal>), scartare righe duplicate. Includere tutte le righe rimanenti
nel risultato della query ricorsiva, inoltre posizionarle in una 
<firstterm>tabella di lavoro</firstterm> temporanea.
    </para>
   </step>

   <step performance="required">
    <para>
A patto che la tabella di lavoro non sia vuota, ripetere questi passi:
    </para>
    <substeps>
     <step performance="required">
      <para>
Valutare il termine ricorsivo, sostituendo l'attuale contenuto della
tabella di lavoro per il riferimento ricorsivo a sè stessa.
Per <literal>UNION</literal> (ma non per <literal>UNION ALL</literal>), scartare
le righe duplicate e le righe che duplicano qualsiasi riga risultante precedente.
Includere tutte le rimanenti righe nel risultato della query ricorsiva, e 
posizionarle in una <firstterm>tabella intermedia</firstterm> temporanea.
      </para>
     </step>

     <step performance="required">
      <para>
Sostituire il contenuto della tabella di lavoro con il contenuto della tabella intermedia,
quindi svuotare la tabella intermedia.
      </para>
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
   <para>
A rigor di termini, questo processo si chiama iterazione, non ricorsione, ma 
<literal>RECURSIVE</literal> è la terminologia scelta dalla commissione per lo standard SQL.
   </para>
  </note>

  <para>
Nel'esempio sopra, la tabella di lavoro ha solo una singola riga per ogni passo,
e prende i valori da 1 a 100 in passi successivi. Nel 100esimo passo, 
non c'è nessuno output, in conseguenza della clausola <literal>WHERE</literal>,
e quindi la query termina.
  </para>

  <para>
Le query ricorsive sono usate tipicamente per gestire dati gerarchici o
strutturati ad albero. Un esempio utile è questa query per trovare tutte le sottoparti 
dirette e indirette di un prodotto, data solo una tabella che mostra 
inclusioni immediate:

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>

  <para>
Quando si lavora con query ricorsive è importante essere sicuri che
la parte ricorsiva della query eventualmente non restituirà tuple,
altrimenti la query effettuerà loop indefinitamente. Qualche volta, usando 
<literal>UNION</literal> invece di <literal>UNION ALL</literal> puà risolvere la questione
scartando righe che duplicano righe di output precedenti. Comunque, spesso un
ciclo non coinvolge righe di output che sono completamente duplicate: può essere necessario
controllare solo uno o pochi campi per vedere se lo stesso punto è stato raggiunto prima.
Il metodo standard per gestire queste situazioni è di calcolare
un array dei valori già visitati. Per esempio, considerare
la seguente query che cerca una tabella <structname>graph</structname> usando un campo
<structfield>link</structfield>:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
        SELECT g.id, g.link, g.data, 1
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1
        FROM graph g, search_graph sg
        WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   This query will loop if the <structfield>link</structfield> relationships contain
   cycles.  Because we require a <quote>depth</quote> output, just changing
   <literal>UNION ALL</literal> to <literal>UNION</literal> would not eliminate the looping.
   Instead we need to recognize whether we have reached the same row again
   while following a particular path of links.  We add two columns
   <structfield>path</structfield> and <structfield>cycle</structfield> to the loop-prone query:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
        SELECT g.id, g.link, g.data, 1,
          ARRAY[g.id],
          false
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1,
          path || g.id,
          g.id = ANY(path)
        FROM graph g, search_graph sg
        WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>

   Aside from preventing cycles, the array value is often useful in its own
   right as representing the <quote>path</quote> taken to reach any particular row.
  </para>

  <para>
   In the general case where more than one field needs to be checked to
   recognize a cycle, use an array of rows.  For example, if we needed to
   compare fields <structfield>f1</structfield> and <structfield>f2</structfield>:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
        SELECT g.id, g.link, g.data, 1,
          ARRAY[ROW(g.f1, g.f2)],
          false
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1,
          path || ROW(g.f1, g.f2),
          ROW(g.f1, g.f2) = ANY(path)
        FROM graph g, search_graph sg
        WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>
  </para>

  <tip>
   <para>
    Omit the <literal>ROW()</literal> syntax in the common case where only one field
    needs to be checked to recognize a cycle.  This allows a simple array
    rather than a composite-type array to be used, gaining efficiency.
   </para>
  </tip>

  <tip>
   <para>
    The recursive query evaluation algorithm produces its output in
    breadth-first search order.  You can display the results in depth-first
    search order by making the outer query <literal>ORDER BY</literal> a
    <quote>path</quote> column constructed in this way.
   </para>
  </tip>

  <para>
   A helpful trick for testing queries
   when you are not certain if they might loop is to place a <literal>LIMIT</literal>
   in the parent query.  For example, this query would loop forever without
   the <literal>LIMIT</literal>:

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
</programlisting>

   This works because <productname>PostgreSQL</productname>'s implementation
   evaluates only as many rows of a <literal>WITH</literal> query as are actually
   fetched by the parent query.  Using this trick in production is not
   recommended, because other systems might work differently.  Also, it
   usually won't work if you make the outer query sort the recursive query's
   results or join them to some other table.
  </para>

  <para>
   A useful property of <literal>WITH</literal> queries is that they are evaluated
   only once per execution of the parent query, even if they are referred to
   more than once by the parent query or sibling <literal>WITH</literal> queries.
   Thus, expensive calculations that are needed in multiple places can be
   placed within a <literal>WITH</literal> query to avoid redundant work.  Another
   possible application is to prevent unwanted multiple evaluations of
   functions with side-effects.
   However, the other side of this coin is that the optimizer is less able to
   push restrictions from the parent query down into a <literal>WITH</literal> query
   than an ordinary sub-query.  The <literal>WITH</literal> query will generally be
   evaluated as stated, without suppression of rows that the parent query
   might discard afterwards.  (But, as mentioned above, evaluation might stop
   early if the reference(s) to the query demand only a limited number of
   rows.)
  </para>

 </sect1>

</chapter>

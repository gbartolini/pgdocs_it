<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="ddl">
 <title>Definizione dei dati</title>

 <para>
    Questo capitolo tratta la creazione delle strutture del database che
    andranno a contenere i dati. In un database relazionale, i dati grezzi sono
    memorizzati in tabelle. La maggior parte di questo capitolo è dedicata a
    illustrare come le tabelle siano create e modificate e quali caratteristiche siano
    a disposizione dell'amministratore per il controllo dei dati.
    Successivamente, verrà affrontato come organizzare le tabelle in
    schemi, e come assegnare privilegi alle tabelle. Infine,
    verranno brevemente esposte le altre funzionalità riguardanti la memorizzazione dei dati,
    come ereditarietà, viste, funzioni e trigger.
 </para>

 <sect1 id="ddl-basics">
  <title>Fondamenti sulle Tabelle</title>

  <indexterm zone="ddl-basics">
   <primary>tabella</primary>
  </indexterm>

  <indexterm>
   <primary>riga</primary>
  </indexterm>

  <indexterm>
   <primary>colonna</primary>
  </indexterm>

  <para>
    Una tabella, in un database relazionale, è molto simile a una tabella sulla carta: essa
    consiste di righe e colonne. Il numero e l'ordine delle colonne
    è fisso, ed ogni colonna ha un nome. Il numero di righe è
    variabile &mdash; riflette la quantità di dati immagazzinati in un dato momento.
    SQL non dà alcuna garanzia circa l'ordine delle righe in una
    tabella. Quando una tabella viene letta, le righe appariranno in ordine non specificato,
    a meno che un preciso ordinamento non sia esplicitamente richiesto. Questo argomento è trattato in <xref
    linkend="queries"/>. Inoltre, SQL non assegna identificatori unici
    alle righe, così è possibile avere diverse righe
    completamente uguali in una tabella. Questa è una conseguenza del
    modello matematico sottostante ad SQL, ma di solito non rappresenta il comportamento desiderato.
    Questo argomento verrà comunque affrontato più avanti nel corso di questo capitolo.
  </para>

  <para>
    Ogni colonna ha un tipo di dato. Il tipo di dato regola l'insieme di
    possibili valori che può essere assegnato a una colonna e fornisce
    semantica ai dati immagazzinati nella colonna stessa (in modo da poter essere utilizzati per calcoli computazionali). 
    Per esempio, una colonna dichiarata come tipo
    numerico non accetterà stringhe di testo arbitrarie, e i dati
    contenuti in quella colonna potranno essere usati per calcoli matematici.
    Al contrario, una colonna dichiarata per contenere stringhe di caratteri,
    accetterà quasi ogni tipo di dato ma non si presterà
    a calcoli matematici, benché altre operazioni, come la concatenazione di stringhe,
    siano possibili.
  </para>

  <para>
    <productname>PostgreSQL</productname> include un insieme rilevante di tipi di dato
    che risultano adatti per molte applicazioni. Gli utenti possono inoltre
    definire i loro propri tipi di dato. Molti dei tipi di dato nativi hanno
    nomi e semantica ovvia, perciò si rimanda al <xref 
    linkend="datatype"/> per una spiegazione dettagliata. Alcuni dei tipi di dato usati frequentemente sono
    <type>integer</type> per i numeri interi, <type>numeric</type> per
    i numeri a virgola mobile, <type>text</type> per stringhe
    di carattere, <type>date</type> per le date, <type>time</type> per
    orari e <type>timestamp</type> per valori che contengono
    sia data che orario.
  </para>

  <indexterm>
   <primary>tabella</primary>
   <secondary>creazione</secondary>
  </indexterm>

  <para>
    Per creare una tabella, è possibile utilizzare il comando opportunamente chiamato 
    <xref linkend="sql-createtable" />.
    All'interno di questo comando l'utente ha la possibilità di specificare, nella forma minima, un nome per la nuova tabella, i
    nomi delle colonne e il tipo di dato per ogni colonna. Per
    esempio:
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
    Questo comando crea una tabella chiamata <literal>my_first_table</literal> con
    due colonne. La prima colonna si chiama
    <literal>first_column</literal> e ha un tipo di dato
    <type>text</type>; la seconda colonna si chiama
    <literal>second_column</literal> ed è di tipo <type>integer</type>.
    I nomi di tabella e colonna seguono la sintassi per gli identificatori, descritta
    nella <xref linkend="sql-syntax-identifiers"/>. Anche i nomi dei tipi sono
    di solito identificatori, ma esistono delle eccezioni. Si noti che
    la lista di colonne è separata da virgole e racchiusa all'interno di parentesi.
  </para>

  <para>
    L'esempio precedente risulta molto forzato. In condizioni normali,
    è buona norma assegnare nomi a tabelle e colonne in modo significativo. Un esempio più realistico è rappresentato da:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   (Il tipo <type>numeric</type> può contenere componenti frazionarie,
    tipico di somme in valuta, ad esempio).
  </para>

  <tip>
   <para>
        In fase di creazione di tabelle collegate tra loro è buona norma scegliere
        un modello coerente per i nomi di tabelle e colonne. Ad esempio, è possibile scegliere se utilizzare nomi di tabella al singolare oppure al plurale, entrambe sostenute da due correnti di pensiero contrapposte.
    </para>
  </tip>

  <para>
    Esiste un limite sul numero di colonne che una tabella può contenere.
    A seconda dei tipi di colonna, il limite è compreso tra 250 e 1600.
    Comunque, definire una tabella con un numero di colonne anche minimamente vicino al limite,
    è molto inusuale e spesso è sintomo di un design discutibile.
  </para>

  <indexterm>
   <primary>tabella</primary>
   <secondary>rimozione</secondary>
  </indexterm>

  <para>
    Una tabella non più necessaria può essere rimossa con il comando
   <xref linkend="sql-droptable"/> .
    Per esempio:
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
    Il tentativo di rimozione di una tabella non esistente è considerato un errore.
    Ciò nonostante, nei file di script SQL è molto comune
    eliminare in modo incondizionato ogni tabella prima di crearla, ignorando qualsiasi messaggio di errore.
    In questo modo, lo script è in grado di funzionare a prescindere dall'esistenza della tabella (è possibile utilizzare la variante <literal>DROP TABLE IF EXISTS</literal>
    per evitare i messaggi di errore, anche se non contemplata dallo standard SQL).
  </para>

  <para>
    Per la modifica di tabelle esistenti, fare riferimento alla <xref
   linkend="ddl-alter"/>, descritta più avanti in questo capitolo.
  </para>

  <para>
    Gli strumenti discussi fino a questo punto, permettono di creare tabelle completamente funzionanti.
    Il resto di questo capitolo riguarda funzionalità aggiuntive
    alla definizione di tabelle per garantire l'integrità dei dati,
    la sicurezza o per semplice comodità. L'utente ansioso di riempire le proprie tabelle con dati
    può saltare direttamente al <xref linkend="dml"/> e leggere il resto di questo capitolo in un secondo momento.
  </para>
 </sect1>


 <sect1 id="ddl-default">
  <title>Valori di Default</title>

  <indexterm zone="ddl-default">
   <primary>valore di default</primary>
  </indexterm>

  <para>
    Ad una colonna può essere assegnato un valore di default. Quando una riga
    viene creata e non sono specificati valori per alcune colonne, queste 
    verranno riempite con i loro rispettivi valori di default. Un
    comando di manipolazione dei dati può anche richiedere esplicitamente che una colonna
    sia impostata al suo valore di default, senza dover sapere che valore sia
    (dettagli riguardanti i comandi di manipolazione dei dati sono nel <xref linkend="dml"/>).
  </para>

  <para>
   <indexterm><primary>valore null</primary><secondary>valore di default</secondary></indexterm>
    Se un valore di default non è dichiarato esplicitamente, il valore di default è il
    valore null. Ciò di solito ha senso in quanto un valore null può
    essere considerato rappresentativo di un dato non conosciuto o non definito.
  </para>

  <para>
    Nella definizione di una tabella, i valori di default sono elencati dopo il tipo di dato della colonna.
    Per esempio:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
    Il valore di default può essere un'espressione, che verrà
    valutata ogniqualvolta il valore di default viene inserito
    (<emphasis>non</emphasis> quando la tabella viene creata).  Un esempio molto comune
    è assegnare a una colonna di tipo <type>timestamp</type> un valore di default <literal>CURRENT_TIMESTAMP</literal>,
    che verrà impostato al momento dell'inserimento della riga. Un altro esempio comune
    è la generazione di un <quote>numero di serie</quote> per ogni riga.
    In <productname>PostgreSQL</productname> questo viene tipicamente fatto con 
    qualcosa simile a:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
    dove la funzione <literal>nextval()</literal> fornisce valori successivi  
    da una <firstterm>sequenza</firstterm> (si veda la <xref 
    linkend="functions-sequence"/>). Questo espediente è talmente comune
    da avere una speciale scorciatoia:
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   L'abbreviazione <literal>SERIAL</literal> è discussa approfonditamente nella <xref
   linkend="datatype-serial"/>.
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Vincoli</title>

  <indexterm zone="ddl-constraints">
   <primary>vincolo</primary>
  </indexterm>

  <para>
    I tipi di dato sono un modo per limitare il genere dei dati che possono essere immagazzinati in una tabella.
    Il vincolo che forniscono, tuttavia è per molte applicazioni troppo grossolano.
    Per esempio, una colonna contenente il prezzo di un prodotto
    dovrebbe, probabilmente, accettare solo valori positivi. Ma non c'è nessun
    tipo di dato standard che accetti esclusivamente numeri positivi. Un altro problema è
    rappresentato dal voler vincolare il dato di una colonna rispetto ai dati di
    altre colonne o persino righe. Ad esempio, in una tabella contenente informazioni
    su un prodotto, ci dovrebbe essere soltanto una riga per ogni numero di prodotto.
  </para>

  <para>
    Per questo, SQL permette di definire vincoli sulle colonne e sulle
    tabelle. I vincoli permettono di controllare a proprio piacimento i dati contenuti nelle tabella.
    Se un utente tenta di immagazzinare dati in una colonna
    violando un vincolo, viene generato un errore. Questo si applica
    anche se il valore proviene dalla definizione del valore di default.
  </para>

  <sect2>
   <title>Vincolo Check</title>

   <indexterm>
    <primary>vincolo check</primary>
   </indexterm>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>check</secondary>
   </indexterm>

   <para>
        Il vincolo check è del tipo più generico. Permette
        di specificare che il valore di una certa colonna debba soddisfare
        un'espressione booleana (valore-verità). Per esempio, per richiedere prezzi positivi
        per i prodotti, usare:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
        La definizione di vincolo viene dopo il tipo di dato,
        esattamente come le definizioni dei valori di default. I valori di default e i vincoli
        possono essere elencati in qualsiasi ordine. Un vincolo check
        consiste della parola chiave <literal>CHECK</literal> seguita da un'espressione
        in parentesi. L'espressione del vincolo check dovrebbe 
        coinvolgere la colonna vincolata, altrimenti il vincolo 
        non avrebbe molto senso.
   </para>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>nome</secondary>
   </indexterm>

   <para>
        Si può anche dare un nome al vincolo. Questo chiarifica
        i messaggi di errore e permette di individuare il vincolo quando 
        questo debba essere modificato. La sintassi è:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
        Così, per specificare un vincolo con nome, usare la parola chiave
        <literal>CONSTRAINT</literal> seguita da un identificatore e
        dalla definizione del vincolo (qualora non venga specificato un nome in modo esplicito,
        il sistema ne sceglierà uno).
   </para>

   <para>
        Un vincolo check può anche riguardare diverse colonne. Si supponga
        di avere un prezzo regolare e un prezzo scontato, e di volersi
        assicurare che il prezzo scontato sia minore del prezzo regolare:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>

   <para>
        I primi due vincoli dovrebbero essere familiari. Il terzo
        usa una nuova sintassi. Esso non è vincolato a una particolare colonna
        ed appare invece come un oggetto separato all'interno della lista delle colonne separate da virgola.
        Le definizioni delle colonne e dei vincoli possono essere elencate in ordine sparso.
   </para>

   <para>
        Il terzo è comunemente detto <emphasis>vincolo di tabella</emphasis> perchè non è legato a una particolare
        definizione di colonna. I vincoli di colonna possono anche
        essere scritti come vincoli di tabella, mentre il contrario non è possibile,
        dato che un vincolo di colonna si riferisce solo alla colonna
        per cui è definito (<productname>PostgreSQL</productname> non
        impone questa regola, ma dovrebbe essere seguita qualora si richieda che le definizioni delle tabelle
        funzionino con altri sistemi di database). L'esempio precedente avrebbe potuto
        essere scritto in uno dei seguenti modi:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    oppure:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
     È una questione di gusto.
   </para>

   <para>
        I nomi possono essere assegnati ai vincoli di tabella nello stesso modo 
        in cui vengono assegnati ai vincoli di colonna:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>

   <indexterm>
    <primary>valore null</primary>
    <secondary sortas="check constraints">con vincoli check</secondary>
   </indexterm>

   <para>
        Un vincolo check è soddisfatto se 
        l'espressione restituisce un valore true o null. Dato che la maggior parte delle 
        espressioni restituirà null se uno degli operandi è null,
        esse non impediranno valori null nelle colonne vincolate. Per 
        assicurare che una colonna non contenga valori null, può essere usato il vincolo not-null
        descritto nella prossima sezione.
   </para>
  </sect2>

  <sect2>
   <title>Vincolo Not-Null</title>

   <indexterm>
    <primary>vincolo not-null</primary>
   </indexterm>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
        Un vincolo not-null semplicemente specifica che una colonna non può assumere in nessun caso
        il valore null. Un esempio di sintassi:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>

   <para>
        Un vincolo non-null è sempre scritto come un vincolo di colonna. Un    
        vincolo not-null funziona come un vincolo check della forma
        <literal>CHECK (<replaceable>column_name</replaceable>
        IS NOT NULL)</literal>, ma in 
        <productname>PostgreSQL</productname> creare esplicitamente un 
        vincolo not-null è più efficiente. Il rovescio della medaglia è che non è possibile
        dare esplicitamente nomi ai vincoli not-null creati in questo modo.
   </para>

   <para>
        Ovviamente, una colonna può avere più di un vincolo. Semplicemente scrivere
        i vincoli uno dopo l'altro:
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
        L'ordine non conta. Esso non determina necessariamente in quale ordine
        i vincoli sono controllati.
   </para>

   <para>
        Il vincolo <literal>NOT NULL</literal> ha un inverso: il 
        vincolo <literal>NULL</literal>. Questo non significa che la colonna
        debba essere nulla, che sarebbe sicuramente inutile. Invece, questo 
        seleziona semplicemente il comportamento di default della colonna sia null.
        Il vincolo <literal>NULL</literal> non è presente nello standard SQL 
        e non dovrebbe essere usato in applicazioni portabili (è stato
        aggiunto a <productname>PostgreSQL</productname> per essere 
        compatibile con alcuni altri sistemi di database). Ad alcuni utenti, comunque,
        piace perchè rende facile cambiare il vincolo in uno script.
        Per esempio, potresti partire con:
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
        e poi inserire la parola chiave <literal>NOT</literal> dove desiderato.
   </para>

   <tip>
    <para>
        In molti progetti di database la maggioranza delle colonne dovrebbe essere segnata come
        not null.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Vincolo Unique</title>

   <indexterm>
    <primary>vincolo unique</primary>
   </indexterm>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>unique</secondary>
   </indexterm>

   <para>
        I vincoli unique assicurano che i dati contenuti in una colonna o un
        gruppo di colonne siano unici rispetto a tutte le righe nella
        tabella. La sintassi è:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
        quando scritto come vincolo di colonna, e:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
        quando scritto come vincolo di tabella.
   </para>

   <para>
        Se un vincolo unique si riferisce a un gruppo di colonne, le colonne
        sono elencate separate da virgole_
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
        Questo specifica che la combinazione di valori nelle colonne indicate 
        è unica in tutta la tabella, sebbene ogni singola colonna non necessiti di essere
        (e di solito non lo è) unica.
   </para>

   <para>
        È possibile assegnare un nome per un vincolo unique, nel solito modo:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
        Aggiungere un vincolo unique creerà automaticamente un indice btree nella 
        colonna, o gruppo di colonne, usate nel vincolo.
   </para>

   <indexterm>
    <primary>valore null</primary>
    <secondary sortas="unique constraints">con vincolo unique</secondary>
   </indexterm>

   <para>
        In generale, un vincolo unique è violato quando c'è più di 
        una riga nella tabella dove i valori di tutte le colonne
        incluse nel vincolo sono uguali.
        Comunque, due valori null non sono considerati uguali in questa 
        comparazione. Questo significa che anche in presenza di un
        vincolo unique è possibile immagazzinare righe duplicate 
        che contengono un valore null in almeno una delle colonne vincolate.
        Questo comportamento è conforme allo standard SQL, ma abbiamo 
        sentito che altri database SQL potrebbero non seguire questa regola. Così,
        stai attento quando sviluppi applicazioni che debbano essere portabili.
   </para>
  </sect2>

  <sect2>
   <title>Chiavi Primarie</title>

   <indexterm>
    <primary>chiave primaria</primary>
   </indexterm>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>chiave primaria</secondary>
   </indexterm>

   <para>
        Tecnicamente, un vincolo chiave primaria è semplicemente una combinazione del
        vincolo unique e del vincolo not-null. Così, le due tabelle seguenti
        accettano gli stessi dati:
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
        Le chiavi primarie possono anche vincolare più di una colonna; La sintassi 
        è simile ai vincoli unique:
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

   <para>
        Una chiave primaria indica che una colonna o gruppo di colonne può essere
        usata come identificatore unico per le righe nella tabella. Questa è una
        diretta conseguenza della definizione di chiave primaria (notare che 
        un vincolo unique non fornisce, da solo, un identificatore unico,
        perchè non esclude i valori null). Questo è utile sia per
        scopi di socumentazione, sia per applicazioni client. Per esempio,
        un'applicazione GUI che permette la modifica dei valori di una riga probabilmente ha bisogno
        di sapere la chiave primaria di una tabella per essere capace di identificare le righe
        unicamente.
   </para>

   <para>
        Aggiungere una chiave primaria creerà automaticamente un indice btree unico
        sulla colonna o gruppo di colonne usate nella chiave primaria.
   </para>

   <para>
        Una tabella può avere al più una chiave primaria. (Ci possono essere qualsiasi numero
        di vincoli unique e not-null, che sono funzionalmente la stessa 
        cosa, ma solo uno può essere identificato come chiave primaria.)
        La teoria dei database relazionali
        afferma che ogni tabella deve avere una chiave primaria. Questa regola non 
        è forzata da <productname>PostgreSQL</productname>, ma è 
        generalmente preferibile seguirla.
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>Chiavi Esterne</title>

   <indexterm>
    <primary>chiave esterna</primary>
   </indexterm>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>chiave esterna</secondary>
   </indexterm>

   <indexterm>
    <primary>integrità referenziale</primary>
   </indexterm>

   <para>
        Un vincolo chiave esterna specifica che i valori in una colonna (o
        un gruppo di colonne) deve essere uguale ai valori presenti in qualche riga
        di un'altra tabella.
        Questo mantiene l'<firstterm>integrità referenziale</firstterm>
        tra due tabelle correlate.
   </para>

   <para>
        Mettiamo di avere la tabella products, che abbiamo usato già diverse volte:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
        Assumiamo inoltre di avere una tabella che tiene gli ordini di 
        questi prodotti. Vogliamo assicurare che la tabella degli ordini contengano solo
        ordini di prodotti che esistono realmente. Così definiamo un vincolo chiave esterna
        nella tabella ordini che fa riferimento alla tabella prodotti:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
        Ora è impossibile creare ordini con 
        valori di <structfield>product_no</structfield> che non appaiano nella tabella prodotti.
   </para>

   <para>
        Diciamo che in questa situazione la tabella ordini è la tabella
        <firstterm>referente</firstterm> e la tabella prodotti è
        la tabella <firstterm>referenziata</firstterm>. Similarmente, ci sono
        colonne referenti e referenziate.
   </para>

   <para>
        È possibile anche abbreviare il comando sopra:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
        perchè in assenza di un elenco di colonne, la chiave primaria della
        tabella referenziata è usata come colonna/e referenziate.
   </para>

   <para>
        Una chiave esterna puà anche vincolare e referenziare un gruppo di colonne.
        Come al solito, deve essere scritta nella forma dei vincoli di tabella.
        Ecco un esempio di sintassi contratta:
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
        Certamente, il numero e il tipo delle colonne vincolate necessita di 
        coincidere col numero e il tipo delle colonne referenziate.
   </para>

   <para>
        Si può assegnare un nome per un vincolo chiave esterna,
        nel solito modo.
   </para>

   <para>
        Una tabella puà contenere più di un vincolo chiave esterna. Questo è
        usato per implementare relazioni molti-a-molti tra le tabelle. Mettiamo
        di avere tabelle riguardanti prodotti e ordini, ma ora si vuole 
        permettere a un ordine di contenere molti prodotti (la struttura precedente non 
        lo permetteva). Usare questa struttura di tabella:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
        Notare che la chiave primaria si sovrappone con le chiavi esterne nell'ultima tabella.
   </para>

   <indexterm>
    <primary>CASCADE</primary>
    <secondary>azione chiave esterna</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>azione chiave esterna</secondary>
   </indexterm>

   <para>
        Sappiamo che le chiavi esterne non permettono la creazione di ordini 
        che non siano correlati a qualche prodotto. Ma cosa succede se un prodotto viene 
        rimosso dopo che un ordine che lo referenzia viene creato? SQL ti permette di
        gestire questa situazione. Intuitivamente, abbiamo diverse opzioni:
    <itemizedlist spacing="compact">
     <listitem><para>Non permettere la cancellazione di un prodotto referenziato</para></listitem>
     <listitem><para>Cancellare anche gli ordini</para></listitem>
     <listitem><para>Qualcos'altro?</para></listitem>
    </itemizedlist>
   </para>

   <para>
        Per spiegarlo, implementiamo il seguente comportamento sulla relazione molti-a-molti
        dell'esempio superiore: quando qualcuno vuole 
        rimuovere un prodotto che è referenziato da un ordine (attraverso 
        <literal>order_items</literal>), noi non glielo permettiamo. Se qualcuno
        rimuove un ordine, anche gli articoli dell'ordine verranno rimossi:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>

   <para>
        Le cancellazioni ristrette e in cascata sono le due opzioni più comuni.
        <literal>RESTRICT</literal> previene la cancellazione di una  
        riga referenziata.  <literal>NO ACTION</literal> significa che se esiste
        una riga referenziante quando il vincolo viene controllato, viene generato
        un errore; questo è il comportamento di default se non specifichi niente.
        (La differenza essenziale tra queste due scelte è che
        <literal>NO ACTION</literal> permette che il controllo venga rinviato 
        successivamente nella transazione, mentre <literal>RESTRICT</literal> no.)
        <literal>CASCADE</literal> specifica che quando una riga referenziata viene cancellata,
        anche la/e riga/e referenti dovrebbero essere cancellate.
        Ci sono altre due opzioni:
        <literal>SET NULL</literal> e <literal>SET DEFAULT</literal>.
        Queste causano che le colonne referenti siano settate a null o al valore di default,
        rispettivamente, quando la riga referenziata viene cancellata.
        Notare che questo non ti esclude dall'avere vincoli.
        Per esempio, se un'azione specifica <literal>SET DEFAULT</literal>,
        ma il valore di default non soddisfa la chiave esterna, l'operazione
        fallirà.
   </para>

   <para>
    Analogous to <literal>ON DELETE</literal> there is also
        Analogamente a <literal>ON DELETE</literal> c'è anche 
        <literal>ON UPDATE</literal>, che è invocata quando una colonna referenziata viene
        cambiata (aggiornata). Le azioni possibili sono le stesse.
   </para>

   <para>
        Dato che un <command>DELETE</command> di una riga da una tabella referenziata
        o un <command>UPDATE</command> di una colonna referenziata richiederanno
        una scansione della tabella referente per la ricerca delle righe che soddisfano il vecchio valore, 
        spesso è una buona idea indicizzare le colonne referenti. Siccome questo
        non è sempre necessario, e ci sono molte scelte disponibili su come 
        indicizzare, la dichiarazione di una chiave esterna non crea automaticamente un indice
        sulla colonna referente.
   </para>

   <para>
        Maggiori informazioni circa l'aggiornamento e la cancellazione di dati si trovano in <xref
    linkend="dml"/>.
   </para>

   <para>
        Infine, dobbiamo menzionare che una chiave esterna deve referenziare 
        colonne che siano o chiavi primarie o vincolate unique.
        Se la chiave esterna referenzia un vincolo unique, ci sono alcune 
        possibilità aggiuntive su come i valori null sono combinati.
        Questi sono spiegati nella documentazione riguardante
    <xref linkend="sql-createtable"/>.
   </para>
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
   <title>Vincoli Exclusion</title>

   <indexterm>
    <primary>vincolo exclusion</primary>
   </indexterm>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>exclusion</secondary>
   </indexterm>

   <para>
        I vincoli Exclusion assicurano che se qualsiasi coppia di righe viane comparata sulle
        colonne specificate o su espressioni che usano gli operatori specificati, 
        almeno una di queste comparazioni ritornerà false o null.
        
        La sintassi è:
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>

   <para>
        Vedi anche <link linkend="sql-createtable-exclude"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</command></link> per maggiori dettagli.
   </para>

   <para>
        Aggiungere un vincolo exclusion creerà automaticamente un indice
        del tipo specificato nella dichiarazione del vincolo.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
  <title>Colonne di Sistema</title>

  <para>
        Ogni tabella ha diverse <firstterm>colonne di sistema</firstterm> che sono
        definite implicitamente dal sistema. Perciò, questi nomi non possono essere
        usati come nomi di colonne definiti dall'utente. (Notare che queste
        restrizioni non riguardano se il nome è una parola chiave o no;
        mettere il nome tra parentesi non ti permetterà di scavalcare queste restrizioni.)
        Non preoccuparsi di queste colonne; Basta sapere che esistono.
  </para>

  <indexterm>
   <primary>colonna</primary>
   <secondary>colonna di sistema</secondary>
  </indexterm>

  <variablelist>
   <varlistentry>
    <term><structfield>oid</structfield></term>
    <listitem>
     <para>
      <indexterm>
       <primary>OID</primary>
       <secondary>colonna</secondary>
      </indexterm>
        L'identificatore oggetto (OID oggetto) di una riga. Questa colonna è presente
        solo se la tabella è stata creata usando <literal>WITH
        OIDS</literal>, o se la variabile di configurazione  <xref linkend="guc-default-with-oids"/>
        è settata al momento della creazione della tabella. Questa colonna è del tipo
        <type>oid</type> (stesso nome della colonna); vedi <xref
        linkend="datatype-oid"/> per maggiori informazioni sul tipo..
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>tableoid</structfield></term>
    <listitem>
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>

     <para>
        L'OID della tabella contenente questa riga.  Questa colonna è
        particolarmente utile per query che selezionano da gerarchie di 
        ereditarietà (see <xref linkend="ddl-inherit"/>), dato che senza essa,
        è difficile dire da quale tabella proviene una riga. Il
        <structfield>tableoid</structfield> può essere unito con
        la colonna <structfield>oid</structfield> di
        <structname>pg_class</structname> per ottenere il nome della tabella.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmin</structfield></term>
    <listitem>
     <indexterm>
      <primary>xmin</primary>
     </indexterm>

     <para>
        L'identificatore (ID transazione) della transazione di inserimento per l'attuale versione della riga.
        (Una versione di riga è lo stato individuale di una riga);
        Ogni aggiornamento di una riga crea una nuova versione di riga per la stessa
        riga logica.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmin</structfield></term>
    <listitem>
     <indexterm>
      <primary>cmin</primary>
     </indexterm>

     <para>
        L'identificatore di comando (partendo da zero) all'interno della transazione di inserimento.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmax</structfield></term>
    <listitem>
     <indexterm>
      <primary>xmax</primary>
     </indexterm>

     <para>
        L'identificatore (ID transazione) della transazione di cancellazione, o
        zero per una riga non cancellata. Per questa colonna è possibile essere
        non-zero in una versione di riga visibile. Questo di solito indica che 
        la transazione di cancellazione non è stata ancora eseguita, o che è stato fatto un rollback 
        su  un tentativo di cancellazione.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmax</structfield></term>
    <listitem>
     <indexterm>
      <primary>cmax</primary>
     </indexterm>

     <para>
        L'identificatore di comando all'interno della transazione di cancellazione, o zero.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>ctid</structfield></term>
    <listitem>
     <indexterm>
      <primary>ctid</primary>
     </indexterm>

     <para>
        La locazione fisica della versione di riga all'interno della sua tabella. Notare che
        sebbene <structfield>ctid</structfield> può essere usato per  
        localizzare la versione di riga molto velocemente, il 
        <structfield>ctid</structfield> di una riga cambierà se la riga viene
        aggiornata o mossa dal  <command>VACUUM FULL</command>. Perciò
        <structfield>ctid</structfield> è inutile come identificatore di riga a lungo-termine.
        L'OID, od ancora meglio un numero di serie definito dall'utente,
        dovrebbero essere usati per identificare le righe.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

   <para>
        Gli OID sono quantità a 32-bit, assegnati da un singolo 
        contatore per cluster. In un database grande o vecchio, è possibile
        che il contatore si inceppi. Quindi, è una cattiva abitudine
        assumere che gli OID siano unici, a meno che tu non faccia qualcosa 
        per assicurartene. Se hai bisogno di identificare le righe
        una tabella, l'uso di un generatore di sequence è fortemente raccomandato.
        Comunque, anche gli OID possono essere usati, se vengono prese alcune precauzioni
        addizionali:

    <itemizedlist>
     <listitem>
      <para>
        Un vincolo unique dovrebbe essere creato sulla colonna OID di ogni
        tabella in cui l'OID sarà usato per identificare le righe. Quando 
        un vincolo unique (o un indice unico) esistono, il sistema si prende cura
        di non generare un OID che sia uguale ad una riga già esistente.
        (Ovviamente, questo è possibile solo se la tabella contiene meno
        di 2<superscript>32</superscript> (4 bilioni) di righe, e in pratica la dimensione
        di una tabella dovrebbe essere molto meno di così, o le prestazioni potrebbero risentirne.)
      </para>
     </listitem>
     <listitem>
      <para>
        Gli OID non dovrebbero mai essere considerati unici attraverso le tabelle; Usa
        la combinazione di <structfield>tableoid</structfield> e l'OID della riga se hai 
        bisogno di un identificatore attraverso il database.
      </para>
     </listitem>
     <listitem>
      <para>
            Certamente, le tabelle in questione devono essere create <literal>WITH
            OIDS</literal>. Da <productname>PostgreSQL</productname> 8.1,
            <literal>WITHOUT OIDS</literal> è il default.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
        Anche gli identificatori di transazione sono a 32-bit. In un 
        database vissuto è possibile che gli ID di transazione si inceppino.
        Questo non è un problema fatale se usate procedure di manutenzione appropriate;
        vedi <xref linkend="maintenance"/> per maggiori dettagli.  Non è
        consigliabile, comunque, contare sull'unicità degli ID di transazione
        per il lungo periodo (più di un bilione di transazioni).
   </para>

   <para>
        Anche gli identificatori di comando sono quantità a 32-bit. Questo crea un forte limite 
        di  2<superscript>32</superscript> (4 bilioni) di comandi SQL dentro una 
        singola transazione. In pratica questo limite non è un problema
        &mdash; note che il limite è sul numero di 
        comandi <acronym>SQL</acronym>, non il numero di righe processate. 
        Inoltre, da <productname>PostgreSQL</productname> 8.3, solo i comandi
        che realmente modificano il contenuto del database  consumeranno un identificatore
        di comando.
   </para>
 </sect1>

 <sect1 id="ddl-alter">
  <title>Modifica di Tabelle</title>

  <indexterm zone="ddl-alter">
   <primary>tabella</primary>
   <secondary>modifica</secondary>
  </indexterm>

  <para>
    Quando si crea una tabella e ci si  rende conto di aver commesso un errore, o
    le richieste dell'applicazione sono cambiate, è possibile eliminare la tabella e crearla di nuovo.
    Ma questa non è un'opzione conveniente se la tabella è 
    già riempita con dati, o se la tabella è referenziata da altri oggetti 
    del database (per esempio un vincolo chiave esterna). 
    Perciò  <productname>PostgreSQL</productname> mette a disposizione una famiglia di comandi
        per modificare tabelle esistenti.
    Notare che concettualmente questo è differente dall'alterazione dei dati contenuti nella tabella:
    qui siamo interessati nel modificare la definizione, o la struttura, della tabella.
  </para>

  <para>
   You can:
   <itemizedlist spacing="compact">
    <listitem>
     <para>Aggiungere colonne</para>
    </listitem>
    <listitem>
     <para>Rimuovere colonne</para>
    </listitem>
    <listitem>
     <para>Aggiungere vincoli</para>
    </listitem>
    <listitem>
     <para>Rimuovere vincoli</para>
    </listitem>
    <listitem>
     <para>Cambiare i valori di default</para>
    </listitem>
    <listitem>
     <para>Cambiare i tipi di dato delle colonne</para>
    </listitem>
    <listitem>
     <para>Rinominare colonne</para>
    </listitem>
    <listitem>
     <para>Rinominare tabelle</para>
    </listitem>
   </itemizedlist>

    Tutte queste azioni sono effettuate usando il comando
   <xref linkend="sql-altertable"/>,
    la cui pagina di riferimento contiene dettagli oltre a quelli descritti qui.
  </para>

  <sect2>
   <title>Aggiungere una colonna</title>

   <indexterm>
    <primary>colonna</primary>
    <secondary>aggiungere</secondary>
   </indexterm>

   <para>
        Per aggiungere una colonna, usa il comando:
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
        La nuova colonna è inizialmente riempita con qualunque valore di default sia dato
        (null se non specifici una clausola <literal>DEFAULT</literal> )
   </para>

   <para>
        Puoi anche definire vincoli sulla colonna allo stesso tempo,
        usando la sintassi usuale:
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
        Infatti tutte le opzioni che possono essere applicate alla descrizione di una colonna in
        <command>CREATE TABLE</command> possono essere usate qui. Tieni a mente comunque
        che il valore di default deve soddisfare i vincoli dati, o la 
        <literal>ADD</literal> fallirà. Alternativamente, puoi aggiungere 
        vincoli più tardi (vedi sotto) dopo che hai riempito la nuova colonna 
        correttamente.
   </para>

  <tip>
   <para>
        Aggiungere una colonna con un default richiede l'aggiornamento di ogni riga della 
        tabella (per immagazzinare il valore della nuova colonna). Comunque, se non specifici
        un default, <productname>PostgreSQL</productname> è capace di evitare
        l'aggiornamento fisico. Così se intendi riempire la colonna con
        valori non default principalmente, è meglio aggiungere al colonna senza default,
        inserisci i valori corretti usando <command>UPDATE</command>, e poi aggiungi qualsiasi
        default desirato come descritto sotto.
   </para>
  </tip>
  </sect2>

  <sect2>
   <title>Rimuovere una Colonna</title>

   <indexterm>
    <primary>colonna</primary>
    <secondary>rimuovere</secondary>
   </indexterm>

   <para>
        Per rimuovere una colonna, usa un comando tipo:
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
        Qualsiasi dato nella colonna sparisce. Anche i vincoli di tabella coinvolti nella colonna 
        sono eliminati. Comunque, se la colonna è referenziata da un
        vincolo chiave esterna di un'altra tabella,
        <productname>PostgreSQL</productname> non eliminerà silenziosamente quel
        vincolo. Puoi autorizzare l'eliminazione di tutto quello che depende dalla coklonna
        aggiungendo  <literal>CASCADE</literal>:
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    Vedi <xref linkend="ddl-depend"/> per una descrizione del meccanismo generale che sta sotto.
   </para>
  </sect2>

  <sect2>
   <title>Aggiungere un vincolo</title>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>aggiungere</secondary>
   </indexterm>

   <para>
    To add a constraint, the table constraint syntax is used.  For example:
        Per aggiungere un vincolo, si usa la sintassi dei vincoli di tabella. Per esempio: 
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
        Per aggiungere un vincolo not-null, che non può essere scritto come vincolo di tabella,
        usa questa sintassi:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>

   <para>
        Il vincolo sarà controllato immediatamente, così la tabella dovrà
        soddisfarlo prima che possa essere aggiunto.
   </para>
  </sect2>

  <sect2>
   <title>Rimuovere un Vincolo</title>

   <indexterm>
    <primary>vincolo</primary>
    <secondary>rimuovere</secondary>
   </indexterm>

   <para>
        Per rimuovere un vincolo devi conoscerne il nome. Se gli hai dato 
        un nome allora è semplice. Altrimenti il sistema gli ha assegnato un nome
        generato, che devi scoprire. Il comando 
        <application>psql</application> <literal>\d <replaceable>tablename</replaceable></literal>
        può essere utile qui;
        Anche altre interfaccie potrebbero avere un modo per ispezionare i dettagli di una tabella.
        Quindi il comando è:
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
        (Se hai a che fare con un nome di vincolo generato, tipo <literal>$2</literal>,
        non dimenticare che avrai bisogno di metterlo tra doppie virgolette per renderlo un 
        identificatore valido.)
   </para>

   <para>
        Come con la cancellazione di una colonna, devi aggiungere <literal>CASCADE</literal> se vuoi
        eliminare un vincolo da cui dipende qualcos'altro. Un esempio 
        è che un vincolo chiave esterna dipende da un vincolo unique o chiave primaria 
        sulla/e colonna/e referenziata.
   </para>

   <para>
        Questo funziona allo stesso modo per tutti i tipi di vincoli ad eccezione dei vincoli not-null.    
        Per eliminare un vincolo not null usa:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
        (Ricorda che i vincoli not null non hanno nomi.)
   </para>
  </sect2>

  <sect2>
   <title>Cambiare il Valore di Default di una Colonna</title>

   <indexterm>
    <primary>calore di default</primary>
    <secondary>cambiare</secondary>
   </indexterm>

   <para>
        Per impostare un nuovo default per una colonna, usa un comando tipo:
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
        Notare che questo non interessa nessuna delle righe esistenti nella tabella,
        cambia solamente il default per i futuri comandi  <command>INSERT</command>. 
   </para>

   <para>
        Per rimuovere ogni valore di default, usa:
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
        Effettivamente questo è lo stesso di impostare il default a null.
        Come conseguenza, non è un errore  
        eliminare un default dove non è stato definito, perchè il
        default è implicitamente il valore null.
   </para>
  </sect2>

  <sect2>
   <title>Cambiare il Tipo di Dato di una Colonna</title>

   <indexterm>
    <primary>tipo di dato della colonna</primary>
    <secondary>cambiare</secondary>
   </indexterm>

   <para>
        Per convertire una colonna a un diverso tipo di dato, usa un comando come:
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
        Questo andrà a buon fine solo se ogni valore esistente nella colonna può essere
        convertito al nuovo tipo da un cast implicito. Se è necessaria una 
        conversione più complessa, puoi aggiungere una clausola <literal>USING</literal> che
        specifica come calcolare il nuovo valore dal vecchio.
   </para>

   <para>
        <productname>PostgreSQL</productname> tenterà di convertire il valore di default della colonna
        (se esistente) al nuovo tipo, così come qualsiasi vincolo
        che coinvolge la colonna. Ma queste conversioni potrebbero fallire, o potrebbero
        produrre risultati sorprendenti. Spesso è meglio eliminare qualsiasi vincolo
        sulla colonna prima di modificarne il tipo, e poi rimettere dopo vincoli corretti.
   </para>
  </sect2>

  <sect2>
   <title>Rinominare una Colonna</title>

   <indexterm>
    <primary>colonna</primary>
    <secondary>rinominare</secondary>
   </indexterm>

   <para>
    Per rinominare una colonna:
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Rinominare una Tabella</title>

   <indexterm>
    <primary>tabella</primary>
    <secondary>rinominare</secondary>
   </indexterm>

   <para>
    Per rinominare una tabella:
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
  <title>Privilegi</title>

  <indexterm zone="ddl-priv">
   <primary>privilegio</primary>
  </indexterm>

  <indexterm>
   <primary>permesso</primary>
   <see>privilegio</see>
  </indexterm>

  <para>
    Quando crei un oggetto di database, ne divieni il suo possessore. Di
    default, solo il possessore diun oggetto può fare qualcosa su di lui.
    Per permettere agli altri utenti di usarlo,
    devono essere garantiti <firstterm>privilegi</firstterm>. (Comunque, 
    gli utenti che sono superuser possono sempre 
    accedere a qualsiasi oggeto.)
  </para>

  <para>
    Ci sono diversi privilegi differenti: <literal>SELECT</literal>,
    <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
    <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
    <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
    <literal>EXECUTE</literal> e <literal>USAGE</literal>.
    I privilegi applicabili ad un particolare
    oggetto variano a seconda del tipo di oggetto (tabella, funzione, etc.)
    Per maggiori informazioni sui diversi tipi di privilegi 
    supportati da <productname>PostgreSQL</productname>, consulta la pagina di riferimento a 
    <xref linkend="sql-grant"/> .
    Anche le sezioni e i capitoli seguenti ti mostreranno come sono usati questi privilegi.
  </para>

  <para>
    Il diritto a modificare o distruggere un oggetto è sempre un privilegio del possessore.
  </para>

  <note>
   <para>
        Per cambiare il possessore di una tabella, indice, sequenza, o vista, usa il comando
        <xref linkend="sql-altertable"/>
        Ci sono corrispondenti comandi <literal>ALTER</literal> per gli altri tipi di oggetti.
   </para>
  </note>

  <para>
    Per assegnare privilegi, si usa il comando <command>GRANT</command>.
    Per esempio, se <literal>joe</literal> è un utente esistente, e 
    <literal>accounts</literal> è una tabella esistente, il privilegio di 
    aggiornare la tabella è concesso con:
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
    Scrivere <literal>ALL</literal> al posto di un privilegio specifico concede tutti
    i privilegi che sono rilevanti per il tipo di oggetto.
  </para>

  <para>
    Il nome <quote>utente</quote> speciale <literal>PUBLIC</literal> può
    essere usato per concedere privilegi ad ogni utente del sistema. Inoltre,
    i role <quote>group</quote> possono essere impostati per aiutarti a gestire i privilegi quando
    ci sono molti utenti per un database &mdash; per dettagli guarda
    <xref linkend="user-manag"/>.
  </para>

  <para>
    Per revocare un privilegio, usa il comando chiamato appropriamente
    <command>REVOKE</command>:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
    I privilegi speciali del possessore dell'oggetto (es., il diritto ai comandi
    <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, ecc.)
    sono sempre impliciti dell'essere il possessore,
    e non possono essere concessi o revocati. Ma il possessore dell'oggetto può scegliere
    di revocare i suoi privilegi, per esempio, per rendere una tabella
    a sola lettura per sè oltre che per gli altri.
  </para>

  <para>
    Solitamente, solo il possessore dell'oggetto (o un superuser) puà concedere o
    revocare privilegi su un oggetto. Comunque, è possibile concedere un
    privilegio <quote>con l'opzione grant</quote> che dà al beneficiario il 
    diritto di concederlo a turno agli altri. Se l'opzione grant successivamente è
    revocata, allora tutti quelli che hanno ricevuto il privilegio da quel beneficiario
    (direttamente o attraverso una catena di grant) perderanno il
    privilegio. Per dettagli vedi le pagine di referenza <xref linkend="sql-grant"/> e
    <xref linkend="sql-revoke"/>. 
  </para>
 </sect1>

 <sect1 id="ddl-schemas">
  <title>Schemi</title>

  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>

  <para>
    Un cluster di database <productname>PostgreSQL</productname>
    contiene uno o più database. Utenti e gruppi di utenti sono
    condivisi attraverso l'intero cluster, ma nessun altro dato è condiviso tra i 
    database. Ogni connessione da un client al server può accedere
    solo ai dati in un singolo database, quello specificato nella richiesta di connessione.
  </para>

  <note>
   <para>
        Gli utenti di un cluster non hanno necessariamente il privilegio di aver accesso ad ogni 
        database nel cluster. La condivisione degli username significa che non ci possono essere
        differenti utenti chiamati, per esempio, <literal>joe</literal> in due database
        dello stesso cluster; ma il sistema può essere configurato per permettere 
        a <literal>joe</literal> l'accesso solamente ad alcuni dei database.
   </para>
  </note>

  <para>
    Un database contiene uno o più <firstterm>schemi</firstterm>, che
    contengono tabelle. Gli schemi contengono anche altri tipi di oggetti con nome,
    incluso tipi di dato, funzioni, e operatori. Lo stesso 
    nome di oggetto può essere usato in differenti schemi senza conflitti; Per 
    esempio, sia <literal>schema1</literal> che <literal>myschema</literal> possono
    contenere tabelle chiamate <literal>mytable</literal>. A differenza dei database,
    gli schemi non sono separati rigidamente: un utente può avere accesso a qualsiasi 
    degli schemi nel database a cui è connesso, se ha i 
    privilegi per farlo.
  </para>

  <para>
    Ci sono diverse ragioni per cui potresti voler usare gli schemi:

   <itemizedlist>
    <listitem>
     <para>
        Permettere a molti utenti di usare un database senza interferire 
        tra di loro.
     </para>
    </listitem>

    <listitem>
     <para>
        Organizzare gli oggetti di database in gruppi logici per renderli
        più gestibili.
     </para>
    </listitem>

    <listitem>
     <para>
        Applicazioni di terze parti posso essere messe in schemi separati così
        cge non conflittino con i nome degli altri oggetti.
     </para>
    </listitem>
   </itemizedlist>

    Gli schemi sono analoghi alle directory a livello di sistema operativo,
    ad eccezione che gli schemi non possono essere annidate.
  </para>

  <sect2 id="ddl-schemas-create">
   <title>Creare uno Schema</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creazione</secondary>
   </indexterm>

   <para>
        Per creare uno schema, usa il comando <xref linkend="sql-createschema"/>
        Dai allo schema un nome a piacere.
        Per esempio:
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>

   <indexterm>
    <primary>nome qualificato</primary>
   </indexterm>

   <indexterm>
    <primary>nome</primary>
    <secondary>qualificato</secondary>
   </indexterm>

   <para>
        Per creare o accedere ad oggetti in uno schema, scrivi un 
        <firstterm>nome qualificante</firstterm> composto dal nome dello schema e dal nome della tabella
        separati da un punto:
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
        Questo funziona ovunque sia accettato il nome di una tabella, inclusi i comandi 
        di modifica della tabella e i comandi di accesso ai dati discussi nei seguenti
        capitoli.
        (Per brevità parleremo solo di tabelle, ma la stessa idea si applica
        agli altri tipi di oggetti, come tipi e funzioni.)
   </para>

   <para>
        In realtà, anche la sintassi più generale 
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
        può essere usata, ma al momento questa è solo per essere <foreignphrase>pro
        forma</foreignphrase> con lo standard SQL. Se scrivi il nome di un database, 
        deve essere lo stesso del database a cui sei connesso.
   </para>

   <para>
    So to create a table in the new schema, use:
        Così, per creare una tabella nel nuovo schema, usa:
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>

   <indexterm>
    <primary>schema</primary>
    <secondary>rimuovere</secondary>
   </indexterm>

   <para>
        Per eliminare uno schema se è vuoto (tutti gli oggetti all'interno della schema sono stati eliminati),
        usa:
<programlisting>
DROP SCHEMA myschema;
</programlisting>
        Per eliminare uno schema includendo tutti gli oggetti contenuti, usa:
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
        Vedi <xref linkend="ddl-depend"/> per una descrizione del comportamento generale che sta sotto.
   </para>

   <para>
        Spesso vorrai create uno schema posseduto da qualcun altro
        (dato che questo è un modo di restringere le attività dei tuoi utenti 
        in namespace ben definiti). La sintassi per farlo è:
<programlisting>
CREATE SCHEMA <replaceable>schemaname</replaceable> AUTHORIZATION <replaceable>username</replaceable>;
</programlisting>
        Puoi comunque omettere il nome dello schema, nel qual caso il nome dello schema 
        sarà lo stesso dell'username. Vedi <xref
        linkend="ddl-schemas-patterns"/> per sapere come questo può essere utile.
   </para>

   <para>
        I nomi degli schemi che iniziano con <literal>pg_</literal> sono riservati per 
        scopi di sistema e non possono essere creati dagli utenti.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Lo Schema Public</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
        Nelle sezioni precedenti abbiamo creato tabelle senza specificare alcuno
        schema. Di default quelle tabelle (e gli altri oggetti) sono 
        automaticamente inseriti in uno schema chiamato <quote>public</quote>. Ogni nuovo
        database contiene quello schema. Così, i seguenti comandi sono equivalenti:
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    and:
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Il Percorso di Ricerca dello Schema</title>

   <indexterm>
    <primary>percorso di ricerca</primary>
   </indexterm>

   <indexterm>
    <primary>nome non qualificato</primary>
   </indexterm>

   <indexterm>
    <primary>nome</primary>
    <secondary>non qualificato</secondary>
   </indexterm>

   <para>
        I nomi qualificati sono noiosi da scrivere, e comunque spesso è meglio non
        legare uno schema particolare all'applicazione. Perciò
        spesso ci si riferisce alle tabelle con <firstterm>nomi non qualificati</firstterm>, 
        che consistono solo del nome della tabella. Il sistema determina a quale tabella
        ci stiamo riferendo seguendo un <firstterm>percorso di ricerca</firstterm>, che è un elenco
        di schemi in cui cercare. La prima tabella corrispondente trovata nel percorso di ricerca
        è considerata quella voluta. Se non ci sono risultati nel percorso di ricerca, 
        viene riportato un errore, anche se il nome di tabella cercato esiste 
        in altri schemi del database.
   </para>

   <indexterm>
    <primary>schema</primary>
    <secondary>corrente</secondary>
   </indexterm>

   <para>
        Il primo schema persente nel percorso di ricerca è chiamato lo schema corrente.
        Oltre ad essere il primo schema cercato, è anche lo schema in 
        cui le nuove tabelle saranno create se il comando  <command>CREATE TABLE</command>
        non specifica il nome di uno schema.
   </para>

   <indexterm>
    <primary>search_path</primary>
   </indexterm>

   <para>
        Per vedere il percorso di ricerca corrente, usa il seguente comando:
<programlisting>
SHOW search_path;
</programlisting>
        Nell'installazione di default questo ritorna:
<screen>
 search_path
--------------
 "$user",public
</screen>
        Il primo elemento specifica che uno schema con lo stesso nome dell'utente 
        corrente viene cercato. Se tale schema non esiste, 
        la voce viene ignorata. Il secondo elemento allo schema public 
        che abbiamo già visto.
   </para>

   <para>
        Il primo schema nel percorso di ricerca che esiste è la posizione di default 
        per la creazione di nuovi oggetti. È la ragione per cui gli oggetti 
        sono creati di default nello schema public. Quando gli oggetti sono richiamati
        in ogni altro contesto senza qualificare uno schema
        (modifica di tabelle, modifica di dati o query) il 
        percorso di ricerca viene attraversato finchè non viene trovato un oggetto corrispondente.
        Perciò, in una configurazione standard, ogni accesso non qualificato  
        può riferirsi solo allo schema public.
   </para>

   <para>
    To put our new schema in the path, we use:
        Per inserire il nostro schema nel percorso, usiamo:
<programlisting>
SET search_path TO myschema,public;
</programlisting>
        (Omettiamo l'<literal>$user</literal> qui perchè non ne abbiamo immediato bisogno.) 
        E quindi possiamo accedere alla tabella senza
        qualificare lo schema:
<programlisting>
DROP TABLE mytable;
</programlisting>
        Inoltre, dato che <literal>myschema</literal> è il primo elemento nel 
        percorso, i nuovi oggetti saranno per default creati in esso.
   </para>

   <para>
        Potevamo anche scrivere:
<programlisting>
SET search_path TO myschema;
</programlisting>
        Così non avremo più accesso allo schema public senza
        esplicita qualificazione. Non c'è niente di speciale nello schema public
        tranne che esiste di default. Può essere anche cancellato.
   </para>

   <para>
        Vedi anche <xref linkend="functions-info"/> per altri modi di manipolare 
        il percorso di ricerca degli schemi.
   </para>

   <para>
        Il percorso di ricerca lavora nello stesso modo dei nomi dei tipi di dato, nomi di funzioni
        e nomi di operatori e nomi di tabelle. I tipi di dato e i nomi delle funzioni  
        possono essere qualificati nello stesso identico modo dei nomi delle tabelle. Se devi
        scrivere un nome di operatore qualificato in una espressione, c'è una
        condizione speciale: devi scrivere
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
        Questo è necessario per evitare ambiguità sintattiche. Un esempio è:
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
        In pratica puoi contare sul percorso di ricerca per gli operatori,
        così non dovrai scrivere di così orribile.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Schemi e Privilegi</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>privilegio</primary>
    <secondary sortas="schemas">per schemai</secondary>
   </indexterm>

   <para>
        Per default, gli utenti non possono accedere ad alcun oggetto in schemi che non possiedano.
        Per permettere questo, il possessore dello schema deve concedere il privilegio
        <literal>USAGE</literal> allo schema. Per permettere agli utenti di
        fare uso degli oggetti nello schema, potresti avere bisogno di concedere privilegi addizionali, 
        appropriati per l'oggetto.
   </para>

   <para>
        Un utente può anche essere abilitato a creare oggetti in uno schema di un altro.
        Per permettere ciò, devi concedere  il privilegio <literal>CREATE</literal>
        sullo schema. Notare che di default, chiunque
        ha i privilegi <literal>CREATE</literal> e <literal>USAGE</literal> sullo
        schema 
        <literal>public</literal>. Questo permette a tutti gli utenti che possono
        collegarsi a un dato database, di creare oggetti nel proprio
        schema <literal>public</literal>. Se non vuoi  
        permettere ciò, puoi revocare quel privilegio:
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
        (Il primo <quote>public</quote> è lo schema, il secondo 
         <quote>public</quote> significa <quote>ogni utente</quote>. 
        Il primo è un identificatore, il secondo una parola chiave, da cui
        il differente uso delle maiuscole; ricontrolla le linee guida 
        <xref linkend="sql-syntax-identifiers"/>.)
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Lo Schema Catagolo di Sistema</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>catalogo di sistema</primary>
    <secondary>schema</secondary>
   </indexterm>

   <para>
        In aggiunta agli schemi <literal>public</literal> e a quelli creati dall'utente, ogni
        database ha uno schema <literal>pg_catalog</literal>, che contiene
        le tabelle di sistema e tutti i tipi di dato, funzioni, e operatori incorporati.
        <literal>pg_catalog</literal> è sempre una parte effettiva del 
        percorso di ricerca. È cercato implicitamente <emphasis>prima</emphasis> degli altri schemi.
        Questo assicura che i nomi incorporati saranno sempre raggiungibili-
        Ad ogni modo, puoi esplicitamente posizionare 
        <literal>pg_catalog</literal> alla fine del percorso di ricerca se preferisci
        avere nomi definiti dall'utente che sovrascrivano nomi incorporati.
   </para>

   <para>
        Nelle versioni <productname>PostgreSQL</productname> precedenti la 7.3,
        i nomi delle tabelle che cominciavano con  <literal>pg_</literal> erano riservati. Questo
        non è più vero: quei nomi si possono usare, in ogni schema
        non di sistema. Comunque, è meglio continuare a evitare
        tali nomi, per essere sicuri di non avere conflitti se qualche versione futura
        definirà una tabella di sistema chiamata allo stesso modo della tua.
        (Con il percorso di ricerca di default, un riferimento non qualificato alla
        tua tabella sarebbe invece risolto come riferimento alla tabella di sistema.)
        Le tabelle di sistema continueranno a seguire la convenzione di avere 
        nomi che cominciano con <literal>pg_</literal>, così che non andranno in conflitto 
        con nomi di tabelle-utente non qualificati finche l'utente eviterà
        il prefisso <literal>pg_</literal> 
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Usage Patterns</title>

   <para>
        Gli schemi possono essere usati per organizzare i dati in molte maniere. Ci sono
        alcuni modi d'uso raccomandati e supportati facilmente dalla
        configurazione di default:
    <itemizedlist>
     <listitem>
      <para>
        Se non si crea nessun schema allora tutti gli utenti hanno accesso allo
        schema public implicitamente. Questo simula la situazione in
        chi gli schemi non sono disponibili per niente. Questa configurazione è
        raccomandata principalmente quando c'è un solo utente o pochi utenti cooperanti
        in un database. Questa situazione permette anche una transizione fluida 
        da una che non abbia schemi.
      </para>
     </listitem>

     <listitem>
      <para>
        Si può creare uno schema per ogni utente con lo stesso nome dell'utente.
        Ricordare che il percorso di ricerca di default comincia con
        <literal>$user</literal>, che diventa il nome dell'utente.
        Per questo, se ogni utente ha uno schema separato, accederà
        il proprio schema di default.
      </para>

      <para>
        Usando questa configurazione allora si potrebbe voler anche revocare l'accesso 
        allo schema public (o eliminarlo del tutto), così gli utenti saranno
        realmente vincolati all'uso dei propri schemi.
      </para>
     </listitem>

     <listitem>
      <para>
        Per installare applicazioni condivise (tabelle che tutti possano usare,
        funzioni addizionali messe a disposizione da terzi, ecc.), metterle
        in schemi separati. Si ricordi di concedere privilegi
        appropriati per permettere agli altri utenti di averne accesso. Gli utenti possono
        allora riferirsi a questi oggetti addizionali qualificandone i nomi 
        con il nome dello schema, o possono mettere gli schemi addizionali nel loro
        percorso di ricerca, è una loro scelta.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>Portabilità</title>

   <para>
        Nell'SQL standard, il concetto di oggetti nello stesso schema
        posseduti da utenti diversi non esiste. In più, alcune
        implementazioni non permettono la creazione di schemi che hanno un nome
        diverso dal loro possessore. Infatti, i concetti di schema
        e utente sono quasi equivalenti in un sistema di database che 
        implementa solo un supporto base agli schemi.
        Perciò, molti utenti considerano nomi qualificati composti, in realtà, da
        <literal><replaceable>username</replaceable>.<replaceable>tablename</replaceable></literal>.
        Così è come  <productname>PostgreSQL</productname> si comporterà effettivamente
        se viene creato uno schema per ogni utente.
   </para>

   <para>
        Inoltre, non c'è il concetto di schema <literal>public</literal> nel SQL standard.
        Per seguire al massimo lo standard, non dovresti usare 
        (forse addirittura rimuovere) lo schema  <literal>public</literal>.
   </para>

   <para>
        Certamente, alcuni sistemi di database SQL potrebbero non implementare gli schemi 
        per niente, o fornire il supporto ai namespace permettendo un accesso attraverso al databse (probabilmente limitato).
        Se devi lavorare con questi 
        sistemi, allora la massima portabilità si raggiunge non usansdo per niente gli schemi.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>Ereditarietà</title>

  <indexterm>
   <primary>ereditarietà</primary>
  </indexterm>

  <indexterm>
   <primary>tabella</primary>
   <secondary>ereditarietà</secondary>
  </indexterm>

  <para>
    <productname>PostgreSQL</productname> implementa l'ereditarietà delle tabelle,
    che può essere uno strumento utile per progettare un databse. (SQL:1999 e successivi
    definiscono l'ereditarietà dei tipi, che è molto diversa
    dalle caratteristiche descritte qui.)
  </para>

  <para>
    Partiamo con un esempio: si supponga di provare a costruire un modello di dati per 
    le città. Ogni stato ha molte città, ma solo una
    capitale. Vogliamo essere capaci di ricavare velocemente la città capitale
    di un particolare stato. Questo può essere fatto creando due tabelle,
    una per le capitali statali e una per le città che non sono 
    capitali. Comunque, cosa succede quando si vogliono informazioni su una città,
    senza badare se sia una capitale o meno? L'ereditarietà
    può aiutare a ricolvere questo problema. Definire la tabella
    <structname>capitals</structname> di modo che erediti da 
    <structname>cities</structname>:

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

    In questo caso, la tabella <structname>capitals</structname>  <firstterm>eredità</firstterm>
    tutte le colonne della sua tabella genitore, <structname>cities</structname>. Le
    capitali statali hanno una colonna in più, <structfield>state</structfield>, che mostra il loro Stato.
  </para>

  <para>
    In <productname>PostgreSQL</productname>, una tabella può ereditare da 
    zero o più tabelle, e una query può riferirsi sia a tutte le righe di una tabella
    che a tutte le righe di una tabella più tutte quelle di una tabella discendente.
    Quest'ultimo casi è il default.
    Per esempio, la query seguente trova i nomi di tutte le città,
    include le capitali statali, che sono collocate ad un'altitudine 
    maggiore di 500 piedi:

<programlisting>
SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;
</programlisting>

    Prendendo i dai di esempio dal tutorial di  <productname>PostgreSQL</productname>
    (see <xref linkend="tutorial-sql-intro"/>), la query restituisce:

<programlisting>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

  <para>
    Invece, la query seguente trova tutte le città che
    non sono capitali statali e sono situate ad un'altezza maggiore di 500 piedi:

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>

  <para>
    Qui la parola chiave  <literal>ONLY</literal> indica che la query
    deve essere applicata solo sulla tabella <structname>cities</structname>, e non sulle tabelle
    sotto <structname>cities</structname> nella gerarchia di ereditarietà. Molti
    dei comandi che abbiamo già discusso &mdash; 
    <command>SELECT</command>, <command>UPDATE</command> e
    <command>DELETE</command> &mdash; supportano la parola chiave
    <literal>ONLY</literal>.
  </para>

  <para>
    In alcuni casi si potrebbe voler sapere da quale tabella è stata generata una 
    particolare riga. In ogni tabella c'è una colonna di sistema chiamata
    <structfield>tableoid</structfield> che può dire
    la tabella originatrice:

<programlisting>
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>

   che restituisce:

<programlisting>
 tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

    (Se provi a riprodurre questo esempio, probabilmente otterrai 
    differenti OID.) Eseguendo una join con
    <structname>pg_class</structname> si possono avere i nomi delle tabelle:

<programlisting>
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   che restituisce:

<programlisting>
 relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845
</programlisting>
  </para>

  <para>
    L'ereditarietà non propaga automaticamente i dati dai comandi 
    <command>INSERT</command> o <command>COPY</command> alle altre tabelle
    nella gerarchia di ereditarietà. Nel nostro esempio, il
    comando  <command>INSERT</command> seguente fallirà:
<programlisting>
INSERT INTO cities (name, population, altitude, state)
VALUES ('New York', NULL, NULL, 'NY');
</programlisting>
    Si potrebbe sperare che i dati fossero in qualche modo mandati alla
    tabella <structname>capitals</structname>, am questo non succede:
    l'<command>INSERT</command> inserisce sempre esattamente nella tabella
    specificata. In alcuni casi è possibile redirigere l'inserimento 
    usando una regola  (see <xref linkend="rules"/>). Comunque questo non
    aiuta nel caso sopra, perchè la tabella <structname>cities</structname> 
    non contiene la colonna <structfield>state</structfield>, e quindi
    il comando sarebbe respinto prima che la regola possa essere applicata.
  </para>

  <para>
    Tutti i vincoli check e not-null su una tabella genitore sono 
    automaticamente ereditati da i suoi figli. Altri tipi di vincoli 
    (unique, chiave primaria e chiave esterna) non sono ereditati.
  </para>

  <para>
    Una tabella può ereditare da più di una tabella genitore, nel qual caso avrà
    l'unione delle colonne definite dalle tabelle genitrici. Le colonne
    dichiarate nella definizione della tabella figlia sono aggiunte a quelle. Se lo
    stesso nome di colonna appare in più tabelle genitrici, o sia in una tabella genitore 
    che in una figlia,  allora queste colonne sono <quote>fuse</quote>
    così che ci sia una sola di queste colonne nella tabella figlia. Per essere fuse,
    le colonne devono avere lo stesso tipi di dato, altrimenti viene generato un errore. La
    colonna fusa avrà copie di tutti i vincoli check provenienti da qualsiasi
    definizione di colonna originaria, e sarà segnata come not-null
    se lo è qualsiasi colonna originiaria.
  </para>

  <para>
    L'ereditarietà delle tabelle è tipicamente stabilita quando la tabella figlia viene
    creata, usando la clausola <literal>INHERITS</literal> del comando 
    <xref linkend="sql-createtable"/>
    Alternativamente, ad una tabella che è già definita in modo compatibile, 
    è possibile aggiungere una genitore, usando la variante <literal>INHERIT</literal>
    di <xref linkend="sql-altertable"/>.
    Per fare questo la nuova tabella figlia deve già includere colonne con lo 
    stesso nome e tipo delle colonne del genitore. Deve anche includere
    vincoli check con gli stessi nomi e espressioni check del genitore.
    Similarmente, un collegamento di ereditarietò può essere rimosso da un figlio usando la
    variante <literal>NO INHERIT</literal> di  <command>ALTER TABLE</command>.
    Aggiungere e rimuovere dinamicamente collegamenti di ereditarietà in questo modo può essere utile
    quando la relazione di ereditarietà viene usata per il partizionameno
    (vedere <xref linkend="ddl-partitioning"/>).
  </para>

  <para>
    Un modo comodo per creare una tabella compatibile che successivamente diventerà
    una nuova figlia è di usare la clausola <literal>LIKE</literal> nel <command>CREATE
    TABLE</command>. Questo crea una nuova tabella con le stesse colonne della
    tabella sorgente. Se ci sono alcuni vincoli <literal>CHECK</literal>
    definiti sulla tabella sorgente, l'opzione <literal>INCLUDING
    CONSTRAINTS</literal> della <literal>LIKE</literal> dovrebbe essere specificata,
    dato che la nuova figlia deve avere vincoli corrispondenti alla genitrice
    per essere considerata compatibile.
  </para>

  <para>
    Una tabella genitore non può essere eliminata finchè una delle sue figlie esiste. Nemmeno
    le colonne o i vincoli check delle tabelle figlie possono essere eliminate o modificate 
    se sono ereditate 
    da tabelle genitrici. Se si desidera rimuovere una tabella e tutte le sue discendenti,
    un modo semplice è eliminare la tabella genitrice con l'opzione
    <literal>CASCADE</literal>.
  </para>

  <para>
    <xref linkend="sql-altertable"/> propagherà
    i cambiamenti nelle definizioni dei dati di colonna e nei vincoli check
    lungo tutta la gerarchia di ereditarietà. Di nuovo, la cancellazione delle
    colonne che dipendono da altre è possibile solo usando l'opzione 
    <literal>CASCADE</literal>. <command>ALTER
    TABLE</command> segue le stesse regole per la fusione di colonne duplicate
    e per il rifuto applicate nella  <command>CREATE TABLE</command>.
  </para>

  <para>
    Notare come sono gestiti i permessi di accesso alla tabella. Eseguire una query su una
    tabella genitrice può automaticamente permettere l'accesso ai dati in tabelle figlie senza ulteriori
    controlli sui privilegi di accesso. 
    Questo comportamento mantiene l'apparenza che i dati siano (anche) nella tabella genitrice.
    Comunque, accedere alle tabelle figlie direttamente non è permesso   
    automaticamente e richiederebbe 
    la concessione di ulteriori privilegi .
  </para>

 <sect2 id="ddl-inherit-caveats">
  <title>Avvertimenti</title>

  <para>
    Notare che non tutti i comandi SQL riescono a lavorare con 
    le gerarchie di ereditarietà. I comandi usati per le query,
    la modifica dei dati, o la modifica degli schemi 
    (ad es., <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
    molte varianti di <literal>ALTER TABLE</literal>, ma non
    <literal>INSERT</literal> e <literal>ALTER TABLE ...
    RENAME</literal>) tipicamente di default includono le tabelle figlie e supportano la notazione
    <literal>ONLY</literal> per escluderle.
    I comandi per fare la manutenzione del database e la messa a punto
    (ad es., <literal>REINDEX</literal>, <literal>VACUUM</literal>)
    tipicamente funzionano solo su tabelle fisiche e individuali e non supportano
    la recursione attraverso gerarchie di eredità. Il rispettivo
    comportamento di ogni singolo comando è documentato nel riferimento 
    (<xref linkend="sql-commands"/>).
  </para>

  <para>
    Una seria limitazione dell'ereditarietà è che gli indici (inclusi
    i vincoli unique) e i vincoli chiave esterna si applicano solo su
    singole tabelle, non le loro figlie. Questo è vero sia per il lato
    referente che referenziato, di un vincolo chiave esterna. Così,  
    riprendendo l'esempio sopra:

   <itemizedlist>
    <listitem>
     <para>
        Se <structname>cities</structname>.<structfield>name</structfield> viene dichiarato
        <literal>UNIQUE</literal> o <literal>PRIMARY KEY</literal>, questo non fermerebbe la tabella
        <structname>capitals</structname> dall'avere righe con nomi che duplicano
        le righe nella tabella  <structname>cities</structname>. E queste righe duplicate saranno 
        mostrate di default nelle query riguardanti la tabella <structname>cities</structname>. Infatti,
        di default <structname>capitals</structname> non avrebbe nessun vincolo unique, 
        e così potrebbe contenere diverse righe con lo stesso nome.
        È possibile aggiungere un vincolo unique a <structname>capitals</structname>, ma questo
        non preverrebbe duplicazioni rispetto a <structname>cities</structname>.
     </para>
    </listitem>

    <listitem>
     <para>
        Similarmente, se abbiamo specificato che 
        <structname>cities</structname>.<structfield>name</structfield>  referenzia (<literal>REFERENCES</literal>)
        un altra tabella, questo vincolo non si propagherà automaticamente in
        <structname>capitals</structname>. In questo caso potresti ovviare alla cosa
        aggiungendo manualmente lo stesso vincolo <literal>REFERENCES</literal> 
        a <structname>capitals</structname>.
     </para>
    </listitem>

    <listitem>
     <para>
        Specificare che una colonna <literal>REFERENCES 
        cities(name)</literal> permetterebbe all'altra tabella di contenere nomi di città, ma
        non nomi di capitale. Non ci sono modi di ovviare a questa cosa.
     </para>
    </listitem>
   </itemizedlist>

    Queste carenze saranno probabilmente corrette in versioni future,
    ma nel frattempo è necessaria particolare attenzione nel decidere se
    l'ereditarietà è utile per la propria applicazione.
  </para>

  <note>
   <title>Deprecato</title>
   <para>
        Nelle versioni di  <productname>PostgreSQL</productname> precedenti alla 7.1, il
        comportamento di default non era di includere le tabelle figlie nelle query. Questo
        fu trovato incline ad errori e in violazione dello standard SQL.
        Puoi avere il comportamento delle versioni precedenti la 7.1 agendo sull'opzione di configurazione 
        <xref linkend="guc-sql-inheritance"/>.
   </para>
  </note>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>Partizionamento</title>

   <indexterm>
    <primary>partizionamento</primary>
   </indexterm>

   <indexterm>
    <primary>tabella</primary>
    <secondary>partizionamento</secondary>
   </indexterm>

   <para>
         <productname>PostgreSQL</productname> supporta un partizionamento di base delle tabelle.
        Questa sezione descrive perchè e come implementare 
        il partizionamento come parte del progetto del database.
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>Panoramica</title>

   <para>
        Partizionare si riferisce a dividere quella che è una tabella grande
        in pezzi fisici più piccoli.
        Il partizionamento può portare diversi vantaggi:
   <itemizedlist>
    <listitem>
     <para>
        Le prestazioni delle query possono essere drasticamente migliorate in certe situazioni,
        particolarmente quando la maggior parte delle righe della tabella accesse pesantemente sono 
        in una singola partizione od un piccolo numero di partizioni. 
<!-- /TODO non ho capito -->
        The partitioning
        substitutes for leading columns of indexes, reducing index size and
        making it more likely that the heavily-used parts of the indexes
        fit in memory.
     </para>
    </listitem>

    <listitem>
     <para>
        Quando delle query o degli aggiornamenti accedono ad un'alta percentuale di una 
        singola partizione, le prestazioni possono essere migliorate traendo vantaggio da
        uno scan sequenziale di quella partizione invece di usare 
        un indice e letture acsuali sparse attraverso l'intera tabella.
     </para>
    </listitem>

    <listitem>
     <para>
        Grossi caricamenti ed eliminazioni possono essere svolti aggiungendo o rimuovendo
        partizioni, se questo requisito è stato messo in conto nel progetto di partizionamento.
        <command>ALTER TABLE</command> è molto più veloce di una oprazione massiva.
        Inoltre viene interamente evitato l'overhead del  <command>VACUUM</command>  
        causato da una <command>DELETE</command> massiva.
     </para>
    </listitem>

    <listitem>
     <para>
        I dati usati raramente possono essere migrati verso supporti di immagazzinamento 
        meno costosi e più lenti.
     </para>
    </listitem>
   </itemizedlist>

        I benefici varranno la pena solo quando una tabella
        è molto grande. Il punto esatto in cui una tabella beneficierà
        del partizionamento dipende dall'applicazione, sebbene 
        una regola generale sia che la dimensione della tabella dovrebbe eccedere la memoria
        fisica del database server.
   </para>

   <para>
        Attualmente, <productname>PostgreSQL</productname> supporta il partizionamento
        attraverso l'ereditarietà. Ogni partizione dev'essere creata come tabella 
        figlia di una singola tabella genitrice. La tabella genitrice di per sè normalmente è
        vuota; Esiste solo per rappresentare l'intero insieme di dati. Si dovrebbe avere
        familiarità con l'ereditarietà (vedere <xref linkend="ddl-inherit"/>) prima
        di tentare di mettere su il partizionamento.
   </para>

   <para>
        Le seguenti forme di partizionamento possono essere implementate in
    <productname>PostgreSQL</productname>:

    <variablelist>
     <varlistentry>
      <term>Partizionamento a intervallo (Range Partitioning)</term>

      <listitem>
       <para>
            La tabella è partizionata in <quote>intervalli</quote> definiti 
            da una colonna chiave o insieme di colonne, senza sovrapposizioni tra gli 
            intervalli di valori assegnati alle diverse partizioni. Per
            esempio si potrebbe partizionare per intervalli di date, o per intervalli di 
            identificatori di particolari oggetti.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Partizionamento a elenco (List Partitioning)</term>

      <listitem>
       <para>
            La tabella è partizionata elencando esplicitamente quali valori chiave 
            appaiono in ogni partizione.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-implementation">
     <title>Implementare il Partizionamento</title>

    <para>
        Per impostare una tabella partizionata, fare:
     <orderedlist spacing="compact">
      <listitem>
       <para>
            Creare la tabella <quote>master</quote>, dalla qualle tutte le altre
            erediteranno.
       </para>
       <para>
            Questa tabella non conterrà dati. Non definire nessun
            vincolo check su questa tabella, a meno che non si intenda applicarli 
            equamente a tutte le partizioni. Non c'è neppure alcun motivo
            di definire un indice o vincolo unique. 
       </para>
      </listitem>

      <listitem>
       <para>
            Crea diverse tabelle <quote>figlie</quote> ognuna delle quali eredita
            dalla tabella master. Normalmente, queste tabelle non aggiungeranno colonne 
            all'insieme ereditato dalla master.
       </para>

       <para>
            Ci riferiremo alle tabelle figlie come "partizioni", nonostante siano
            normali tabelle <productname>PostgreSQL</productname>. 
       </para>
      </listitem>

      <listitem>
       <para>
            Aggiungere vincoli di tabella sulle tabelle-partizioni per definire
            i valori chiave permessi in ogni partizione.
       </para>

       <para>
            Tipici esempi potrebbero essere:
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
            Assicurarsi che i vincoli garantiscano che non ci siano sovrapposizioni 
            tra i valori chiave permessi nelle varie partizioni. Un errore comune 
            è impostare vincoli di range tipo:
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
            Questo è sbagliato dato che non è chiaro a quale partizione appartiene il 200.
       </para>

       <para>
            Notare che non c'è differenza nella sintassi tra    
            il partizionamento di intervallo e il partizinamento di elenco; questi termini
            sono solo descrittivi.
       </para>
      </listitem>

      <listitem>
       <para>
            Per ogni partizione, creare un indice su ogni colonna/e, 
            così come ogni altro indice potresti volere. (L'indice chiave non
            è strettamente necessario, ma in molte situazioni è utile.
            Se si vuole che i valori chiave siano unici allora si dovrebbe
            sempre creare un vincolo unique o chiave primaria per ogni 
            partizione.)
       </para>
      </listitem>

      <listitem>
       <para>
            Opzionalmente, definire un trigger o una regola per redirigere i dati inseriti nella
            tabella master alle partizioni appropriate.
       </para>
      </listitem>

      <listitem>
       <para>
            Assicurarsi che il parametro di configurazione  <xref linkend="guc-constraint-exclusion"/>
            non sia disabilitato in <filename>postgresql.conf</filename>.
            Se lo è, le query non saranno ottimizzate come desiderato.
       </para>
      </listitem>

     </orderedlist>
    </para>

    <para>
       Per esempio, supponiamo di realizzare un databse per una grande  
        ditta di gelati. La ditta misura le temperature massime ogni 
        giorno così come le vendite di gelati in ogni regione. Concettualmente, 
        la tabella sarà:

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

        La maggior parte delle query accederanno ai dati dell'ultima settimana, mese o 
        trimestre, dato che l'utilizzo principale di questa tabella sarà di preparare 
        rapporti online per la gestione.
        Per ridurre l'ammontare di vecchi dati che devono essere immagazzinati, 
        vale la pena tenere solo i 3 anni di dati più recenti. All'inizio
        di ogni mese verranno cancellati i dati del mese più vecchio.
    </para>

    <para>
        In questa situazione è possibile usare il partizionamento per far fronte  
        a tutte le esigenze della tabella delle misurazioni.
        Seguendo i passi
        evidenziati sopra, il partizionamento può essere impostato come segue:
    </para>

    <para>
     <orderedlist spacing="compact">
      <listitem>
       <para>
            La tabella master è <structname>measurement</structname>, dichiarata esattamente come sopra.
       </para>
      </listitem>

      <listitem>
       <para>
            Successivamente creare una partizione per ogni mese attivo:

<programlisting>
CREATE TABLE measurement_y2006m02 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 ( ) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 ( ) INHERITS (measurement);
</programlisting>

            Ognuna delle partizioni è una tabella completa,
            ma eredita la sua definizione dalla tabella
            <structname>measurement</structname>.
       </para>

       <para>
            Questo risolve uno dei problemi: la cancellazione dei vecchi dati. Ogni  
            mese, basterà eseguire una <command>DROP
            TABLE</command> sulla tabella figlia più vecchia e creare una nuova tabella
            per i dati del mese nuovo.
       </para>
      </listitem>

      <listitem>
       <para>
            E' necessario fornire vincoli di tabella non sovrapponibili. Piuttosto che
            creare semplicemente le tabelle partizione come sopra, lo script di creazione delle tabelle 
            dovrebbe essere:

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
            Probabilmente ci sarà bisogno di indici sulle colonne chiave:

<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
...
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>

            Per adesso scegliamo di non aggiungere ulteriori indici.
       </para>
      </listitem>

      <listitem>
       <para>
            Vogliamo che l'applicazione sia capace di indirizare nelle tabelle di partizione appropriate    
            i dati inseriti con <literal>INSERT INTO measurement ...</literal>.
            Per realizzare ciò, creare una funzione di trigger adatta e collegarla 
            alla tabella master.
            Se i dati saranno aggiunti solo all'ultima partizione, usare
            una funzione trigger molto semplice:

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEgin
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

            Dopo aver creato la funzione, creare un trigger che
            la chiama:

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();
</programlisting>

            È necessario ridefinire la funzione trigger ogni mese così che punti
            sempre alla partizione corrente. La definizione del trigger, comunque,
            non deve essere aggiornata.
       </para>

       <para>
            Si potrebbe voler inserire i dati e far sì che il server automaticamente 
            localizzi la partizione in cui la riga dovrebbe essere aggiunta. 
            E' possibile farlo con una funzione di trigger più complessa, per esempio:

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEgin
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

            La definizione del trigger sarà la stessa di prima.
            Notare che ogni test <literal>IF</literal> deve esattamente corrispondere
            al vincolo <literal>CHECK</literal> per la sua partizione.
       </para>

       <para>
            Mentre questa funzione è più complessa che quella riguardante il singolo mese,
            non ha bisogno di essere aggiornata così spesso, dato che possono essere aggiunti
            rami in anticipo per ogni bisogno.
       </para>

       <note>
        <para>
            In pratica potrebbe essere meglio controllare la partizione più nuova prima,
            se la maggior parte degli inserimenti vanno in quella partizione. Per simplicità
            si sono mostrati i test del trigger nello stasso ordine che in altre parti
            dell'esempio.
        </para>
       </note>
      </listitem>
     </orderedlist>
    </para>

    <para>
        Come si può notare, uno schema di partizionamento complesso potrebbe richiedere
        una grande quantità di DDL. Nell'esempio sopra di dovrebbe creare
        una nuova partizione ogni mese, così potrebbe esser saggio scrivere uno
        script che generasse il DDL richiesto automaticamente.
    </para>

   </sect2>

   <sect2 id="ddl-partitioning-managing-partitions">
   <title>Gestire le Partizioni</title>

   <para>
        Normalmente l'insieme delle partizioni stabilite quando inizialmente
        si definisce la tabella non rimarrà statico. È comune 
        voler rimuovere vecchie partizioni di dati e periodicamente
        aggiungere nuove partizioni per nuovi dati. Uno dei più importanti
        vantaggi del partizionamento è precisamente che permette che questo
        compito che altrimenti sarebbe penoso, sia eseguito quasi istantaneamente 
        manipolando la struttura della partizione, invece che spostare fisicamente 
        grandi quantità di dati.
   </para>

   <para>
        L'opzione più semplice per rimuovere vecchi dati è semplicemente di eliminare la partizione
        che non è più necessaria:
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
        Questo può cancellare milioni di record velocemente dato che non deve
        cancellare individualmente ogni record.
   </para>

   <para>
        Un'altra opzione che spesso è preferibile è quella di rimuovere la partizione dalla
        tabella partizionata ma conservare l'accesso ad essa come tabella a sè stante:
<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
        Questo permette di svolgere ulteriori operazioni sui dati prima
        di essere eliminati.
        Per esempio, spesso questo è utile per eseguire un backup dei dati
        usando <command>COPY</command>, <application>pg_dump</application>, o 
        strumenti simili.
        Potrebbe anche essere utile per aggregare dati in 
        formati più piccoli, eseguire altre manipolazioni di dati, o fare
        rapporti sui dati.
   </para>

   <para>
        Similarmente, è possibile aggiungere una nuova partizione per trattare nuovi dati. E' possibile creare
        una partizione vuota nella tabella partizionata semplicemente come le partizioni originali
        create sopra:

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

        Come alternativa, a volte è più comodo creare la nuova tabella
        fuori la struttura delle partizioni, e renderla una una partizione vera e propria 
        più tardi. Questo permette ai dati di essere caricati, controllati e 
        trasformari prima di apparire nella tabella partizionata:

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibilmente qualche altro lavoro sulla preparazione dei dati
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
   </sect2>

   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>Partizionamento e Vincolo Exclusion</title>

   <indexterm>
    <primary>vincolo exclusion</primary>
   </indexterm>

   <para>
        Il <firstterm>vincolo exclusion</firstterm> è una tecnica per ottimizzare una query
        che aumenta le prestazioni per le tabelle partizionate definite nel 
        modo descritto sopra. Come esempio:

<programlisting>
SET constraint_exclusion = on;
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

        Senza il vincolo exclusion, la query sopra avrebbe controllato ogni 
        partizione della tabella <structname>measurement</structname>. Con il vincolo
        exclude abilitato, verranno esaminati i vincoli di ogni partizione
        e si tenterà di provare che la partizione non necessita di essere controllata
        perchè non potrebbe contenere alcuna riga che rispetta la clausola <literal>WHERE</literal>.
        Quando si può provare questo, la partizione verrà esclusa dalla query.
   </para>

   <para>
        È possibile usare il comando <command>EXPLAIN</command> per mostrare le differenze
        tra avere  <varname>constraint_exclusion</varname> attiva e disattiva.
        Un esempio di query plan per questo tipo di tabella è:

<programlisting>
SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m02 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m12 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

        Alcune o tutte le partizioni potrebbero usare la scansione degli indici invece
        di una scansione sequenziale di tutta la tabella, ma il punto qui è che non c'è 
        bisogno di scansionare le vecchie partizioni per niente per rispondere a quella query.
        Con il vincolo exclusion abilitato, si ha un query plan significativamente 
        più economico che porterà alla stessa risposta:

<programlisting>
SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>

   <para>
        Notare che il vincolo exclusion è guidato solo dal vincolo <literal>CHECK</literal>,
        non dalla presenza degli indici. Perciò non è necessario 
        definire indici sulle colonne chiave. Se un indice 
        deve essere creato per una data partizione dipende dal fatto che 
        ci si aspetti che le query che scansionano la partizione generalmente scansionino
        una grande parte della partizione o solo una piccola parte. Un indice sarà
        utile nell'ultimo caso ma non nel primo.
   </para>

   <para>
        L'impostazione di default (e raccomandata) di 
        <xref linkend="guc-constraint-exclusion"/> attualmente non è nè
        <literal>on</literal> nè <literal>off</literal>, ma un valore intermedio
        chiamato <literal>partition</literal>, che fa sì che la tecnica sia applicata 
        solo su query che probabilmente lavorano su tabelle partizionate.
        L'impostazione  <literal>on</literal> fa sì che i vincoli <literal>CHECK</literal>
        siano esaminati in tutte le query, anche quelle semplici che
        poco probabilmente ne trarranno beneficio.
   </para>

   </sect2>

   <sect2 id="ddl-partitioning-alternatives">
   <title>Metodi di Partizionamento Alternativi</title>

    <para>
        Un approccio differente per indirizzare gli inserimenti nell'appropriata
        tabella partizione è di impostare regole, invece di trigger, sulla
        tabella master. Per esempio:

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

        Una regola ha un costo significativamente maggiore rispetto a un trigger, ma il costo
        è pagato una volta per query invece di una volta per riga, così questo metodo potrebbe essere
        vantaggioso per inserimenti massivi. In molti casi, comunque,  
        il metodo basato sui trigger offre migliori prestazioni.
    </para>

    <para>
        Tenere presente che <command>COPY</command> ignora le regole. Se si vuole
        usare <command>COPY</command> per inserire dati, si dovranno copiare nella corretta 
        tabella partizione piuttosto che nel master. <command>COPY</command> attiva i 
        trigger, così puoi usarlo normalmente se usi l'approccio con i trigger.
    </para>

    <para>
        Un altro svantaggio  dell'approccio con le regole è che non c'è un modo semplice 
        di forzare un errore se l'insieme di regole non soddisfa i dati da inserire;
        I dati verranno invece inseriti silenziosamente nella tabella master.
    </para>

    <para>
        Il partizionamento può anche essere programmato usando una view  <literal>UNION ALL</literal>,
        invece dell'ereditarietà. Per esempio:

<programlisting>
CREATE VIEW measurement AS
          SELECT * FROM measurement_y2006m02
UNION ALL SELECT * FROM measurement_y2006m03
...
UNION ALL SELECT * FROM measurement_y2007m11
UNION ALL SELECT * FROM measurement_y2007m12
UNION ALL SELECT * FROM measurement_y2008m01;
</programlisting>

        Comunque, la necessità di ricreare la view aggiunge un ulteriore passo all'aggiunta ed
        eliminazione di partizioni singole dell'insieme di dati. In pratica questo metodo
        è poco raccomandabile rispetto all'uso dell'ereditarietà.
    </para>

   </sect2>

   <sect2 id="ddl-partitioning-caveats">
   <title>Avvertimenti</title>

   <para>
        I seguenti avvertimenti si applicano alle tabelle partizionate:
   <itemizedlist>
    <listitem>
     <para>
        Non c'è un modo automatico per verificare che tutti i 
        vincoli <literal>CHECK</literal> sono mutualmente
        esclusivi. È più sicuro creare codice che genera le partizioni
        e creare e/o modificare gli oggetti associati che scriverle
        a mano.
     </para>
    </listitem>

    <listitem>
     <para>
        Gli schemi mostrati qui assumono che la/e colonna/e chiave della partizione
        do una riga non cambia mai, o almeno non cambia abbastanza da richiedere 
        che venga mossa verso un'altra partizione.
        Un  <command>UPDATE</command> che tenta 
        di fare ciò fallirà causa il vincolo <literal>CHECK</literal>.
        Se hai bisogno di far fronte a questi casi, puoi inserire trigger di aggiornamento 
        sulle tabelle partizioni, ma questo renderà la gestione della struttura 
        molto più complicata.
     </para>
    </listitem>

    <listitem>
     <para>
        Quando si usano comandi come il <command>VACUUM</command> manuale o 
        <command>ANALYZE</command>, non dimenticarsi che 
        è necessario eseguirli individualmente sulle partizioni. Un comando tipo:
<programlisting>
ANALYZE measurement;
</programlisting>
        Processerà solo la tabella master.
     </para>
    </listitem>

   </itemizedlist>
   </para>

   <para>
        I seguenti avvertimenti sono validi per il vincolo exclusion:

   <itemizedlist>
    <listitem>
     <para>
        Il vincolo exclusion funziona solo quando la lausola <literal>WHERE</literal>
        della query contiene costanti. Una query parametrizzata non sarà
        ottimizzata, fino a che non sia possibile stabilire il valore 
        che quel parametro potrebbe avere. Per la stessa ragione,
        funzioni <quote>stabili</quote> tipo <function>CURRENT_DATE</function>
        dovrebbero essere evitate.
     </para>
    </listitem>

    <listitem>
     <para>
        È consigliabile mantenere i vincoli di partizionamento semplici, altrimenti il planner potrebbe non
        essere capace di provare che le partizioni non hanno bisogno di essere visitate. Usare condizioni di uguaglianza
        semplici per partizionamenti a elenco, o semplici
        test di intervallo per partizionamenti di intervallo, come illustrato nei precedenti 
        esempi. Una buona regola generale è che i vincoli di partizionamento dovrebbero
        contenere solo comparazioni tra colonna/e di partizionamento e costanti
        usando operatori indicizzabili B-tree.
     </para>
    </listitem>

    <listitem>
     <para>
        Tutti i vincoli su tutte le partizioni della tabella master sono esaminati
        durante il vincolo exclusion, così grandi quantità di partizioni probabilmente
        aumenteranno considerevolmente il tempo di query planning. Pertizionare usando
        queste tecniche funzionerà bene con circa cento partizioni;
        Non tentare di usare molte migliaia di partizioni.
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-others">
  <title>Altri Oggetti di Database</title>

  <para>
        Le tabelle sono gli oggetti centrali in una struttura di database relazionali,
        perchè conservano i dati. Ma non sono gli unici oggetti
        che esistono in un database. Molti altri tipi di oggetti possono
        essere creati per rendere l'uso e la gestione dei dati più efficiente
        o comodo. Non sono discussi in questo capitolo, ma ecco un elenco
        così per conoscere cosa sia possibile avere:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Viste
    </para>
   </listitem>

   <listitem>
    <para>
     Funzioni e operatori
    </para>
   </listitem>

   <listitem>
    <para>
     Tipi di dato e domini
    </para>
   </listitem>

   <listitem>
    <para>
     Trigger e regole rewrite
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Informazioni dettagliate su 
    questi argomenti appaiono in <xref linkend="server-programming"/>.
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>Dipendenze</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">con DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">con DROP</secondary>
  </indexterm>

  <para>
    Quando si crea una struttura di database complessa che contiene molte tabelle
    con vincoli hiave esterna, viste, trigger, funzioni, ecc. si        
    crea implicitamente una rete di dipendenze tra gli oggetti.
    Per esempio, una tabella con un vincolo chiave esterna dipende dalla
    tabella che referenzia.
  </para>

  <para>
    Per assicurare l'integrità dell'intera struttura del database,
    <productname>PostgreSQL</productname> fa sì che non sia possibile
    eliminare oggetti dai quali ne dipendono altri. Per esempio,
    tentare di rimuovere la tabella dei prodotti considerata in <xref
    linkend="ddl-constraints-fk"/>, con la tabella ordini che dipende da essa,
    restituirà un messaggio di errore simile a questo:
<screen>
DROP TABLE products;

NOTICE:  constraint orders_product_no_fkey on table orders depends on table products
ERROR:  cannot drop table products because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
    Il messaggio di errore contiene un suggerimento utile: se non ci si vuole 
    preoccupare di cancellare tutti gli oggetti dipendenti individualmente, si può eseguire:
<screen>
DROP TABLE products CASCADE;
</screen>
    e tutti gli oggetti dipendenti saranno rimossi. In questo caso, 
    non viene rimossa la tabella ordini, viene rimosso solo il vincolo 
    chiave esterna. (Se si vuole controllare cosa farà  <command>DROP ... CASCADE</command>, 
    eseguire <command>DROP</command> senza <literal>CASCADE</literal> e leggere i messaggi <literal>NOTICE</literal>.)
  </para>

  <para>
    Tutti i comandi drop in <productname>PostgreSQL</productname> supportano
    la possibilità di specificare <literal>CASCADE</literal>. Certamente, la natura 
    delle possibile dipendenze varia con il tipo di oggetto. È possibile anche 
    scrivere <literal>RESTRICT</literal> invece di 
    <literal>CASCADE</literal> per avere il comportamento di default, che serve
    a prevenire l'eliminazione degli oggetti che dipendono da altri.
  </para>

  <note>
   <para>
        Secondo lo standard SQL, specificare 
        <literal>RESTRICT</literal> o <literal>CASCADE</literal> è
        necessario. Nessun sistema di database attualmente forza questa regola, ma
        che il comportamento di default sia <literal>RESTRICT</literal> o 
        <literal>CASCADE</literal> varia a seconda del sistema.
   </para>
  </note>

  <note>
   <para>
        Le dipendenze dei vincoli chiave esterna e delle colonne serial 
        da versioni di <productname>PostgreSQL</productname> prima della 7.3
        <emphasis>not</emphasis> sono mantenute o create durante 
        un processo di aggiornamento. Tutti gli altri tipi di dipendenza saranno correttamente 
        creati durante un aggiornamento da un database di versione precedente alla 7.3.
   </para>
  </note>
 </sect1>

</chapter>

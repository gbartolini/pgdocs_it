<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

 <chapter id="datatype">
  <title>Tipi di Dato</title>

  <indexterm zone="datatype">
   <primary>tipo di dato</primary>
  </indexterm>

  <indexterm>
   <primary>tipo</primary>
   <see>tipo di dato</see>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> ha un corposo insieme tipi di dato
   nativi disponibili per gli utenti. Gli utenti possono aggiungere nuovi tipi a
   <productname>PostgreSQL</productname> utilizzando il comando <xref
   linkend="sql-createtype" endterm="sql-createtype-title" />.
  </para>

  <para>
   La <xref linkend="datatype-table" /> visualizza tutti i tipi dati di uso generale
   incorporati. La maggior parte dei nomi alternativi elencati nella colonna 
   <quote>Alias</quote> sono i nomi usati internamente da
   <productname>PostgreSQL</productname> per ragioni storiche. In
   aggiunta, sono disponibili altri tipi usati internamente o deprecati,
   ma non sono elencati quì.
   
  </para>

   <table id="datatype-table">
    <title>Tipi di Dato</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nome</entry>
       <entry>Alias</entry>
       <entry>Descrizione</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>intero con segno a 8 byte</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>intero auto incrementale a 8 byte</entry>
      </row>

      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>stringa di bit a lunghezza fissa</entry>
      </row>

      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit</type></entry>
       <entry>stringa di bit a lunghezza variabile</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>valore Booleano (vero/falso)</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>Un rettangolo su un piano</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>dato binario (<quote>array di byte</quote>)</entry>
      </row>

      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>stringa di caratteri a lunghezza variabile</entry>
      </row>

      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>stringa di caratteri a lunghezza fissa</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>indirizzo di rete IPv4 o IPv6</entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>cerchio su un piano</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>data di calendario (anno, mese, giorno)</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>numero a virgola mobile a doppia precisione (8 bytes)</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>indirizzo di host IPv4 or IPv6</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>intero con segno a 4 byte</entry>
      </row>

      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>intervallo di tempo</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>linea infinita su un piano</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>segnmento di linea su un piano</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>indirizzo MAC (Media Access Control)</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>somma di denaro</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>numerico di precisione selezionabile</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>tracciato geometrico su un piano</entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>punto geometrico su un piano</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>tracciato chiuso su un piano</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>numero a virgola mobile a precisione singola (4 byte)</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>intero con segno a 2-byte</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>intero autoincrementale a 4-byte</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>stringa di caratteri a lunghezza variabile</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>orario del giorno (senza fuso orario)</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>orario del giorno, incluso il fuso orario</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>data e orario (senza fuso orario)</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>data e orario, includo il fuso orario</entry>
      </row>

      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <entry>query di ricerca di testo</entry>
      </row>

      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <entry>documento di ricerca testo</entry>
      </row>

      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <entry>istantanea di transaction ID a livello utente</entry>
      </row>

      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <entry>identificatore unico universalmente</entry>
      </row>

      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <entry>dati XML</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <title>Compatibilità</title>
   <para>
<!-- /TODO or spelling thereof ? -->
    I seguenti tipi (or spellings thereof) sono specificati dall'<acronym>SQL</acronym>: 
    <type>bigint</type>, <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (con o senza fuso orario),
    <type>timestamp</type> (con o senza fuso orario),
    <type>xml</type>.
   </para>
  </note>

  <para>
   Ogni tipo dato ha una rappresentazione esterna determinata dalle sue
   funzioni di input e output. Molti dei tipi incorporati hanno
   formati esterni evidenti. Tuttavia, diversi tipi o sono unici a
   <productname>PostgreSQL</productname>, come i percorsi geometrici,
   o hanno molte più possibilità di formattazione, come i tipi data
   e ora.
   Alcune delle funzioni di input e output non sono invertibili. Cioè
   il risultato di una funzione di output potrebbe perdere precisione quando confrontato
   al input originale.

  </para>

  <sect1 id="datatype-numeric">
   <title>Tipi Numerici</title>

   <indexterm zone="datatype-numeric">
    <primary>tipo di dato</primary>
    <secondary>numerico</secondary>
   </indexterm>

   <para>
    I tipi numerici consistono di numeri interi di due, quattro, e otto byte, di
    numeri in virgola mobile di quattro e otto byte, e di numeri decimali con precisione
    selezionabile. La <xref linkend="datatype-numeric-table" /> elenca
    i tipi disponibili.
    
   </para>

    <table id="datatype-numeric-table">
     <title>Tipi Numerici</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Dimensione</entry>
        <entry>Descrizione</entry>
        <entry>Estensione</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</type></entry>
        <entry>2 byte</entry>
        <entry>interi con piccola estensione</entry>
        <entry>-32768 to +32767</entry>
       </row>
       <row>
        <entry><type>integer</type></entry>
        <entry>4 byte</entry>
        <entry>la scelta comune per gli interi</entry>
        <entry>-2147483648 to +2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</type></entry>
        <entry>8 byte</entry>
        <entry>interi ad elevata estensione</entry>
        <entry>-9223372036854775808 to 9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</type></entry>
        <entry>variable</entry>
        <entry>esatta, precisione specificata dall'utente</entry>
        <entry>senza limite</entry>
       </row>
       <row>
        <entry><type>numeric</type></entry>
        <entry>variable</entry>
        <entry>esatta, precisione specificata dall'utente</entry>
        <entry>senza limite</entry>
       </row>

       <row>
        <entry><type>real</type></entry>
        <entry>4 byte</entry>
        <entry>inesatta, precisione variabile</entry>
        <entry>6 cifre decimali di precisione</entry>
       </row>
       <row>
        <entry><type>double precision</type></entry>
        <entry>8 byte</entry>
        <entry>inesatta, precisione variabile</entry>
        <entry>15 cifre decimali di precisione</entry>
       </row>

       <row>
        <entry><type>serial</type></entry>
        <entry>4 byte</entry>
        <entry>intero autoincrementante</entry>
        <entry>da 1 a 2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
        <entry>8 byte</entry>
        <entry>intero autoincrementante grande</entry>
        <entry>da 1 a 9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    La sintassi delle costanti per i tipi numerici è descritta in
    <xref linkend="sql-syntax-constants" />. I tipi numerici hanno un
    insieme completo di corrispondenti operatori aritmetici e
    funzioni. Riferirsi al <xref linkend="functions" /> per ulteriori
    informazioni. La sezione seguente descrive i tipi in dettaglio.
    
   </para>

   <sect2 id="datatype-int">
    <title>Tipi Interi</title>

    <indexterm zone="datatype-int">
     <primary>integer</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>

    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

    <para>
     I tipi <type>smallint</type>, <type>integer</type>, e
     <type>bigint</type> memorizzano numeri interi, che significa, numeri senza
     componente frazionale, di diversa estensione. Tentativi di memorizzare
     valori al di fuori dell'estensione consentita provocheranno un errore.
    </para>

    <para>
     Il tipo <type>integer</type> è quello scelto normalmente, dato che offre
     il migliore bilanciamento tra estensione, dimensione di memorizzazione e prestazione.
     Il tipo <type>smallint</type> è generalmente usato solo se lo spazio nel
     disco è ridotto. Il tipo <type>bigint</type> dovrebbe essere usato solo se
     l'estensione del tipo <type>integer</type> non è sufficiente,
     in quanto quest'ultimo è certamente più veloce.
    </para>

    <para>
     Il tipo <type>bigint</type> può non funzionare correttamente su tutte
     le piattaforme, dato che richiede sul compilatore un supporto per interi a
     otto byte. Su una macchina senza tale supporto, <type>bigint</type>
     si comporta come <type>integer</type> (ma occupa ugualmente otto byte
     di memorizzazione). Tuttavia, non siamo informati di alcuna
     piattaforma sui cui si sia presentato questo caso.
    </para>

    <para>
     <acronym>SQL</acronym> specifica solo i tipi interi
     <type>integer</type> (o <type>int</type>),
     <type>smallint</type>, e <type>bigint</type>. I tipi
     chiamati <type>int2</type>, <type>int4</type>, e
     <type>int8</type> sono estensioni, che sono condivise con diversi
     altri sistemi di database <acronym>SQL</acronym>.
    </para>


   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <title>Numeri a Precisione Arbitraria</title>

    <indexterm>
     <primary>(tipo di dato) numerico</primary>
    </indexterm>

   <indexterm>
    <primary>numeri a precisione arbitraria</primary>
   </indexterm>

    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>

    <para>
     Il tipo <type>numeric</type> può memorizzare numeri di precisione fino a 1000
     cifre ed effettuare i calcoli esattamente. È
     raccomandato specialmente per memorizzare quantità monetarie e altre
     quantità dove viene richiesta precisione. Tuttavia, l'aritmetica su
     valori <type>numeric</type> è molto lenta confrontata con i tipi
     interi, o con i tipi in virgola mobile descritti nella prossima sezione.
    </para>

    <para>
     In ciò che segue vengono utilizzati questi termini: La
     <firstterm>scala</firstterm> di un <type>numeric</type> è il
     conto delle delle cifre decimali nella parte frazionaria, alla destra del
     punto decimale. La <firstterm>precisione</firstterm> di un
     <type>numeric</type> è il conto totale delle cifre significative
     nell'intero numero, cioè, il numero di cifre in ambedue i lati del
     punto decimale. Per cui il numero 23.5141 ha una precisione di 6
     e una scala di 4. Gli interi possono essere considerati come aventi una scala
     zero.
    </para>

    <para>
     In una colonna <type>numeric</type> possono essere
     configurati sia la massima precisione che la massima
     scala. Per dichiarare una colonna di tipo <type>numeric</type> usare
     la sintassi:

<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>

     La precisione deve essere positiva,la scala zero o positiva.
     Alternativamente:

<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>

       seleziona una scala di 0. Specificare: 

<programlisting>
NUMERIC
</programlisting>
     senza nessuna precisione o scala crea una colonna in cui possono
     essere memorizzati valori di qualsiasi precisione e scala, fino al
     limite di implementazione della precisione. Una colonna di questo tipo
     non forzerà i valori in ingresso ad una particolare scala, mentre
     le colonne <type>numeric</type> con una scala dichiarata forzeranno i
     valori in ingresso a quella scala. (Lo standard <acronym>SQL</acronym>
     richiede un valore predefinito di 0 per la scala, cioè forza la
     precisione a intero. Considerare questo un tantino inutile. Se siete
     preoccupati per la portabilità, specificare esplicitamente la
     precisione e la scala).
    </para>
     
    <para>
     Se la scala di un valore da memorizzare è più grande della scala
     dichiarata della colonna, il sistema arrotonderà il valore al numero
     dichiarato di cifre decimali. Se invece il numero di cifre alla sinistra
     del punto decimale supera la precisione dichiarata meno la scala dichiarata,
     viene generato un errore.
    </para>

    <para>
     I valori numerici vengono fisicamente memorizzati senza zeri non significativi
     e senza zeri finali. Quindi, la precisione e la scala dichiarate per una colonna
     sono massime, non allocazioni fisse.  (In questo senso il tipo <type>numeric</type>
     è più simile al <type>varchar(<replaceable>n</replaceable>)</type>
     che al <type>char(<replaceable>n</replaceable>)</type>). La richiesta reale di memoria
     è di due byte per ogni gruppo di quattro cifre decimali,
     più da cinque a otto byte in testa.
    </para>


    <indexterm>
     <primary>NaN</primary>
     <see>not a number</see>
   </indexterm>

    <indexterm>
     <primary>not a number</primary>
     <secondary>(tipo di dato) numerico</secondary>
    </indexterm>


    <para>
     In aggiunta ai valori numerici normali, il tipo <type>numeric</type>
     ammette il valore speciale <literal>NaN</literal>, che significa 
     <quote>not-a-number</quote> (non-un-numero). Ogni operazione su <literal>NaN</literal>
     restituisce un altro <literal>NaN</literal>. Quando si scrive questo valore come
     una costante in un comando SQL, bisogna racchiuderlo tra apici, per esempio
     <literal>UPDATE tabella SET x = 'NaN'</literal>. In ingresso, la stringa <literal>NaN</literal>
     viene riconosciuta senza distinzione tra maiuscole e minuscole.
    </para>

    
    <note>
     <para>
      Nella maggior parte delle implementazioni del concetto
      <quote>not-a-number</quote>, <literal>NaN</literal> non è considerato
      uguale a nessun altro valore numerico (<literal>NaN</literal> compreso).
      Per consentire che i valori <type>numeric</type> siano ordinati e
      usati negli indici B-tree, <productname>PostgreSQL</productname> tratta i
      valori <literal>NaN</literal> come uguali, e maggiori di tutti i valori
      non-<literal>NaN</literal>.
     </para>
    </note>


    <para>
     I tipi <type>decimal</type> e <type>numeric</type> sono
     equivalenti. Ambedue fanno parte dello standard
     <acronym>SQL</acronym>.
    </para>
   </sect2>


   <sect2 id="datatype-float">
    <title>Tipi a Virgola Mobile</title>

    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>double precision</primary>
    </indexterm>

    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>virgola mobile</primary>
    </indexterm>

    <para>
     I tipi di dato <type>real</type> e <type>double precision</type>
     sono tipi numerici inesatti, con precisione variabile. In pratica,
     questi tipi sono normalmente implementazioni dello standard
     <acronym>IEEE</acronym> 754 per l'Aritmetica Binaria a Virgola-Mobile
     (rispettivamente a singola e doppia precisione), nella misura in
     cui i sottostanti processore, sistema operativo e compilatore li
     supportano.
    </para>

    <para>
     Inesatto significa che alcuni valori non possono essere convertiti esattamente al
     formato interno e vengono memorizzati con approssimazione, per cui la memorizzazione
     e la stampa tirata fuori potrebbero mostrare lievi discrepanze.
     La gestione di questi errori e della loro propagazione attraverso i calcoli
     è il soggetto di una intera branca della matematica e della scienza del
     computer e non sarà quì ulteriormente discussa, tranne che per i
     seguenti punti:
     <itemizedlist>
      <listitem>
       <para>
        Se si richiedono esatte memorizzazione e calcoli (come per gli
        importi monetari), usare invece il tipo <type>numeric</type>.
       </para>
      </listitem>

      <listitem>
       <para>
        Se si vogliono fare calcoli complicati con questi tipi
        per niente di importante, specialmente se si basano su alcuni
        comportamenti in casi limite (infinito, underflow), bisogna
        valutarne attentamente l'implementazione.
       </para>
      </listitem>

      <listitem>
       <para>
        Il confronto di due valori in virgola mobile per l'uguaglianza, non è
        detto che debba funzionare come ci si attende.
       </para>
      </listitem>
     </itemizedlist>
    </para>


    <para>
     Sulla maggior parte delle piattaforme, il tipo <type>real</type> ha una
     estensione di almeno da 1E-37 a 1E+37 con una precisione di almeno 6
     cifre decimali. Il tipo <type>double precision</type> normalmente ha una
     estensione di circa da 1E-307 a 1E+308 con una precisione di almeno 15
     cifre. Valori troppo grandi o troppo piccoli causeranno un errore. Se la
     precisione di un numero in ingresso è troppo alta, si potrà
     verificare un arrotondamento. Numeri troppo prossimi a zero che non sono
     rappresentabili come diversi da zero possono causare un errore di underflow.
    </para>


    <indexterm>
     <primary>not a number</primary>
     <secondary>double precision</secondary>
    </indexterm>

    <para>
     In aggiunte ai valori numerici ordinari, i tipi in virgola mobile
     hanno alcuni valori speciali:

<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>

     Questi rappresentano rispettivamente i valori speciali IEEE 754
     <quote>infinito</quote>, <quote>infinito negativo</quote>, e
     <quote>non-un-numero</quote>.  (Su una macchina la cui aritmetica in
     virgola mobile non segue lo IEEE754, molto probabilmente non lavoreranno
     come ci si aspetta). Quando si scrivono questi valori come costanti in
     un comando SQL, bisogna racchiuderli tra apici, per esempio 
     <literal>UPDATE tabella SET x = 'Infinity'</literal>. In ingresso le stringhe
     vengono riconosciute senza distinzione tra maiuscole e minuscole.
    </para>

    <note>
     <para>
      IEEE754 specifica che <literal>NaN</literal> non dovrebbe essere uguale
      a qualsiasi altro valore in virgola mobile (<literal>NaN</literal> compreso).
      Per consentire che i valori in virgola mobile siano ordinati e usati
      in indici B-tree, <productname>PostgreSQL</productname> tratta i
      valori <literal>NaN</literal> come uguali, e maggiori di tutti i
      valori non-<literal>NaN</literal>.
     </para>
    </note>

    <para>
     <productname>PostgreSQL</productname> also supports the SQL-standard
     notations <type>float</type> and
     <type>float(<replaceable>p</replaceable>)</type> for specifying
     inexact numeric types.  Here, <replaceable>p</replaceable> specifies
     the minimum acceptable precision in <emphasis>binary</emphasis> digits.
     <productname>PostgreSQL</productname> accepts 
     <type>float(1)</type> to <type>float(24)</type> as selecting the
     <type>real</type> type, while 
     <type>float(25)</type> to <type>float(53)</type> select
     <type>double precision</type>.  Values of <replaceable>p</replaceable>
     outside the allowed range draw an error.
     <type>float</type> with no precision specified is taken to mean
     <type>double precision</type>.
    </para>

    <note>
     <para>
      Prima di <productname>PostgreSQL</productname> 7.4, la precisione nei
      <type>float(<replaceable>p</replaceable>)</type> era considerata essere di molte
      cifre decimali. Questo è stato corretto per uniformarsi allo standard SQL,
      il quale specifica che la precisione viene misurata in cifre binarie. Il
      presupposto che <type>real</type> e <type>double precision</type> abbiano nella
      mantissa, rispettivamente, esattamente 24 e 53 bit è corretto per lo
      standard IEEE nell'implementazione in virgola mobile. Sulle piattaforme non-IEEE 
      potrebbe essere leggermente diverso, ma per semplicità viene
      utilizzata la stessa estensione di <replaceable>p</replaceable> su
      tutte le piattaforme.
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
    <title>Tipi Serial</title>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>

    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>

    <para>
     I tipi di dato <type>serial</type> e <type>bigserial</type>
     non sono veri tipi, ma soltanto una convenzione simbolica
     per impostare identificatori unici di colonne
     (in maniera simile alla propriet&agrave; <literal>AUTO_INCREMENT</literal>
     supportata da alcuni altri database). Nell'implementazione corrente, specificare:

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

    è equivalente a specificare:

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

     Così, è stata creata una colonna integer e gli sono stati impostati i
     valori predefiniti che verranno assegnati da un generatore di sequenza. È stato
     applicato un vincolo <literal>NOT NULL</literal> per essere sicuri che non venga, altrimenti,
     inserito esplicitamente un valore null. (Nella maggior parte dei casi si vorrà
     anche inserire un vincolo <literal>UNIQUE</literal> o <literal>PRIMARY KEY</literal> per impedire
     l'inserimento accidentale di valori duplicati, ma questo non è automatico). Infine,
     la sequenza è contrassegnata <quote>owned by</quote> la colonna,
     in modo che potrà essere eliminata se la colonna o la tabella vengono eliminate.
    </para>

    <note>
     <para>
      Prima di <productname>PostgreSQL</productname> 7.3, <type>serial</type>
      sottintendeva <literal>UNIQUE</literal>. Questo non è più
      automatico. Se si vuole che una colonna serial abbia un vincolo unique
      o una chiave primaria, bisognerà specificarlo, come con 
      qualsiasi altro tipo di dato.
     </para>
    </note>

    <para>
     Per inserire nella colonna <type>serial</type> il successivo valore
     di sequenza, specificare che alla colonna  <type>serial</type>
     dovrà essere assegnato il suo valore predefinito. Questo può
     essere fatto o escludendo la colonna dalla lista di colonne
     nell'istruzione <command>INSERT</command>, o tramite l'uso della
     parola chiave <literal>DEFAULT</literal>.
    </para>

    <para>
     I tipi chiamati <type>serial</type> e <type>serial4</type> sono equivalenti:
     ambedue creano colonne <type>integer</type>. I tipi chiamati
     <type>bigserial</type> e <type>serial8</type> lavorano anch'essi nello stesso
     modo, eccetto che essi creano una colonna <type>bigint</type>. Il tipo
     <type>bigserial</type> dovrà essere usato solo se si prevede di usare
     un numero di identificatori maggiore di 2<superscript>31</superscript> nel corso
     della durata della tabella.
    </para>

    <para>
     La sequenza creata per una colonna <type>serial</type> viene
     automaticamente eliminata quando viene eliminata la colonna proprietaria.
     Si potrà eliminare la sequenza senza eliminare la colonna, ma questo
     forzerà la rimozione dell'espressione predefinita della colonna.
     
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>Tipi Monetari</title>

   <para>
    Il tipo <type>money</type> memorizza un ammontare di valuta con una
    precisione frazionaria fissa; vedere la <xref
    linkend="datatype-money-table" />.
    La precisione frazionale è determinata dalle impostazioni del database 
    <xref linkend="guc-lc-monetary"/>.
    L'intervallo mostrato nella tabella assume che ci siano 2 cifre frazionali.
    Il valore di input è accettato in vari formati, inclusi interi e a virgola-mobile, 
    così come tipica formattazione monetaria, come <literal>'$1,000.00'</literal>.
    L'output è generalmente nell'ultima forma ma dipende dalla localizzazione.

   </para>

    <table id="datatype-money-table">
     <title>Tipi Monetari</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Dimenzione</entry>
        <entry>Descrizione</entry>
        <entry>Estensione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>money</entry>
        <entry>8 byte</entry>
        <entry>ammontare monetario</entry>
        <entry>-92233720368547758.08 to +92233720368547758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Dato che questo tipo dato è sensibile alla localizzazione, potrebbe non
    funzionare il caricamento di dati <type>money</type> in un database che ha un'impostazione
    diversa di <varname>lc_monetary</varname>. Per evitare problemi, prima di ripristinare
    un dump bisogna assicurarsi che <varname>lc_monetary</varname> abbia lo stesso
    valore, o un equivalente, di quello che aveva il database da ripristinare.
    
   </para>

   <para>
   
        Valori di tipo <type>numeric</type> posso essere convertiti a               
        <type>money</type>. Altri tipi numerici posso essere convertiti a
        <type>money</type> eseguendo prima un cast a <type>numeric</type>, per esempio:


<programlisting>
SELECT 1234::numeric::money;
</programlisting>
        Un valore <type>money</type> può eseguire un cast di un <type>numeric</type> senza 
        perdita di precisione. La conversione ad altri tipi potrebbe potenzialmente 
        perdere precisione, e deve essere fatta in 2 passi, per esempio:
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>

   <para>
        Quando un valore <type>money</type> è diviso da un altro valore <type>money</type>,
        il risultato è <type>double precision</type> (un numero puro, 
        non un valore monetario); le unità di valuta si cancellano a vicenda nella divisione.
   </para>
  </sect1>


  <sect1 id="datatype-character">
   <title>Tipi Carattere</title>

   <indexterm zone="datatype-character">
    <primary>stringa di caratteri</primary>
    <secondary>tipi di dato</secondary>
   </indexterm>

   <indexterm>
    <primary>stringa</primary>
    <see>stringa di caratteri</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>carattere</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

    <table id="datatype-character-table">
     <title>Character Types</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Descrizione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
        <entry>lunghezza variabile, con limite</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
        <entry>lunghezza fissa, completata con blank</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
        <entry>lunghezza variabile illimitata</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>
    La <xref linkend="datatype-character-table" /> mostra i tipi di dato di
    caratteri di utilizzo generale disponibili in
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    <acronym>SQL</acronym> definisce due tipi primari di caratteri:
    <type>character varying(<replaceable>n</replaceable>)</type> e
    <type>character(<replaceable>n</replaceable>)</type>, dove <replaceable>n</replaceable> è
    un intero positivo. Ambedue questi tipi possono memorizzare stringhe fino
    a <replaceable>n</replaceable> caratteri di lunghezza. Un tentativo di memorizzare
    una stringa più lunga in una colonna di questi tipi provocherà
    un errore, a meno che i caratteri eccedenti non siano tutti spazi, in
    questo caso la stringa verrà troncata alla lunghezza massima. (Questa
    eccezione un pò bizzarra è richiesta dallo standard
    <acronym>SQL</acronym>). Se la stringa da memorizzare è più
    corta della lunghezza dichiarata, nei valori di tipo <type>character</type>
    la parte eccedente sarà completata con spazi; nei valori di tipo
    <type>character varying</type> la stringa verrà semplicemente memorizzata
    con la sua lunghezza più corta.
    
   </para>

   <para>
    Se si effettua una conversione esplicita di un valore a <type>character
    varying(<replaceable>n</replaceable>)</type> o
    <type>character(<replaceable>n</replaceable>)</type>, un eventuale eccesso di
    lunghezza del valore verrà troncato a <replaceable>n</replaceable> caratteri
    senza generare un errore. (Anche questo è richiesto dallo standard
    <acronym>SQL</acronym>).
   </para>

   <para>
    Le notazioni <type>varchar(<replaceable>n</replaceable>)</type> e
    <type>char(<replaceable>n</replaceable>)</type> sono, rispettivamente, alias
    per <type>character varying(<replaceable>n</replaceable>)</type> e
    <type>character(<replaceable>n</replaceable>)</type>. Il tipo <type>character</type>
    senza specificatore di lunghezza è equivalente a
    <type>character(1)</type>. Se <type>character varying</type> viene usato
    senza specificatore di lunghezza, accetterà stringhe di qualsiasi
    lunghezza. Quest'ultima è un'estensione di <productname>PostgreSQL</productname>.
    
   </para>

   <para>
    Inoltre, <productname>PostgreSQL</productname> fornisce il
    tipo <type>text</type>, il quale memorizza stringhe di qualsiasi lunghezza.
    Anche se il tipo <type>text</type> non è nello standard 
    <acronym>SQL</acronym>, diversi altri sitemi di gestione database SQL
    lo hanno adottato.
    
   </para>

   <para>
    I valori di tipo <type>character</type> vengono fisicamente completati con
    spazi fino alla larghezza specificata <replaceable>n</replaceable>, e vengono
    memorizzati e visualizzati in questo modo. Tuttavia gli spazi riempitivi sono
    trattati come semanticamente insignificanti. Gli spazi accodati non vengono presi
    in considerazione quando si confrontano due valori di tipo <type>character</type>,
    e vengono invece eliminati quando si converte un valore di tipo
    <type>character</type> a uno degli altri tipi stringa. Notare che gli spazi accodati
    <emphasis>sono</emphasis> semanticamente significativi nei valori
    <type>character varying</type> e <type>text</type>.
    
   </para>

   <para>
    La memoria richiesta per una stringa corta (fino a 126 byte) è di 1 byte
    più la stringa effettiva, che comprende gli spazi riempitivi nel caso di
    <type>character</type>. Stringhe più lunghe hanno 4 byte in testa invece di
    di 1. Le stringhe lunghe vengono automaticamente compresse dal sistema, per cui
    la lunghezza fisica richiesta su disco potrebbe essere minore. Valori molto lunghi vengono anche
    memorizzati in tabelle di background in modo che non interferiscano con l'accesso
    rapido a valori di colonna più corti. In ogni caso, la più lunga
    stringa di caratteri che può essere memorizzata è di circa 1 GB. (Il
    valore massimo consentito per <replaceable>n</replaceable> nella dichiarazione del tipo dato
    è inferiore a questo. Non sarebbe molto utile cambiare questo comportamento
    perchè con la codificazione di caratteri multibyte, il numero di
    caratteri e di byte può essere comunque abbastanza diverso. Se si desidera
    memorizzare stringhe lunghe con nessun limite superiore specificato, usare
    <type>text</type> o <type>character varying</type> senza specificatore di
    lunghezza, piuttosto che impostare un limite di lunghezza arbitrario).

   </para>

   <tip>
    <para>
     Non ci sono differenze di prestazioni tra questi tre tipi, a prescindere
     dalla maggiore dimensione di memorizzazione quando si utilizza il tipo con
     spazi riempitivi, e alcuni cicli CPU supplementari per controllare la lunghezza
     quando si memorizzano in colonne a lunghezza vincolata. Mentre in alcuni
     altri sistemi di database, <type>character(<replaceable>n</replaceable>)</type> ha
     vantaggi nelle prestazioni, esso non ha gli stessi vantaggi in
     <productname>PostgreSQL</productname>; Infatti <type>character(<replaceable>n</replaceable>)</type> 
     è solitamente il più lento dei tre, causa il costo del suo spazio di immagazzinamento aggiuntivo. 
     Nella maggior parte delle situazioni
     dovrebbero invece essere usati <type>text</type> o
     <type>character varying</type>.
    </para>
   </tip>

   <para>
    Vedere <xref linkend="sql-syntax-strings" /> per informazioni circa
    la sintassi delle stringhe, e in <xref linkend="functions" />
    per informazioni circa gli operatori e le funzioni disponibili. Il
    set di caratteri del database determina il set di caratteri usato per
    memorizzare valori testuali; per ulteriori informazioni sul set di
    caratteri supportato, vedere in <xref linkend="multibyte" />.
   </para>

   <example>
    <title>Utilizzare i tipi di carattere</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
       La funzione <function>char_length</function> è discussa dentro
       <xref linkend="functions-string" />.
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
    There are two other fixed-length character types in
    <productname>PostgreSQL</productname>, shown in <xref
    linkend="datatype-character-special-table"/>. The <type>name</type>
    type exists <emphasis>only</emphasis> for the storage of identifiers
    in the internal system catalogs and is not intended for use by the general user. Its
    length is currently defined as 64 bytes (63 usable characters plus
    terminator) but should be referenced using the constant
    <symbol>NAMEDATALEN</symbol> in <literal>C</literal> source code.
    The length is set at compile time (and
    is therefore adjustable for special uses); the default maximum
    length might change in a future release. The type <type>"char"</type>
    (note the quotes) is different from <type>char(1)</type> in that it
    only uses one byte of storage. It is internally used in the system
    catalogs as a simplistic enumeration type.
    
    Ci sono altri due tipi carattere a lunghezza fissa in
    <productname>PostgreSQL</productname>, mostrati nella <xref
    linkend="datatype-character-special-table" />. Il tipo <type>name</type>
    esiste <emphasis>solo</emphasis> per memorizzazioni di identificatori lunghi
    nei cataloghi di sistema e non è destinato per un uso generale degli utenti. La sua
    lunghezza è attualmente definita di 64 byte (63 caratteri usabili più il
    terminatore) ma dovrebbe essere referenziata usando la costante
    <symbol>NAMEDATALEN</symbol> nel codice sorgente <literal>C</literal> . 
    La lunghezza è impostata al momento della compilazione (ed
    è quindi adattabile per usi speciali); 
    La lunghezza massima preimpostata potrebbe essere
    cambiata in un futuro rilascio. Il tipo <type>"char"</type>
    (notare gli apici) è diverso da <type>char(1)</type> in quanto
<!-- /TODO tipo di enumerazione semplicistica??? -->
    usa solo un byte di memorizzazione. Viene usato internamente nei cataloghi di
    sistema come tipo di enumerazione semplicistica.
   </para>

    <table id="datatype-character-special-table">
     <title>Tipi Carattere Speciali</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Dimensione</entry>
        <entry>Descrizione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 byte</entry>
        <entry>tipo interno a 1-byte</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <entry>64 bytes</entry>
        <entry>tipo interno per i nomi di oggetti</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>Tipi di dato binari</title>

  <indexterm zone="datatype-binary">
   <primary>dato binario</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>

   <para>
    Il tipo di dato <type>bytea</type> consente memorizzazioni di stringhe binarie;
    Vedere <xref linkend="datatype-binary-table" />.
   </para>

   <table id="datatype-binary-table">
    <title>Tipi di dato binari</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nome</entry>
       <entry>Dimensione</entry>
       <entry>Descrizione</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>1 o 4 byte più l'attuale stringa binaria</entry>
       <entry>stringa binaria a lunghezza variabile</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Una stringa binaria è una sequenza di ottetti (o byte). Le stringhe
    binarie si distinguono dalle stringhe di caratteri per due caratteristiche.
    In primo luogo, le stringhe binarie consentono specificatamente la memorizzazione 
    di ottetti di valore zero e altri ottetti <quote>non-stampabili</quote>
    (normalmente ottetti al di fuori della gamma da 32 a 126). Le stringhe di
    caratteri non accettano ottetti zero, e neanche altri valori di ottetti e
    sequenze di valori di ottetti che non sono validi secondo la codifica del
    set di caratteri selezionata dal database. In secondo luogo, le operazioni
    sulle stringhe binarie elaborano i byte reali, mentre l'elaborazione delle
    stringhe di caratteri dipende dall'impostazione della localizzazione.
    In breve, le stringhe binarie sono indicate per la memorizzazione di dati che
    il programmatore ritiene <quote>byte non codificati</quote>, mentre le stringhe di
    caratteri sono indicate per memorizzare testo.
   </para>

   <para>
    
        Il tipo <type>bytea</type> supporta 2 formati esterni per 
        l'input e l'output: il formato <quote>escape</quote>, storico
        di <productname>PostgreSQL</productname>, e il formato <quote>hex</quote>.
        Ambedue sono accettati in input. Il formato di output dipende 
        dal parametro di configurazione <xref linkend="guc-bytea-output"/>;
        Il default è hex. (Notare che il formato hex è stato introdotto in 
        <productname>PostgreSQL</productname> 9.0; Versioni precedenti ed alcuni 
        strumenti non lo capiscono.)
   </para>

   <para>
        Lo standard <acronym>SQL</acronym> definisce un altro tipo 
        di stringa binaria, chiamato  <type>BLOB</type> o <type>BINARY LARGE
        OBJECT</type>. Il formato di input è diverso da
        <type>bytea</type>, ma le funzioni e gli operatori messe a disposizione sono
        per la maggior parte le stesse.
   </para>

  <sect2>
   <title>Il formato hex di <type>bytea</type></title>

   <para>
        Il formato <quote>hex</quote> codifica i dati binari come 2 cifre esadecimali 
        per byte, mettendo prima il nibble più significativo. L'intera stringa è
        preceduta dalla sequenza  <literal>\x</literal> (per distinguerla dal
        formato escape). In alcuni contesti, la barra inversa iniziale potrebbe
        avere bisogno di un escape, quindi va raddoppiata, come nei casi in cui le barre inverse
        devono essere raddoppiate nel formato escape; Dettagli sotto.
        Le cifre esadecimali possono
        essere sia maiuscole che minuscole, e sono permessi spazi bianchi tra
        coppie di cifre (ma non all'interno di una coppia di cifre e nemmeno nella sequenza
        iniziale <literal>\x</literal> ).
        Il formato hex è compatibile con una vasta
        gamme di applicazioni e protocolli, e tende ad essere più veloce
        da convertire rispetto al formato escape, per questo il suo uso è preferibile.
   </para>

   <para>
    Example:
<programlisting>
SELECT E'\\xDEADBEEF';
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Il formato escape di <type>bytea</type></title>

   <para>
        Il formato <quote>escape</quote> è il formato tradizionale di
        <productname>PostgreSQL</productname> per il tipo <type>bytea</type>.
        Esso
        usa l'approccio di rappresentare una stringa binaria come una sequenza
        di caratteri ASCII, convertendo i byte che non possono essere rappresentati 
        come carattere ASCII in sequence di escape speciali.
        Se, dal punto di vista dell'applicazione, rappresentare i byte 
        come caratteri ha senso, allora questa rappresentazione può essere
        conveniente. Ma in pratica, di solito questo è fuorviante, in quanto
        maschera la distinzione fra stringhe binarie e stringhe di caratteri.
<!-- /TODO and also the particular escape mechanism that was chosen is somewhat unwieldy. -->        
        Per questo, questo formato dovrebbe probabilmente essere evitato per la
        maggior parte delle nuove applicazioni.
   </para>

   <para>
        Quando si inseriscono valori <type>bytea</type> in formato escape, 
        ottetti di certi
        valori <emphasis>devono</emphasis> essere espressi in formato escape, mentre tutti i 
        valori ottetti <emphasis>possono</emphasis> essere espressi in formato escape. In
        generale, per esprimere un ottetto in formato escape, convertirlo nel suo valore 
        ottale e precederlo da
        una barra inversa (o due barre inverse, se si sta scrivendo il valore 
        come un valore letterale che usa la sintassi di escape di stringa).
        La barra inversa di per sè (valore di ottetto 92) può alternativamente essere rappresentata da
        doppie barre inverse.
        <xref linkend="datatype-binary-sqlesc"/>
        mostra i caratteri che devono essere espressi con l'escape, e mostra le 
        sequenze di escape alternative dove sono applicabili.
   </para>

   <table id="datatype-binary-sqlesc">
    <title>Sequenze di escape di ottetti letterali per <type>bytea</type></title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Valore decimale ottetto</entry>
       <entry>Descrizione</entry>
       <entry>Rappresentazione sequenza di escape in ingresso</entry>
       <entry>Esempio</entry>
       <entry>Rappresentazione in uscita</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>ottetto 0</entry>
       <entry><literal>E'\\000'</literal></entry>
       <entry><literal>SELECT E'\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>apice singolo</entry>
       <entry><literal>''''</literal> or <literal>E'\\047'</literal></entry>
       <entry><literal>SELECT E'\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>barra inversa</entry>
       <entry><literal>E'\\\\'</literal> or <literal>E'\\134'</literal></entry>
       <entry><literal>SELECT E'\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>da 0 a 31 e da 127 a 255</entry>
       <entry>ottetti <quote>non stampabili</quote></entry>
       <entry><literal>E'\\<replaceable>xxx'</replaceable></literal> (valore ottale)</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    La necessità di codificare le sequenze di escape per gli ottetti 
    <quote>non stampabili</quote> varia a seconda dell'impostazione locale. 
    In alcuni
    casi è possibile cavarsela senza dover fare l'escape. Notare che il risultato in
    ognuno degli esempi in <xref linkend="datatype-binary-sqlesc" /> è
    esattamente della lunghezza di un ottetto, anche se la rappresentazione d'uscita degli
    ottetti a volte è maggiore di un carattere.
   </para>

   <para>
    La ragione per cui bisogna scrivere diverse barre inverse, come mostrato nella
    <xref linkend="datatype-binary-sqlesc" />, è che una stringa in input,
    scritta come stringa letterale, deve passare attraverso due fasi di analisi
    nel server <productname>PostgreSQL</productname>. La prima barra inversa
    di ogni paio viene interpretata come un carattere di escape dall'analizzatore
    di stringhe letterali (assumendo che si stia utilizzando la sintassi di escape per le
    stringhe) e viene quindi eliminata, lasciando invariata la seconda
    barra inversa del paio. (Per eliminare questo livello di decodifica del carattere di
    escape è possibile utilizzare le stringhe racchiuse tra caratteri dollaro).
    La barra inversa rimasta viene quindi riconosciuta dalla funzione di input di
    <type>bytea</type> o come inizio di un valore ottale di tre cifre, oppure come
    un'altro carattere barra inversa di escape. Per esempio, una stringa letterale passata
    al server come <literal>E'\\001'</literal> diventa <literal>\001</literal>
    dopo essere passata attraverso l'analizzatore di sequenze di escape. Il valore
    <literal>\001</literal> viene quindi passato alla funzione di input di
    <type>bytea</type>, dove viene convertito in un singolo ottetto con valore
    decimale 1. Notare che il carattere racchiuso tra singoli-apici non viene
    specificatamente trattato da <type>bytea</type> per cui segue le regole normali
    per le stringhe letterali. (Vedere anche <xref linkend="sql-syntax-strings" />). 
   </para>

   <para>
    Gli ottetti di <type>Bytea</type> a volte vengono codificati come sequenze di escape
    in uscita. Generalmente ogni ottetto <quote>non-stampabile</quote> viene convertito
    nel suo equivalente valore ottale a tre cifre e preceduto da una barra inversa.
    La maggior parte degli ottetti <quote>stampabili</quote> vengono rappresentati
    nella loro rappresentazione standard nel set di caratteri del client. L'ottetto con valore
    decimale 92 (barra inversa) viene raddoppiato in uscita.
    Maggiori dettagli in <xref linkend="datatype-binary-resesc" />.
    
   </para>

   <table id="datatype-binary-resesc">
    <title>Ottetti di <type>bytea</type> con escape in uscita</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Valore decimale ottetto</entry>
       <entry>Descrizione</entry>
       <entry>Rappresentazione sequenza di escape in uscita</entry>
       <entry>Esempio</entry>
       <entry>Risultato in uscita</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>barra inversa</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT E'\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <entry>ottetti <quote>non stampabili</quote></entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal> (valore ottale)</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32 to 126</entry>
       <entry>ottetti <quote>stampabili</quote></entry>
       <entry>rappresentazione in base al set di caratteri del client</entry>
       <entry><literal>SELECT E'\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    In base al front end di <productname>PostgreSQL</productname> utilizzato, potrebbe
    essere necessario fare del lavoro aggiuntivo sulla codifica e la decodifica
    delle sequenze di escape per le stringhe di <type>bytea</type>. Per esempio, si
    potrebbe anche dover fare l'escape per l'accapo e per il ritorno carrello se la
    vostra interfaccia non li trasforma automaticamente.
    
   </para>
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
   <title>Tipi di Data/Orario</title>

   <indexterm zone="datatype-datetime">
    <primary>data</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>orario</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>orario senza fuso orario</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>orario con fuso orario</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp con fuso orario</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp senza fuso orario</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>intervallo</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>arco di tempo</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> supporta l'insieme
    completo dei tipi data e ora di <acronym>SQL</acronym>,
    visualizzato nella <xref linkend="datatype-datetime-table" />.
    Le operazioni disponibili in questi tipi di dati sono
    descritte in <xref linkend="functions-datetime" />.
    
   </para>

    <table id="datatype-datetime-table">
     <title>Tipi data/orario</title>
     <tgroup cols="6">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Dimensione</entry>
        <entry>Descrizione</entry>
        <entry>Valore minimo</entry>
        <entry>Valore massimo</entry>
        <entry>Risoluzione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 byte</entry>
        <entry>sia data che orario (senza fuso orario)</entry>
        <entry>4713 AC</entry>
        <entry>294276 DC</entry>
        <entry>1 microsecondo / 14 cifre</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8 byte</entry>
        <entry>sia data che orario, con fuso orario</entry>
        <entry>4713 AC</entry>
        <entry>294276 DC</entry>
        <entry>1 microsecondo / 14 cifre</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>4 byte</entry>
        <entry>data (senza orario del giorno)</entry>
        <entry>4713 AC</entry>
        <entry>5874897 DC</entry>
        <entry>1 giorno</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 byte</entry>
        <entry>orario del giorno (senza data)</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 microsecondo / 14 cifre</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12 byte</entry>
        <entry>solo orario del giorno, con fuso orario</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1 microsecondo / 14 cifre</entry>
       </row>
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>12 byte</entry>
        <entry>intervallo di tempo</entry>
        <entry>-178000000 anni</entry>
        <entry>178000000 anni</entry>
        <entry>1 microsecondo / 14 cifre</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
        Lo standard SQL considera che <type>timestamp</type>
        da solo sia equivalente a <type>timestamp without time zone</type> (timestamp senza fuso orario),
        e <productname>PostgreSQL</productname> segue lo stesso comportamento.
        (Le versioni di <productname>PostgreSQL</productname> precedenti la 7.3, tarttavano i <type>timestamp</type>
        come <type>timestamp with time zone</type> (timestamp con fuso orario).)
    </para>
   </note>

   <para>
    I tipi <type>time</type>, <type>timestamp</type>, e
    <type>interval</type> accettano un valore opzionale di precisione
    <replaceable>p</replaceable>, il quale specifica il numero di
    cifre decimali restituite nel campo dei secondi. Per impostazione predefinita, non
    c'è alcun vincolo esplicito di precisione. L'estensione consentita per
    <replaceable>p</replaceable> è da 0 a 6 cifre per i tipi
    <type>timestamp</type> e <type>interval</type>.
    
   </para>

   <note>
   <para>
        Quando valori <type>timestamp</type> sono memorizzati come interi a otto byte
        (attualmente per default), la precizione al microsecondo è disponibile 
        per tutta la gamma di valori. Quando invece i valori <type>timestamp</type> sono
        memorizzati come numeri a vorgola mobile con doppia precisione, (un'opzione
        di compilazione deprecata), il limite effettivo di precisione 
        potrebbe essere minore di 6. I valori <type>timestamp</type> sono memorizzati
        come secondi prima o dopo la mezzanotte del 01/01/2000. Quando 
        i valori <type>timestamp</type> sono implementati usando numeri a
        virgola mobile, la precisione al millisecondo è disponibile per date entro pochi
        anni dal 01/01/2000, ma la precisione degrada per date più lontane.
        Notare che l'uso di datetimes a virgola mobile permette un una gamma maggiore di 
        valori rispetto a quanto mostrato sopra:
        da 4713 AC fino a 5874897 DC.
   </para>

   <para>
        La stessa opzione di compilazione determina se
        i valori <type>time</type> e <type>interval</type> sono memorizzati come
        numeri a virgola mobile o interi a otto byte. Nel caso della virgola mobile,
        valori di grandi intervalli degradano in precisione 
        man mano che la dimensione dell'intervallo cresce.
   </para>
   </note>

   <para>
    Per i tipi <type>time</type>, il valore consentito per <replaceable>p</replaceable>
    va da 0 a 6 se si utilizza la memorizzazione con intero a otto byte,
    o da 0 a 10 quando si utilizza la memorizzazione in virgola mobile.
   </para>

   <para>
        Il tipo  <type>interval</type> ha un'opzione aggiuntiva, che è
        di restringere l'insieme dei campi memorizzati scrivendo una di queste frasi:
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
        Notare che se sono specificate sia <replaceable>fields</replaceable> che 
        <replaceable>p</replaceable>, l'opzione  
        <replaceable>fields</replaceable> deve includere <literal>SECOND</literal>,
        dato che la precisione si applica solo sui secondi.
   </para>

   <para>
    Il tipo <type>time with time zone</type> è definito dallo standard
    SQL, ma la definizione espone proprietà che portano ad un utilizzo
    discutibile. Nella maggior parte dei casi, una combinazione di
    <type>date</type>, <type>time</type>, <type>timestamp without time
    zone</type> e <type>timestamp with time zone</type> dovrebbe
    fornire una completa gamma di funzionalità per data/ora richiesta
    da qualsiasi applicazione.
    
   </para>

   <para>
    I tipi <type>abstime</type> e <type>reltime</type>
    sono tipi a bassa precisione che sono usati internamente.
    Siete sconsigliati dall'utilizzare questi tipi nelle
    applicazioni. Questi tipi interni
    potrebbero sparire nei rilasci futuri.
   </para>

   <sect2 id="datatype-datetime-input">
    <title>Input di date/orari</title>

    <para>
     L'input per le date e le ore è accettato in qualsiasi plausibile formato,
     compreso il formato ISO 8601, <acronym>SQL</acronym>-compatibile, i formati
     tradizionali <productname>POSTGRES</productname>, ed altri. Per alcuni formati,
     il posizionamento per mese, giorno e anno nelle date in input è ambiguo
     ed esiste un supporto per specificare il posizionamento desiderato per questi
     campi . Impostare il parametro <xref linkend="guc-datestyle" /> a
     <literal>MDY</literal> per selezionare la disposizione mese-giorno-anno,
     <literal>DMY</literal> per selezionare la disposizione giorno-mese-anno,
     <literal>YMD</literal> per selezionare la disposizione anno-mese-giorno.
    </para>

    <para>
     <productname>PostgreSQL</productname> è più
     flessibile nella gestione dell'input di data/ora rispetto a
     quanto richiesto dallo standard <acronym>SQL</acronym>. Vedere
     <xref linkend="datetime-appendix" /> per conoscere le regole
     esatte di conversione dell'input di data/ora e per i campi di
     testo riconosciuti compresi mesi, giorni della settimana, e
     fusi orari. 
    </para>

    <para>
     Ricordare che ogni data o orario letterale in ingresso deve essere
     racchiuso tra singoli apici, come le stringhe di testo. Vedere
     <xref linkend="sql-syntax-constants-generic" /> per ulteriori
     informazioni.
     <acronym>SQL</acronym> richiede la seguente sintassi
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     dove la specifica di precisione opzionale <replaceable>p</replaceable>
     è un intero corrispondente al numero delle cifre decimali nel
     campo dei secondi. La precisione può essere
     specificata per i tipi <type>time</type>, <type>timestamp</type> e
     <type>interval</type>. I valori consentiti sono stati specificati
     sopra. Se non viene specificata nessuna costante di precisione,
     come precisione viene assunta quella propria del valore letterale.
     
    </para>

    <sect3>
    <title>Date</title>

    <indexterm>
     <primary>date</primary>
    </indexterm>
 
    <para>
     La <xref linkend="datatype-datetime-date-table" /> mostra alcuni possibili
     valori di input per il tipo <type>date</type>.
    </para>

     <table id="datatype-datetime-date-table">
      <title>Input per le date</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Esempio</entry>
         <entry>Descrizione</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; 8 Gennaio in qualsiasi modo
         (formato raccomandato)</entry>
        </row>
        <row>
         <entry>January 8, 1999</entry>
         <entry>non ambiguo per qualsiasi modo di input impostato con <varname>datestyle</varname></entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <entry>8 Gennaio nel modo <literal>MDY</literal>;
          1 Agosto nel modo <literal>DMY</literal></entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <entry>18 Gennaio nel modo <literal>MDY</literal>;
          respinto negli altri modi</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <entry>2 Gennaio 2003 nel modo <literal>MDY</literal>;
          1 Febbraio 2003 nel modo <literal>DMY</literal>;
          3 Febbraio 2001 nel modo <literal>YMD</literal>
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <entry>8 Gennaio in qualsiasi modo</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <entry>8 Gennaio in qualsiasi modo</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <entry>8 Gennaio in qualsiasi modo</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <entry>8 Gennaio nel modo <literal>YMD</literal>, altrimenti errore</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <entry>8 Gennaio, errore se in modo <literal>YMD</literal></entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <entry>8 Gennaio, errore se in modo <literal>YMD</literal></entry>
        </row>
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; 8 Gennaio 1999 in qualsiasi modo</entry>
        </row>
        <row>
         <entry>990108</entry>
         <entry>ISO 8601;  8 Gennaio 1999 in qualsiasi modo</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <entry>anno e giorno dell'anno</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <entry>giorno giuliano</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>anno 99 AC</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
     <title>Orari</title>

     <indexterm>
      <primary>time</primary>
     </indexterm>
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>

     <para>
      I tipi relativi alle ore del giorno sono <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> e
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>.  Scrivere solo <type>time</type> equivale a scrivere
      <type>time without time zone</type>.
     </para>

     <para>
      Input validi per questi tipi consistono in un ora del giorno seguita
      da un opzionale fuso orario. (Vedere la <xref
      linkend="datatype-datetime-time-table" /> e la 
      <xref linkend="datatype-timezone-table" />). Se viene specificato il fuso
      orario nell'input di <type>time without time zone</type>, questo viene
      tranquillamente ignorato. Anche se viene specificata una data, questa
      sarà ignorata, eccetto se viene utilizzato un nome di fuso orario
      che coinvolge un utilizzo di ora estiva, come <literal>America/New_York</literal>.
      In questo caso è necessario specificare la data per determinare
      se si deve applicare l'ora standard o quella estiva. L'offset
      appropriato per il fuso orario è registrato nel valore
      <type>time with time zone</type>.

     </para>

      <table id="datatype-datetime-time-table">
       <title>Input per gli orari</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Esempio</entry>
          <entry>Descrizione</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>stesso di 04:05; AM non influisce sul valore</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>stesso di 16:05; l'ora di ingresso deve essere &lt;= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>fuso orario specificato con un'abbreviazione</entry>
         </row>
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>fuso orario specificato con il nome completo</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <title>Input di fuso orario</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Esempio</entry>
          <entry>Descrizione</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>PST</literal></entry>
          <entry>Abbreviazione (per Pacific Standard Time)</entry>
         </row>
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>Nome compelto del fuso orario</entry>
         </row>
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>Specifica del fuso orario in stile POSIX</entry>
         </row>
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>ISO-8601 scostamento da PST</entry>
         </row>
         <row>
          <entry><literal>-800</literal></entry>
          <entry>ISO-8601 scostamento da PST</entry>
         </row>
         <row>
          <entry><literal>-8</literal></entry>
          <entry>ISO-8601 scostamento da PST</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>Abbreviazione militare per UTC</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <entry>Forma contratta di <literal>zulu</literal></entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>
        Riferirsi a <xref linkend="datatype-timezones"/> per maggiori informazioni su 
        come specificare il fuso orario.
    </para>
    </sect3>

    <sect3>
    <title>Input per i timestamp</title>

    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

     <para>
      Input validi per i tipi timestamp consistono in una concatenazione di una
      data e un'orario, seguiti da un opzionale fuso orario e da un opzionale
      <literal>AD</literal> o <literal>BC</literal>. (Alternativamente,
      <literal>AD</literal>/<literal>BC</literal> pu&ograve; apparire
      prima del fuso orario, ma questo non &egrave; l'ordine preferito).
      Per cui:

<programlisting>
1999-01-08 04:05:06
</programlisting>
      e:
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      sono valori validi, che seguono lo standard <acronym>ISO</acronym> 8601.
      In aggiunta, il formato largamente diffuso:
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      è supportato.
     </para>

     <para>
      Lo standard <acronym>SQL</acronym> differenzia i letterali <type>timestamp without time zone</type> 
      e <type>timestamp with time zone</type> per la presenza di un <quote>+</quote> o
      <quote>-</quote> e lo scostamento di fuso orario. Per cui, secondo lo standard, 
      <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>
      è un <type>timestamp without time zone</type>, mentre
      <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>
      è un a <type>timestamp with time zone</type>.
      <productname>PostgreSQL</productname> non esamina mai il contenuto di una
      stinga letterale prima di determinare il relativo tipo, e quindi tratterà
      entrambi i tipi visti sopra come <type>timestamp without time zone</type>. Per
      assicurarsi che un letterale venga trattato come <type>timestamp with time
      zone</type>, bisogna fornirgli il corretto tipo esplicito:
      <programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>
      In un lettarale, che è stato determinato essere <type>timestamp without time
      zone</type>, <productname>PostgreSQL</productname> ignorerà tranquillamente
      qualsiasi indicazione di fuso orario.
      Cioè, il valore risultante deriverà dal valore in input dei campi
      data/ora, e non verrà adattato al fuso orario.
     </para>


     <para>
      Per <type>timestamp with time zone</type>, il valore memorizzato
      internamente è sempre in UTC (Universal Coordinated Time,
      tradizionalmente conosciuto come Greenwich Mean Time,
      <acronym>GMT</acronym>). Un valore in input che ha un esplicito fuso
      orario specificato viene convertito in UTC utilizzando lo scostamento specifico
      per quel fuso orario. Se nella stringa in input non è stato indicato
      il fuso orario si suppone che il fuso orario sia quello  indicato nel parametro di
      sistema <xref linkend="guc-timezone" />, e quindi viene convertita in UTC utilizzando
      lo scostamento per il fuso <varname>timezone</varname>.
    </para>

     <para>
      Quando in uscita si ha un valore <type>timestamp with time zone</type>,
      questo viene sempre convertito da UTC al corrente fuso
      <varname>timezone</varname>, e visualizzato come ora locale in quel fuso.
      Per visualizzare l'ora in un altro fuso orario, modificare
      <varname>timezone</varname> o usare il costrutto <literal>AT TIME ZONE</literal>
      (vedere dentro <xref linkend="functions-datetime-zoneconvert" />).
     </para>

     <para>
      Le conversioni tra <type>timestamp without time zone</type> e
      <type>timestamp with time zone</type> assumono normalmente che il
      valore <type>timestamp without time zone</type> verrà accettato o fornito
      come ora locale <varname>timezone</varname>. Un diverso riferimento di fuso può
      essere specificato per la conversione utilizzando <literal>AT TIME ZONE</literal>.
     </para>
    </sect3>

    <sect3>
     <title>Valori speciali</title>

     <indexterm>
      <primary>time</primary>
      <secondary>costanti</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>costanti</secondary>
     </indexterm>

     <para>
      <productname>PostgreSQL</productname> supporta in input, per comodità,
      diversi valori speciali di data/ora, come mostrato nella <xref
      linkend="datatype-datetime-special-table" />. I valori
      <literal>infinity</literal> e <literal>-infinity</literal>
      sono rappresentazioni speciali all'interno del sistema e possono essere
      visualizzati nel modo normale; ma gli altri sono semplici notazioni 
      abbreviate che verranno convertite in valori data/ora ordinari quando letti.
      (In particolare, <literal>now</literal> e le relative stringhe vengono convertite in
      uno specifici valori di orario al momento appena vengono lette).
      Tutti questi valori devono essere scritti racchiusi tra singoli apici quando
      vengono usati come costanti in comandi SQL.
      
     </para>

      <table id="datatype-datetime-special-table">
       <title>Input speciali di data/ora</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Stringa in input</entry>
          <entry>Tipi validi</entry>
          <entry>Descrizione</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00 (Tempo zero di sistema UNIX)</entry>
         </row>
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>successivo a tutti gli altri time stamps</entry>
         </row>
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>precedente a tutti gli altri time stamps</entry>
         </row>
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>momento di avvio della transazione corrente</entry>
         </row>
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>mezzanotte di oggi</entry>
         </row>
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>mezzanotte di domani</entry>
         </row>
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>mezzanotte di ieri</entry>
         </row>
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>
      Le seguenti funzioni compatibili <acronym>SQL</acronym> possono anche
      essere utilizzate per ottenere l'attuale valore temporale per il corrispondente
      tipo di dato:
      <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, 
      <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>, 
      <literal>LOCALTIMESTAMP</literal>.  Le ultime quattro accettano la 
      specificazione opzionale di precisione dei subsecondi.  (Vedere <xref 
      linkend="functions-datetime-current" />.)  Notare uttavia che queste sono
      funzioni SQL e <emphasis>non</emphasis> sono riconosciute come stringhe per input dati.
     </para>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>Ouput di data/ora</title>

    <indexterm>
     <primary>date</primary>
     <secondary>formato di output</secondary>
     <seealso>formattazione</seealso>
    </indexterm>

    <indexterm>
     <primary>time</primary>
     <secondary>formato di output</secondary>
     <seealso>formattazione</seealso>
    </indexterm>

    <para>
     Il formato di output dei tipi data/ora può essere impostato a uno dei quattro
     stili ISO 8601,
     <acronym>SQL</acronym> (Ingres), POSTGRES tradizionale e
     German, utilizzando il comando <literal>SET datestyle</literal>.
     Il formato predefinito è l'<acronym>ISO</acronym>. (Lo 
     standard <acronym>SQL</acronym> richiede l'uso del formato ISO 8601.
     Il nome del formato di output <quote>SQL</quote> è un
     incidente storico). La <xref
     linkend="datatype-datetime-output-table" /> mostra esempi di ogni
     stile di output.  L'output dei tipi <type>date</type> e
     <type>time</type> è naturalmente solo la parte data o ora
     in conformità con l'esempio fornito.
    </para>

     <table id="datatype-datetime-output-table">
      <title>Stili di output per data/ora</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Specifica stile</entry>
         <entry>Descrizione</entry>
         <entry>Esempio</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>ISO</entry>
         <entry>ISO 8601/SQL standard</entry>
         <entry>1997-12-17 07:37:16-08</entry>
        </row>
        <row>
         <entry>SQL</entry>
         <entry>stile tradizionale</entry>
         <entry>12/17/1997 07:37:16.00 PST</entry>
        </row>
        <row>
         <entry>POSTGRES</entry>
         <entry>stile originale</entry>
         <entry>Wed Dec 17 07:37:16 1997 PST</entry>
        </row>
        <row>
         <entry>German</entry>
         <entry>stile regionale</entry>
         <entry>17.12.1997 07:37:16.00 PST</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Negli stili <acronym>SQL</acronym> e POSTGRES, se è stato specificato
     il campo di ordinamento DMY, i giorni compaiono prima dei mesi, altrimenti i mesi compaiono
     prima dei giorni.
     (Vedere <xref linkend="datatype-datetime-input" />
     per come questa impostazione influisce nell'interpretazione dei valori in input).
     La <xref linkend="datatype-datetime-output2-table" /> mostra un
     esempio.
     
    </para>

     <table id="datatype-datetime-output2-table">
      <title>Convenzioni di ordinamento della data</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Impostazione <varname>datestyle</varname></entry>
         <entry>Ordinamento in input</entry>
         <entry>Esempio di output</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>giorno</replaceable>/<replaceable>mese</replaceable>/<replaceable>anno</replaceable></entry>
         <entry>17/12/1997 15:37:16.00 CET</entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>mese</replaceable>/<replaceable>giorno</replaceable>/<replaceable>anno</replaceable></entry>
         <entry>12/17/1997 07:37:16.00 PST</entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>giorno</replaceable>/<replaceable>mese</replaceable>/<replaceable>anno</replaceable></entry>
         <entry>Wed 17 Dec 07:37:16 1997 PST</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Gli stili di data/ora, possono essere selezionati dall'utente usando il
     comando <command>SET datestyle</command>, il parametro <xref
     linkend="guc-datestyle" /> nel
     file di configurazione <filename>postgresql.conf</filename>, o la
     variabile di ambiente <envar>PGDATESTYLE</envar> nel server o nel
     client. Per formattare l'output di data/ora in un modo più flessibile,
     è anche disponibile la funzione <function>to_char</function> 
     (Vedere <xref linkend="functions-formatting" />).
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title>Fusi OrarioTime Zones</title>

    <indexterm zone="datatype-timezones">
     <primary>fuso orario</primary>
    </indexterm>

   <para>
    I fusi orari e le convenzioni per i fusi orari, sono influenzati da
    decisioni politiche, non solo dalla geometria della terra. I fusi orari intorno al
    mondo cominciano ad essere standardizzati durante il 1900,
    ma continuano ad essere soggetti a modifiche arbitrarie, particolarmente
    rispetto alle regole per l'ora estiva.
    
        <productname>PostgreSQL</productname> sfrutta il database di fusi orari
        <literal>zoneinfo</literal> per informazioni sulle regole storiche
        riguardanti i fusi orario. Per orari, nel futuro, si assume 
        che l'ultima regola per un dato fuso orario continui
        ad essere osservata indefinitamente nel futuro.
   </para>

    <para>
	  
    <productname>PostgreSQL</productname> si sforza di essere compatibile con
     le definizioni dello standard <acronym>SQL</acronym> per usi tipici.
     Tuttavia, lo standard <acronym>SQL</acronym> ha uno strano miscuglio di tipi e di
     possibilità per data e ora. Due problemi evidenti sono:

     <itemizedlist>
      <listitem>
       <para>
        Anche se il tipo <type>date</type> non ha 
        un fuso orario associato, il tipo
        <type>time</type> potrebbe averlo.
        I fusi orari nel mondo reale hanno uno scarso significato a meno che
        non siano associati ad una data oltre che ad un ora, poichè
        lo scostamento può variare durante l'anno, in funzione
        dell'applicazione dell'ora estiva.
        
       </para>
      </listitem>

      <listitem>
       <para>
        Il fuso orario predefinito è specificato come una costante numerica di 
        scostamento da <acronym>UTC</acronym>. Non è perciò possibile adattarlo
        all'ora estiva quando l'aritmetica data/ora viene fatta attraverso i
        confini del <acronym>DST</acronym>.
        
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     Per far fronte a queste difficoltà, si raccomanda di utilizzare tipi data/ora che
     contengano ambedue le informazioni di data e ora quando si utilizzano i fusi orari. Si
     raccomanda di <emphasis>non</emphasis> utilizzare il tipo <type>time with
     time zone</type> (Anche se è supportato da
     <productname>PostgreSQL</productname> per le applicazioni ereditate e
     per conformità con lo standard <acronym>SQL</acronym>).
     <productname>PostgreSQL</productname> presume che
     il fuso orario locale per qualsiasi tipo contenga solo data o ora.
     
    </para>

    <para>
     Tutte le date e ore consapevoli del fuso orario sono memorizzate internamente
     in <acronym>UTC</acronym>. Esse vengono convertite in ora locale nel fuso
     specificato dal parametro di configurazione <xref linkend="guc-timezone" />
     prima di essere visualizate al client.
    </para>

    <para>
     <productname>PostgreSQL</productname> consente di specificare il fuso orario
        in tre modi differenti:
     <itemizedlist>
      <listitem>
       <para>
        Un nome completo di fuso orario, per esempio <literal>America/New_York</literal>.
        I nomi riconosciuti di fusi orario sono elencati nella
        vista <literal>pg_timezone_names</literal> (vedere <xref
        linkend="view-pg-timezone-names" />).
        <productname>PostgreSQL</productname> utilizza per questo scopo
        i dati di fusi orari <literal>zic</literal> ampiamente usati, in modo che gli stessi
        nomi siano riconosciuti anche da molti altri software.
        
       </para>
      </listitem>
      <listitem>
       <para>
        Una abbreviazione di fuso orario, per esempio <literal>PST</literal>. Tale
        specifica si limita a definire un particolare scostamento da UTC, in
        contrasto con il nome completo di fuso orario il quale potrebbe implicare
        un insieme di regole di transizioni delle date per l'ora estiva. Le abbreviazioni
        riconosciute sono elencate nella vista <literal>pg_timezone_abbrevs</literal>
        (vedere <xref linkend="view-pg-timezone-abbrevs" />). Non si possono
        impostare i parametri di configurazione <xref linkend="guc-timezone" /> o
        <xref linkend="guc-log-timezone" /> utilizzando un'abbrevizione
        di fuso orario, ma si possono usare le abbreviazioni nei valori
        di input data/ora e con l'operatore
        <literal>AT TIME ZONE</literal>.
        
       </para>
      </listitem>
      <listitem>
       <para>
        Oltre ai nomi di fusi orari e alla abbreviazioni,
        <productname>PostgreSQL</productname> accetterà anche specificazioni
        di fuso orario stile POSIX nella forma <replaceable>STD</replaceable><replaceable>scostamento</replaceable> o
        <replaceable>STD</replaceable><replaceable>scostamento</replaceable><replaceable>DST</replaceable>, dove
        <replaceable>STD</replaceable> è una abbreviazione di fuso, <replaceable>scostamento</replaceable> è uno
        scostamento numerico in ore a sinistra da UTC, e <replaceable>DST</replaceable> è un
        opzionale  abbreviazione di "zona di ora estiva", presupponendo di stare un'ora avanti
        dallo scostamento fornito. Per esempio, se <literal>EST5EDT</literal> non è
        un nome riconosciuto di fuso orario, esso sarà accettato e sarà funzionalmente
        equivalente all'ora della costa est degli USA. Quando è presente
        un nome di fuso di ora legale, si presuppone che sarà usato
        con le stesse regole di transizione all'ora estiva usate nelle voci
        <filename>posixrule</filename> del database di fusi orari <literal>zic</literal>.
        In una installazione <productname>PostgreSQL</productname> standard,
        <filename>posixrules</filename> è identico a <literal>US/Eastern</literal>, così
        che le specificazioni di fusi orari in stile POSIX seguono le regole dell'ora estiva
        USA. Se necessario, è possibile modificare questo comportamento sostituendo
        il file <filename>posixrules</filename>.
        
       </para>
      </listitem>
     </itemizedlist>

     In breve, c'è una differenza concettuale e pratica tra le abbreviazioni
     e i nomi completi: le abbreviazioni rappresentano sempre uno scostamento fisso dall'UTC,
     mentre la maggior parte dei nomi completi implica una regola di gestione dell'ora estiva
     locale per cui si hanno due possibili scostamenti UTC.
    </para>

    <para>
     Bisogna stare attenti che lo stile POSIX di fuso orario può
     portare ad accettare passivamente input fasullo, dato che non c'è alcun controllo
     sulla logicità delle abbreviazioni di fuso. Per esempio, <literal>SET
     TIMEZONE TO FOOBAR0</literal> funzionerà, lasciando che il sistema usi effettivamente
     un'abbreviazione piuttosto strana per UTC.
     Un altra questione da tenere a mente è che nei nomi di fusi orari POSIX,
     vengono usati scostamenti positivi per locazioni ad <emphasis>ovest</emphasis> di Greenwich.
     In qualsiasi altro luogo, <productname>PostgreSQL</productname> segue la
     convenzione ISO-8601 che gli scostamenti positivi del fuso orario sono ad <emphasis>est</emphasis>
     di Greenwich.
    </para>

    <para>
     In ogni casi, i nomi di fusi orari sono riconosciuti insensibili alle maiuscole. (Ciò
     è diverso dalle versioni di <productname>PostgreSQL</productname> precedenti alla 8.2,
     dove c'era distinzione tra le maiuscole e le minuscole in alcuni contesti e non in altri).
    </para>

    <para>
     Nè i nomi completi nè le abbreviazioni sono incorporati nel server;
     essi vengono ottenuti dai file di configurazione memorizzati sotto
     <filename>.../share/timezone/</filename> e <filename>.../share/timezonesets/</filename>
     della directory di installazione
     (vedere <xref linkend="datetime-config-files" />).
    </para>

    <para>
     Il parametro di configurazione <xref linkend="guc-timezone" /> può
     essere impostato nel file <filename>postgresql.conf</filename>, o in qualcuno degli
     altri modi standard descritti nel <xref linkend="runtime-config" />.
     Ci sono anche altri modi speciali per impostarlo:

     <itemizedlist>
      <listitem>
       <para>
        Se <varname>timezone</varname> non è specificato nè in <filename>postgresql.conf</filename>
        e neanche come una opzione a linea di comando per il server,
        il server prova ad utilizzare il valore della variabile di ambiente
        <envar>TZ</envar> come fuso orario predefinito. Se <envar>TZ</envar>
        non è definito o non è uno dei nomi di fusi orari conosciuti da
        <productname>PostgreSQL</productname>, il server tenta di
        determinare il fuso orario predefinito del sistema verificando il
        comportamento della funzione della libreria C <literal>localtime()</literal>. Il fuso orario
        predefinito viene selezionato come la corrispondenza più vicina ai fusi orari
        conosciuti da <productname>PostgreSQL</productname>.
        (Queste regole vengono anche utilizzate per scegliere il valore predefinito di
        <xref linkend="guc-log-timezone" />, se non è stato specificato).
        
       </para>
      </listitem>

      <listitem>
       <para>
        Il comando <acronym>SQL</acronym> <command>SET TIME ZONE</command>
        imposta il fuso orario per la sessione. Questa è una versione alternativa
        di <command>SET TIMEZONE TO</command> con una sintassi più compatibile alle specifiche SQL.
       </para>
      </listitem>

      <listitem>
       <para>
        La variabile di ambiente <envar>PGTZ</envar>
        è utilizzata dai client <application>libpq</application>
        per inviare un comando <command>SET TIME ZONE</command> al server al
        momento della connessione.
        
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2 id="datatype-interval-input">
     <title>Input di Intervalli</title>

    <indexterm>
     <primary>intervallo</primary>
    </indexterm>

     <para>
       I valori <type>interval</type> possono essere scritti usando la seguente 
        sintassi:

<synopsis>
<optional>@</optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional><replaceable>quantity</replaceable> <replaceable>unit</replaceable>...</optional> <optional><replaceable>direction</replaceable></optional>
</synopsis>

      Dove: <replaceable>quantità</replaceable> è un numero (possibilmente con segno);
      <replaceable>unità</replaceable> è <literal>microsecondo</literal>,
      <literal>millisecondo</literal>, <literal>secondo</literal>,
      <literal>minuto</literal>, <literal>ora</literal>, <literal>giorno</literal>,
      <literal>settimana</literal>, <literal>mese</literal>, <literal>anno</literal>,
      <literal>decennio</literal>, <literal>secolo</literal>, <literal>millennio</literal>,
      o abbreviazioni o plurali di queste unità;
      <replaceable>direzione</replaceable> può essere <literal>ago</literal> o
      vuoto. Il simbolo at (<literal>@</literal>) è un opzionale. Le
      quantità delle diverse unità vengono implicitamente sommate con la
      appropriata registrazione del segno.
        <literal>ago</literal> nega tutti i campi.
        Questa sintassi è usata anche per l'output di intervalli, se
        <xref linkend="guc-intervalstyle"/> è impostata a 
        <literal>postgres_verbose</literal>.

    </para>

    <para>
      Le quantità di giorni, ore, minuti e secondi possono essere specificate senza una
      esplicita marcatura delle unità. Per esempio, <literal>'1 12:59:10'</literal> viene letto
      nella stessa modo di <literal>'1 day 12 hours 59 min 10 sec'</literal>. Inoltre,
        una combinazione di anni e mesi può essere specificata con un trattino;
        Per esempio,  <literal>'200-10'</literal> verrà letto come <literal>'200 anni 10 mesi'</literal>.         
        (Queste forme contratte sono infatti le sole permesse dallo standard <acronym>SQL</acronym>, 
        e sono usate per l'output quando <varname>IntervalStyle</varname> è impostato a <literal>sql_standard</literal>.) 
    </para>

    <para>
        Valori di intervallo possono anche essere scritti come intervalli di tempo ISO 8601,
<!-- /TODO designator ?? -->
        usando sia il <quote>formato con designator</quote> della sezione 4.4.3.2
        dello standard, o il <quote>formato alternativo</quote> della sezione 4.4.3.3. 
        Il formato con designator si esprime così:
<synopsis>
P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional></optional>
</synopsis>
        La stringa deve iniziare con una <literal>P</literal>, e può includere una
        <literal>T</literal> che introduce le unità orario-del-giorno. Le
        abbreviazioni di unità disponibili sono presenti in <xref
        linkend="datatype-interval-iso8601-units"/>. Le unità potrebbero essere 
        omesse, e potrebbero essere specificate in qualsiasi ordine, ma unità più piccole di
        un giorno devono apparire dopo <literal>T</literal>. In particolare, il significato di 
        <literal>M</literal> dipende dal fatto che sia prima o dopo la 
        <literal>T</literal>.
     </para>

     <table id="datatype-interval-iso8601-units">
      <title>Abbreviazioni delle unità di intervallo ISO 8601</title>
     <tgroup cols="2">
       <thead>
        <row>
         <entry>Abbreviatione</entry>
         <entry>Significato</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Y</entry>
         <entry>Anni</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>Mesi (nella parte data)</entry>
        </row>
        <row>
         <entry>W</entry>
         <entry>Settimane</entry>
        </row>
        <row>
         <entry>D</entry>
         <entry>Giorni</entry>
        </row>
        <row>
         <entry>H</entry>
         <entry>Ore</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>Minute (nella parte orario)</entry>
        </row>
        <row>
         <entry>S</entry>
         <entry>Secondi</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <para>
        Nei formati alternativi:
<synopsis>
P <optional> <replaceable>years</replaceable>-<replaceable>months</replaceable>-<replaceable>days</replaceable> </optional> <optional> T <replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:<replaceable>seconds</replaceable> </optional>
</synopsis>
        la stringa deve iniziare con <literal>P</literal>, e una
        <literal>T</literal> separa le parti di data e ora dell'intervallo.
        I valori sono dati come numeri simili alle date ISO 8601.
    </para>

    <para>
        Quando si scrive un intervallo costante con la specificazione di <replaceable>campi</replaceable>,
        o quando si assegna una stringa a una colonna di intervallo che è stata
        definita con una specificazione di <replaceable>campi</replaceable>, l'interpretazione di
        quantità senza segno dipende dai <replaceable>campi</replaceable>. Per
        esempio <literal>INTERVAL '1' YEAR</literal> è letto come 1 anno, dal momento che
         <literal>INTERVAL '1'</literal> significa 1 secondo. Inoltre, valori di campo
        <quote>alla destra</quote> del campo meno significativo permesso dalla specifica dei
         <replaceable>campi</replaceable> sono scartati automaticamente. Per 
        esempio, scrivere <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>
        elimina il secondo campo, ma non il campo "day" (giorno).
    </para>

    <para>
        In accordo allo standard <acronym>SQL</acronym> tutti i campi di un valore di intervallo
        devono avere lo stesso segno, così un segno meno in cima si applica a tutti i campi;
        per esempio, il segno negativo nell'intervallo letterale
        <literal>'-1 2:03:04'</literal> si applica sia alla parte dei giorni che alla parte ore/minuti/secondi.
        <productname>PostgreSQL</productname> permette ai campi di avere segno differente,
        e tradizionalmente tratta ogni campo nella rappresentazione testuale
        come avente segno indipendente, così la parte ore/minuti/secondi è 
        considerata positiva in questo esempio. Se <varname>IntervalStyle</varname> è 
        impostato a <literal>sql_standard</literal> allora il segno principale è considerato 
        da applicare a tutti i campi (ma solo se non appaiono segni aggiuntivi).
        Altrimentii viene usata l'interpretazione tradizionale <productname>PostgreSQL</productname>. 
        Per evitare ambiguità, è raccomandato aggiungere un segno esplicito
        ad ogni campo se qualcuno è negativo.
    </para>

    <para>
        Internamente i valori <type>interval</type> sono immagazzinati come mesi, giorni 
        e secondi. Viene fatto questo perchè il numero di giorni in un mese 
        varia, e un giorno puà avere 23 o 25 ore se è coinvolto un cambiamento di orario.
        I campi mesi e giorni sono interi
        mentre il campo secondi può avere frazioni. Dato che gli intervalli sono
        solitamente creati da stringhe costanti o sottrazioni di <type>timestamp</type>,
        questo metodo di immagazzinamento lavora bene in molti casi. Sono 
        disponibili le funzioni  <function>justify_days</function> e <function>justify_hours</function>
        per aggiustare giorni e ore che superano i loro normali 
        range.
    </para>

    <para>
        Nel formato di input prolisso, ed in alcuni campi dei formati di input
        più compatti, i valori dei campi possono avere parti frazionali; per esempio
        <literal>'1.5 week'</literal> o <literal>'01:02:03.45'</literal>. Questi valori di input sono
        convertiti nell'appropriato numero di mesi, giorni, e secondi
        per l'immagazzinamento. Quando questo risulterebbe in un numero frazionale
        di mesi o giorni, la frazione è aggiunta ai campi di ordine più basso
        usando i fattori di conversione 1 mese = 30  giorni e 1 giorno = 24 ore.
        Per esempio,  <literal>'1.5 month'</literal> diventa 1 mese e 15 giorni.
        Solo i secondi saranno sempre mostrati come frazionali in output.
    </para>

    <para>
     <xref linkend="datatype-interval-input-examples"/> mostra alcuni esempi di input validi di 
     <type>intervallo</type>.
    </para>

     <table id="datatype-interval-input-examples">
      <title>Input di intervalli</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Esempio</entry>
         <entry>Descrizione</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1-2</entry>
         <entry>formato SQL standard: 1 anno 2 mesi</entry>
        </row>
        <row>
         <entry>3 4:05:06</entry>
         <entry>formato SQL standard: 3 giorni 4 ore 5 minuti 6 secondi</entry>
        </row>
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <entry>Formato tradizionale di Postgres: 1 anno 2 mesi 3 giorni 4 ore 5 minuti 6 secondi</entry>
        </row>
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <entry>ISO 8601 <quote>formato con designators</quote>: stesso significato di sopra</entry>
        </row>
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <entry>ISO 8601 <quote>formato alternativo</quote>: stesso significato di sopra</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

   </sect2>

   <sect2 id="datatype-interval-output">
    <title>Output di intervalli</title>

    <indexterm>
     <primary>intervallo</primary>
     <secondary>formato di output</secondary>
     <seealso>formattazione</seealso>
    </indexterm>

    <para>
        Il formato di output del tipo intervallo puà essere impostato ad uno 
        dei quattro stili  <literal>sql_standard</literal>, <literal>postgres</literal>,
        <literal>postgres_verbose</literal>, o <literal>iso_8601</literal>,
        usando il comando <literal>SET intervalstyle</literal>.
        <literal>postgres</literal> è il formato di default.
        <xref linkend="interval-style-output-table"/> mostra esempi di 
        ogni stile di output.
    </para>

    <para>
        Lo stile <literal>sql_standard</literal> produce output conforme alle
        specifiche dello standard SQL per stringhe letterali di intervalli, se
        il valore di intervallo rispetta le restrizioni dello standard (sia solo anno-mese
        o solo giorno-ora, senza componenti miste negative e positive). Altrimenti l'output 
        sarà una stringa letterale anno-mese seguita da una stringa letterale giorno-ora,
        con segni espliciti aggiunti per rendere non ambigui intervalli con segni misti.
    </para>

    <para>
        L'output dello stile <literal>postgres</literal> corrisponde all'output dello stile 
        delle versioni precedenti la 8.4 di  <productname>PostgreSQL</productname>, quando il parametro
        <xref linkend="guc-datestyle"/> era impostato a <literal>ISO</literal>.
    </para>

    <para>
     L'output dello stile <literal>postgres_verbose</literal> corrisponde all'output dello stile
    delle versioni precedenti la 8.4 di <productname>PostgreSQL</productname>, quando il parametro
     <varname>DateStyle</varname> era impostato a non-<literal>ISO</literal>.
    </para>

    <para>
        L'output dello stile <literal>iso_8601</literal> corrisponde al <quote>formato 
        con designator</quote> descritto nella sezione 4.4.3.2 dello standard 
        ISO 8601.
    </para>

     <table id="interval-style-output-table">
       <title>Esempi di stile di output per gli intervalli</title>
       <tgroup cols="4">
        <thead>
         <row>
          <entry>Specifice di stile</entry>
          <entry>Intervallo anno-mese</entry>
          <entry>Intervallo giorno-ora</entry>
          <entry>Intervallo misto</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </sect2>

   <sect2 id="datatype-datetime-internals">
<!-- /TODO Internals ?? -->
    <title>Internals</title>

    <para>
     <productname>PostgreSQL</productname> utilizza le date Giuliane
     per tutti i calcoli data/ora. Esse hanno la buona proprietà di
     calcolare correttamente ogni data più recente del 4713 AC
     e lontana nel futuro, usando l'assunzione che la lunghezza dell'anno
     è di 365,2425 giorni.
    </para>

    <para>
     La convenzioni per le date precedenti al 19° secolo servono per una interessante lettura,
     ma non sono abbastanza consistenti da garantire la codificazione in un gestore di data/ora.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>Tipo booleano</title>

   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>tipo di dato</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <para>
    
    <productname>PostgreSQL</productname> fornisce il tipo
    standard <acronym>SQL</acronym> <type>boolean</type>.
    Il tipo <type>boolean</type> può avere solo uno dei due stati:
    <quote>true</quote> o <quote>false</quote>. Un terzo stato,
    <quote>unknown</quote>, è rappresentato dal valore
    <acronym>SQL</acronym> null.
   </para>

   <table id="datatype-boolean-table">
    <title>Tipo di dato boolean</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nome</entry>
       <entry>Dimensione</entry>
       <entry>Descrizione</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>boolean</type></entry>
       <entry>1 byte</entry>
       <entry>stato true o false</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Validi valori letterali per lo stato <quote>true</quote> sono:
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    Per lo stato <quote>false</quote>, possono essere usati i
    seguenti valori:
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    Spazi bianchi in testa ed in coda vengono ignorati. È preferibile
    (ed è conforme a <acronym>SQL</acronym>) usare le parole chiave
    <literal>TRUE</literal> e <literal>FALSE</literal>.
   </para>


   <para>
    L'<xref linkend="datatype-boolean-example" /> mostra che i valori
    <type>boolean</type> vengono scritti in output usando le lettere
    <literal>t</literal> ed <literal>f</literal>.
   </para>

   <example id="datatype-boolean-example">
    <title>Usando il tipo <type>boolean</type></title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>
  </sect1>









  <sect1 id="datatype-enum">
   <title>Tipi enumerati</title>

   <indexterm zone="datatype-enum">
    <primary>tipo di dato</primary>
    <secondary>enumerato (enum)</secondary>
   </indexterm>

   <indexterm zone="datatype-enum">
    <primary>tipi enumerati</primary>
   </indexterm>

   <para>
    I tipi enumerati (enum) sono tipi di dati che fanno parte
    di un predefinito insieme, statico, di valori con uno
    specifico ordine. Essi sono equivalenti ai tipi <type>enum</type>
    contenuti in un certo numero di linguaggi di programmazione. Un esempio di tipo enum
    potrebbe essere i giorni della settimana, o un insieme di valori di stato per
    una certa parte di dati.
   </para>

   <sect2>
    <title>Dichiarazione di tipi enumerati</title>

    <para>
     I tipi enum vengono creati usando il comando <xref
     linkend="sql-createtype" endterm="sql-createtype-title" />,
     per esempio:

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

     Una volta creato, il tipo enum può essere usato in definizioni di
     tabelle e funzioni come qualsiasi altro tipo:
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood 
------+--------------
 Moe  | happy
(1 row)
</programlisting>
    </para>
    </sect2>

    <sect2>
     <title>Ordinamento</title>

     <para>
    
      L'ordinamento dei valori in un tipo enum è l'ordine nel quale
      i valori sono stati elencati quando il tipo è stato dichiarato.
      Tutti gli operatori di confronto e le relative funzioni aggregate
      sono supportati per enum. Per esempio:
 
<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood 
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood 
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name 
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name  
-------
 Larry
(1 row)
</programlisting>
     </para>
   </sect2>

   <sect2>
    <title>Sicurezza del tipo</title>

    <para>
     I tipi enumerati sono tipi dati completamente separati e non possono
     essere confrontati con nessun altro.

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>

    <para>
     Se si vuole realmente fare qualcosa di simile a questo, è possibile scrivere
     un operatore personalizzato o aggiungere una conversione esplicita alla propria query:

<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks 
------+-----------
 Moe  |         4
(1 row)

</programlisting>
    </para>
   </sect2>

   <sect2>
    <title>Dettagli di implementazione</title>
    
    <para>
     Un valore enum occupa 4 byte su disco. La lunghezza del valore di una
     etichetta testuale di un enum è limitata dall'impostazione di <symbol>NAMEDATALEN</symbol>
     compilata in <productname>PostgreSQL</productname>; nelle compilazioni
     standard sarà al massimo 63 byte.
    </para>

    <para>
     Le etichette di enum sono sensibili alle maiuscole, per cui
     <type>'happy'</type> non è uguale a <type>'HAPPY'</type>.
     Inoltre, gli spazi nelle etichette sono significativi.
    </para>

    <para>
        Le traduzioni da valori interni di enum a etichette testuali sono
        tenute nel catalogo di sistema
        <link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>.
        Interroggare questo catalogo direttamente può essere utile.
    </para>

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
   <title>Tipi geometrici</title>

   <para>
    I tipi dati geometrici rappresentano oggetti spaziali a due
    dimensioni. La <xref linkend="datatype-geo-table" /> mostra i tipi
    geometrici disponibili in <productname>PostgreSQL</productname>. Il
    tipo fondamentale, il punto, forma la base per tutti gli
    altri tipi.
   </para>

    <table id="datatype-geo-table">
     <title>Tipi geometrici</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Dimensione</entry>
        <entry>Rappresentazione</entry>
        <entry>Descrizione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
        <entry>16 byte</entry>
        <entry>Punto nel piano</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <entry>32 byte</entry>
        <entry>Linea infinita (non implementata completamente)</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
        <entry>32 byte</entry>
        <entry>Segmento di linea finito</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
        <entry>32 byte</entry>
        <entry>Box rettangolare</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n byte</entry>
        <entry>Tracciato chiuso (simile a poligono)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n byte</entry>
        <entry>Percorso aperto</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n byte</entry>
        <entry>Poligono (simile a tracciato chiuso)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
        <entry>24 byte</entry>
        <entry>Cerchio</entry>
        <entry>&lt;(x,y),r&gt; (centro e raggio)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Un ricco insieme di funzioni e operatori è disponibile per effettuare diverse operazioni
    geometriche come scalare, traslare, ruotare e determinare
    intersezioni. Queste sono spiegate in <xref linkend="functions-geometry" />.
   </para>

   <sect2>
    <title>Punti</title>

    <indexterm>
     <primary>punto</primary>
    </indexterm>

    <para>
     I punti sono il blocco fondamentale per la costruzione dei tipi geometrici a due dimensioni.
     I valori del tipo <type>point</type> vengono specificati usando le seguenti sintassi:

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     dove <replaceable>x</replaceable> e <replaceable>y</replaceable> sono le rispettive coordinate
     espresse con numeri in virgola mobile.
    </para>

    <para>
        I punti sono espressi in output usando la prima sintassi
    </para>
   </sect2>

   <sect2>
    <title>Segmenti di linea</title>

    <indexterm>
     <primary>lseg</primary>
    </indexterm>

    <indexterm>
     <primary>segmenti di linea</primary>
    </indexterm>

    <para>
     I segmenti di linea (<type>lseg</type>) sono rappresentati da coppie di punti.
     I valori di tipo <type>lseg</type> vengono specificati usando le seguenti sintassi:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     dove
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     e
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sono i punti finali del segmento di linea.
    </para>

    <para>
        I segmenti di linea sono espressi in output usando la prima sintassi.
    </para>
   </sect2>

   <sect2>
    <title>Box</title>

    <indexterm>
     <primary>box (tipo di dato)</primary>
    </indexterm>

    <indexterm>
     <primary>rettangolo</primary>
    </indexterm>

    <para>
        I box sono espressi da coppie di punti che sono gli angoli 
        opposti del box.
        I valori del tipo <type>box</type> sono specificati usando una delle seguenti sintassi:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     dove
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     e
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
        sono qualsiasi coppia di angoli opposti del box.
    </para>

    <para>
        I box sono espressi in output usando la seconda sintassi.
    </para>

    <para>
        Qualsiasi coppia di angoli opposti può essere specificata in input, ma i valori
        sono riordinati se necessario per immagazzinare l'angolo superiore destro
        e inferiore sinistro, nell'ordine.
    </para>
   </sect2>

   <sect2>
    <title>Tracciati</title>

    <indexterm>
     <primary>tracciato (tipo di dato)</primary>
    </indexterm>

    <para>
     I tracciati sono rappresentati da una elenco di punti connessi. I tracciati possono essere
     <firstterm>aperti</firstterm>, dove il
     primo e l'ultimo punto della lista non vengono considerati connessi, o
     <firstterm>chiusi</firstterm>,
     dove il primo e l'ultimo punto vengono considerati connessi.
    </para>

    <para>
     I valori di tipo <type>path</type> vengono specificati usando le seguenti sintassi:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     
    dove i punti sono i punti finali dei segmenti di linee
     compresi nel tracciato. Le parentesi quadre (<literal>[]</literal>) indicano
     un percorso aperto, mentre le parentesi (<literal>()</literal>) indicano un
     percorso chiuso.
    </para>

    <para>
        I tracciati sono espressi in output usando in modo appropriato la prima o la seconda sintassi.
    </para>
   </sect2>

   <sect2>
    <title>Poligoni</title>

    <indexterm>
     <primary>poligono</primary>
    </indexterm>

    <para>
     I poligoni sono rappresentati da un elenco di punti (i vertici del
     poligono). I poligoni dovrebbero verosimilmente essere
     considerati equivalenti ai percorsi chiusi, ma vengono memorizzati differentemente 
     e hanno un loro insieme di routine di supporto.
    </para>

    <para>
     I valori di tipo <type>polygon</type> vengono specificati usando le seguenti sintassi:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     dove i punti sono i punti finali dei segmenti di linee
     comprese nei confini del poligono.
    </para>

    <para>
        I poligoni vengono prodotti usando la prima sintassi.
    </para>
   </sect2>

   <sect2>
    <title>Cerchi</title>

    <indexterm>
     <primary>cerchio</primary>
    </indexterm>

    <para>
     I cerchi vengono rappresentati da un punto centrale e un raggio.
     I valori di tipo <type>circle</type> vengono specificati usando le seguenti sintassi:


<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

     dove
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     è il centro e <replaceable>r</replaceable> è il raggio del cerchio.
    </para>

    <para>
        I cerchi sono espressi in output usando la prima sintassi.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>Tipi indirizzi di rete</title>

   <indexterm zone="datatype-net-types">
    <primary>rete</primary>
    <secondary>tipi di dato</secondary>
   </indexterm>

   <para>

    <productname>PostgreSQL</productname> offre tipi di dato per memorizzare indirizzi IPv4, IPv6
    e MAC, come mostrato nella <xref linkend="datatype-net-types-table" />. È
    preferibile usare questi tipi invece dei tipi in testo normale per memorizzare
    indirizzi di rete, in quanto
    questi tipi offrono il controllo degli errori in input e diversi operatori e
    funzioni specializzati (vedere dentro <xref linkend="functions-net" />).
   </para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>Tipi per gli indirizzi di rete</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Dimensione</entry>
        <entry>Descrizione</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <entry>7 o 19 byte</entry>
        <entry>reti IPv4 e IPv6</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <entry>7 o 19 byte</entry>
        <entry>host e reti IPv4 e IPv6</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 byte</entry>
        <entry>indirizzi MAC</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    
    Quando si ordinano tipi di dati <type>inet</type> o <type>cidr</type>,
    gli indirizzi IPv4 saranno sempre ordinati prima degli indirizzi IPv6, compresi gli
    indirizzi IPv4 incapsulati o mappati dentro indirizzi IPv6, come
    ::10.2.3.4 or ::ffff:10.4.3.2.
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet (tipo di dato)</primary>
    </indexterm>

    <para>
     Il tipo <type>inet</type> contiene un indirizzo host IPv4 o IPv6, e
     opzionalmente l'identità della subnet, tutto in un campo.
     L'identità della subnet è rappresentata dichiarando quanti bit dell'indirizzo
     dell'host rappresentano l'indirizzo di rete (il
     <quote>netmask</quote>). Se il netmask è 32 e l'indirizzo è IPv4,
     allora il valore non indica una subnet, ma solo un singolo host.
     In IPv6, la lunghezza dell'indirizzo è di 128 bit, per cui 128 bit specificano un
     unico indirizzo di host. Notare che se si vuole
     accettare solo reti, bisogna usare il tipo
     <type>cidr</type> piuttosto che il tipo <type>inet</type>.
    </para>

    <para>
      Il formato di input per questo tipo è
      <replaceable class="parameter">indirizzo/y</replaceable>
      dove
      <replaceable class="parameter">indirizzo</replaceable>
      è un indirizzo IPv4 o IPv6 e
      <replaceable class="parameter">y</replaceable>
      è il numero di bit nella netmask. Se la parte
      <replaceable class="parameter">/y</replaceable>
      non è indicata, allora il
      netmask è 32 per IPv4 e 128 per IPv6, per cui il valore rappresenta
      solo un singolo host. In visualizzazione, la parte
      <replaceable class="parameter">/y</replaceable>
      è soppressa se la netmask specifica un singolo host.
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</type></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
     Il tipo <type>cidr</type> contiene una specificazione di rete IPv4 o IPv6.
     I formati di input e output seguono le convenzioni di instradamento di domini
     internet senza classi (Classless Internet Domain Routing) CIDR.
     Il formato per specificare la rete è <replaceable
     class="parameter">indirizzo/y</replaceable> dove <replaceable
     class="parameter">indirizzo</replaceable> è la rete rappresentata come un
     indirizzo IPv4 o IPv6, e <replaceable class="parameter">y</replaceable> è il
     numero di bit nella netmask. Se <replaceable class="parameter">y</replaceable>
     è omesso, esso viene calcolato usando l'assunzione dal vecchio
     sistema di numerazione di rete basato sulla classe, eccetto che
     dovrà essere almeno abbastanza largo da comprendere tutti gli ottetti
     scritti nell'input. È un errore specificare un indirizzo di rete
     che ha bit settati alla destra della netmask specificata.
     
    </para>

    <para>
     <xref linkend="datatype-net-cidr-table"/> mostra qualche esempio.
    </para>

     <table id="datatype-net-cidr-table">
      <title>Esempi di input di<type>cidr</type></title>
      <tgroup cols="3">
       <thead> 
        <row> 
         <entry><type>cidr</type> Input</entry>
         <entry><type>cidr</type> Output</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <title><type>inet</type> contro <type>cidr</type></title>

    <para>
    La differenza essenziale tra i tipi dato <type>inet</type> e <type>cidr</type>
    è che <type>inet</type> accetta valori con bit non zero alla
    destra della netmask, mentre <type>cidr</type> invece no.
    </para>

      <tip>
        <para>
        Se non piace il formato di output dei valori per <type>inet</type> o
        <type>cidr</type>, provare le funzioni <function>host</function>,
        <function>text</function>, e <function>abbrev</function>.
        </para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm>
     <primary>macaddr (tipo di dato)</primary>
    </indexterm>

    <indexterm>
     <primary>indirizzo MAC</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
     
        Il tipo <type>macaddr</type> memorizza indirizzi MAC, cioè,
        indirizzi hardware di schede Ethernet (anche se gli indirizzi MAC vengono
        usati altrettanto bene per altri scopi). L'input viene accettato in diversi
        formati, quali:

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist>

     questi esempi specificano tutti lo stesso
     indirizzo. Sia le maiuscole che le minuscole sono accettate per le cifre da
     <literal>a</literal> a <literal>f</literal>. L'output è sempre nella prima
     delle forme mostrate.
    </para>

    <para>
        Lo standard IEEE Std 802-2001 specifica la senda forma mostrata (con i trattini)
        come la forma canonica per indirizzi MAC, e specifica la prima
        forma (con i due punti) come la notazione "bit-reversed", così 
        08-00-2b-01-02-03 = 01:00:4D:08:04:0C. Questa convenzione è largamente 
        ignorata oggigiorno, ed è rilevante solo per protocolli di rete 
        obsoleti (come il Token Ring). PostgreSQL non prevede il "bit-reverse",
        e tutti i formati accettati usano l'ordine canonico LSB.
    </para>

    <para>
        I rimanento quattro formati di input non sono parte di nessuno standard.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <title>Tipi stringa di bit</title>

   <indexterm zone="datatype-bit">
    <primary>bit string</primary>
    <secondary>data type</secondary>
   </indexterm>

   <para>
    Le stringhe di bit sono stringhe di 1 e 0. Esse possono essere usate per
    memorizzare o visualizzare maschere di bit. Ci sono due tipi di bit SQL:
    <type>bit(<replaceable>n</replaceable>)</type> e <type>bit
    varying(<replaceable>n</replaceable>)</type>, dove
    <replaceable>n</replaceable> è un intero positivo.
   </para>

   <para>
    I dati di tipo <type>bit</type> devono rispettare esattamente la lunghezza
    <replaceable>n</replaceable>; È un errore tentare di memorizzare
    stringhe di bit più corte o più lunghe. Il dato <type>bit varying</type>
    è di lunghezza variabile fino alla lunghezza massima
    <replaceable>n</replaceable>; stringhe più lunghe saranno rifiutate.
    Scrivere <type>bit</type> senza una lunghezza è equivalente a
    <literal>bit(1)</literal>, mentre <type>bit varying</type> senza una specificazione
    di lunghezza significa lunghezza illimitata.
   </para>

   <note>
    <para>
     
    Se viene esplicitamente convertito un valore stringa di bit a
     <type>bit(<replaceable>n</replaceable>)</type>, esso sarà troncato o
     riempito con zeri a destra per essere esattamente di <replaceable>n</replaceable> bit,
     senza generare un errore. In maniera simile, se viene
     esplicitamente convertito un valore stringa di bit a 
     <type>bit varying(<replaceable>n</replaceable>)</type>, Esso sarà troncato
     sulla destra se è maggiore di <replaceable>n</replaceable> bit.
    </para>
   </note>

   <para>
    
    Vedere dentro <xref
    linkend="sql-syntax-bit-strings" /> per informazioni circa la sintassi
    delle costanti stringa di bit. Gli operatori logici a livello di bit e le funzioni
    di manipolazione stringhe sono disponibili; Vedere <xref
    linkend="functions-bitstring" />.
   </para>

   <example>
    <title>Utilizzo dei tipi stringa di bit</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

   <para>
    Un valore stringa di bit richiede 1 byte per ogni gruppo di 8 bit, più
    5 o 8 byte in testa in dipendenza della lunghezza della stringa
    (ma valori lunghi possono essere compressi o spostati fuori della riga, come spiegato
    in <xref linkend="datatype-character" /> per la stringhe di caratteri).
   </para>
  </sect1>

  <sect1 id="datatype-textsearch">
   <title>Tipi ricerca testo</title>

   <indexterm zone="datatype-textsearch">
    <primary>ricerca completa testo</primary>
    <secondary>tipo di dato</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <primary>ricerca testo</primary>
    <secondary>tipi di dato</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> provides two data types that
    are designed to support full text search, which is the activity of
    searching through a collection of natural-language <firstterm>documents</firstterm>
    to locate those that best match a <firstterm>query</firstterm>.
    The <type>tsvector</type> type represents a document in a form optimized
    for text search; the <type>tsquery</type> type similarly represents
    a text query.
    <xref linkend="textsearch"/> provides a detailed explanation of this
    facility, and <xref linkend="functions-textsearch"/> summarizes the
    related functions and operators.
   
     <productname>PostgreSQL</productname> fornisce due tipi di dato che
    sono destinati a supportare ricerche complete di testo, che è l'attività di
    ricerca tramite una raccolta  di <firstterm>documenti</firstterm> in linguaggio-naturale
    per individuare quello che meglio corrisponde ad una <firstterm>query</firstterm>.
    Il tipo <type>tsvector</type> rappresenta  un documento in una forma adatta
    per la ricerca di testo, mentre il tipo <type>tsquery</type> similmente rappresenta
    una query.
    Il <xref linkend="textsearch" /> fornisce una spiegazione dettagliata di queste
    strutture, e <xref linkend="functions-textsearch" /> riassume le 
    funzioni e gli operatori connessi.
   </para>

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

    <indexterm>
     <primary>tsvector (tipo di dato)</primary>
    </indexterm>

    <para>
     A <type>tsvector</type> value is a sorted list of distinct
     <firstterm>lexemes</firstterm>, which are words that have been
     <firstterm>normalized</firstterm> to merge different variants of the same word
     (see <xref linkend="textsearch"/> for details).  Sorting and
     duplicate-elimination are done automatically during input, as shown in
     this example:
     Un valore <type>tsvector</type> è una lista ordinata di distinti
     <firstterm>lessemi</firstterm>, che sono parole
     <firstterm>normalizzate</firstterm> per raggruppare diverse varianti somiglianti della stessa
     parola (vedere il <xref linkend="textsearch" /> per dettagli). L'ordinamento e
     l'eliminazione dei duplicati sono fatti automaticamente durante l'input, come mostrato
     in questo esempio:

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

        Per rappresentare
        lessemi contenenti spazi bianchi o segni di punteggiatura, usare gli apici:

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector                  
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

        (In questo esempio e nel prossimo usiamo il dollaro per evitare
        la confusione di dover raddoppiare gli apici all'interno dei letterali.)
        Gli apici  e le barre inverse interne devono essere raddoppiate:

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector                    
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

     Optionally, integer <firstterm>positions</firstterm>
     can be attached to lexemes:
     Opzionalmente, <firstterm>posizioni</firstterm> intere
     possono essere aggiunte a uno o a tutti i lessemi:

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

     Una posizione indica normalmente la posizione della parola sorgente nel
     documento. L'informazione posizionale può essere usata per
     una <firstterm>classificazione di prossimità</firstterm>. I valori di posizione possono
     estendersi da 1 a 16383; numeri più grandi vengono automaticamente impostati a 16383.
     Posizioni duplicate per lo stesso lessema vengono scartate.
    </para>

    <para>
     Lexemes that have positions can further be labeled with a
     <firstterm>weight</firstterm>, which can be <literal>A</literal>,
     <literal>B</literal>, <literal>C</literal>, or <literal>D</literal>.
     <literal>D</literal> is the default and hence is not shown on output:
     
        I lessemi che hanno posizioni possono ulteriormente essere etichettati con un
     <firstterm>peso</firstterm>, che può essere <literal>A</literal>,
     <literal>B</literal>, <literal>C</literal>, o <literal>D</literal>.
     <literal>D</literal> è il predefinito e quindi non viene visualizzato in uscita:


<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector          
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

     I pesi vengono normalmente usati per riflettere la struttura del documento, per esempio
     per marcare le parole del titolo differentemente dalle parole del corpo. Le funzioni di
     classificazione nella ricerca di testo possono assegnare diverse priorità ai diversi
     marcatori di peso.
    </para>

    <para>
     È importante capire che il tipo
     <type>tsvector</type> non effettua nessuna normalizzazione;
     esso assume che le parole fornite siano adeguatamente normalizzate
     per l'applicazione. Per esempio,

<programlisting>
select 'The Fat Rats'::tsvector;
      tsvector      
--------------------
 'Fat' 'Rats' 'The'
</programlisting>

     Per la maggior parte delle applicazioni di ricerca-testo-inglese le parole
     viste sopra sarebbero considerate non-normalizzate, ma <type>tsvector</type>
     non se ne cura. I documenti di testo grezzo devono usualmente essere passati attraverso
     <function>to_tsvector</function> per normalizzare le parole appropriatamente
     per la ricerca:

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');         
   to_tsvector   
-----------------
 'fat':2 'rat':3
</programlisting>

     Per ulteriori dettagli, vedere nel <xref linkend="textsearch" />.
    </para>

   </sect2>

   <sect2 id="datatype-tsquery">
    <title><type>tsquery</type></title>

    <indexterm>
     <primary>tsquery (tipo di dato)</primary>
    </indexterm>

    <para>
     Un valore <type>tsquery</type> memorizza lessemi che devono essere
     ricercati, e li combina utilizzando gli operatori booleani
     <literal>&amp;</literal> (AND), <literal>|</literal> (OR), e
     <literal>!</literal> (NOT). Possono essere utilizzate parentesi per far rispettare
     il raggruppamento degli operatori:


<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery    
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>

<!-- /TODO da rivedere -->
     In assenza di parentesi, <literal>!</literal> (NOT) lega il più strettamente
     possibile e <literal>&amp;</literal> (AND) lega più strettamente di
     <literal>|</literal> (OR).
    </para>

    <para>
     Opzionalmente, i lessemi in un <type>tsquery</type> possono essere identificati con
     una o più lettere di peso, che li costringono ad abbinarsi solo con 
     lessemi <type>tsvector</type> di peso corrispondente:

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>

    <para>
        Inoltre, i lessemi in un <type>tsquery</type> possono essere etichettati con <literal>*</literal>,
        per specificarei il prefisso di corrispondenza: 
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery  
-----------
 'super':*
</programlisting>
        Questa query troverà ogni parola in un <type>tsvector</type> che comincia  
        con <quote>super</quote>.
    </para>

    <para>
     
    Le regole per quotare i lessemi sono le stesse descritte precedentemente per
     i lessemi in <type>tsvector</type>; E, come con <type>tsvector</type>,
     ogni normalizzazione richiesta delle parole deve essere fatta prima
     della conversione  al tipo <type>tsquery</type>. La funzione <function>to_tsquery</function>
     è conveniente per realizzare tale normalizzazione: 

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery    
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>

   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
   <title>Tipo <acronym>UUID</acronym></title>

   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>

   <para>
    
    Il tipo dato <type>uuid</type> memorizza Universally Unique Identifiers
    (UUID) come definito da RFC 4122, ISO/IEC 9834-8:2005, e relativi standard.
    (Alcuni sistemi si riferiscono a questo tipo dato comei identificatore unico globale, o
    GUID <indexterm><primary>GUID</primary></indexterm>). Questo 
    identificatore è una quantità di 128 bit generata da un algoritmo scelto
    per rendere molto improbabile che lo stesso identificatore verrà generato da
    qualcun'altro nell'universo conosciuto usando lo stesso algoritmo. Per cui,
    per i sistemi distribuiti, questi identificatori forniscono una garanzia di
    unicità migliore di quella ottenuta utilizzando i generatori di sequenza, che
    sono unici solo in un singolo database.
   </para>

   <para>
    Un UUID è scritto come una sequenza di cifre esadecimali in minuscolo,
    in diversi gruppi separati da trattini, specificatamente un gruppo di 8
    cifre seguito da tre gruppi di 4 cifre seguiti da un gruppo di 12 cifre,
    per un totale di 32 cifre che corrispondono a 128 bit. Un
    esempio di un UUID in questa forma standard è il seguente:
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
    <productname>PostgreSQL</productname> accetta anche le seguenti
    forme alternative in input:
    utilizzo di cifre maiuscole, il formato standard racchiuso tra
    parentesi, l'omissione di alcuni, o tutti, i trattini, e l'aggiunta 
    di trattini dopo qualsiasi gruppo di cifre.
    Esempi sono:
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
        L'output è sempre nella forma standard.
   </para>

   <para>
    <productname>PostgreSQL</productname> fornisce, per gli UUID, funzioni di
    memorizzazione e di confronto, ma il core del database non comprende nessuna
    funzione per la generazione di UUID, perchè nessun singolo 
    algoritmo è valido per ogni applicazione. Il modulo contrib 
    <filename>contrib/uuid-ossp</filename> fornisce funzioni che implementano 
    alcuni algoritmi standard.
    In alternativa, gli UUID possono essere generati da applicazioni client o
    altre librerie chiamate tramite una funzione lato server.
   </para>
  </sect1>

  <sect1 id="datatype-xml">
   <title>Tipo <acronym>XML</acronym></title>

   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>

   <para>
   
     Il tipo di dato <type>xml</type> può essere usato per memorizzare dati XML.
    Il suo vantaggio, rispetto alla memorizzazazione di dati XML in un campo <type>text</type>,
    è che esso controlla che i valori in input abbiano una buona
    formattazione, e ci sono funzioni di supporto per realizzare con esso operazioni
    di tipo sicuro; Vedere <xref linkend="functions-xml" />.  L'utilizzo di questo
    tipo di dato richiede che l'installazione sia stata compilata con <command>configure 
    --with-libxml</command>.
   </para>

   <para>

<!-- /TODO da rivedere -->
    Il tipo <type>xml</type> può memorizzare <quote>documenti</quote>
    ben formattati, come definito dallo standard XML, come pure una parte di frammenti di
    <quote>contenuto</quote>, come sono definiti dalla
    <literal>XMLDecl? content</literal> nello standard XML.
    Approssimativamente, questo significa che i frammenti di contenuto possono avere
    più di un elemento di alto livello o nodi di carattere. L'espressione
    <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>
    può essere usata per valutare se un particolare valore di <type>xml</type>
    è un documento completo o solo una parte del contenuto.
   </para>

   <sect2>
    <title>Creare valori XML</title>
   <para>
    Per produrre un valore di tipo <type>xml</type> da dati carattere,
    utilizzare la funzione
    <function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    Esempi:
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    While this is the only way to convert character strings into XML
    values according to the SQL standard, the PostgreSQL-specific
    syntaxes:
    Mentre questo è  il solo modo per convertire stringhe di caratteri in
    valori XML secondo la standard SQL, anche le specifiche sintassi di
    PostgreSQL:
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    possono essere usate.
   </para>

   <para>
    
    Il tipo <type>xml</type> non valida i valori in input secondo una dichiarazione di tipo di documento 
    (DTD),<indexterm><primary>DTD</primary></indexterm>, anche quando il valore di input specifica un DTD.
    Attualmente non c'è un supporto incluso per la validazione
    in base ad altri linguaggi tipo XML Schema.
        
   </para>

   <para>
    L'operazione inversa, la produzione di un valore di tipo stringa di caratteri
    da un <type>xml</type>, utilizza la funzione
    <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
    
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>

    Il parametro <replaceable>type</replaceable> può essere del tipo
    <type>character</type>, <type>character varying</type>, o
    <type>text</type> (o un nome alias per essi). Inoltre, secondo
    lo standard SQL, questo è il solo modo per effettuare la conversione
    tra un tipo <type>xml</type> e i tipi carattere, ma PostgreSQL consente anche
    di effettuare semplicemente una conversione al valore.
   </para>

   <para>
    When a character string value is cast to or from type
    <type>xml</type> without going through <type>XMLPARSE</type> or
    <type>XMLSERIALIZE</type>, respectively, the choice of
    <literal>DOCUMENT</literal> versus <literal>CONTENT</literal> is
    determined by the <quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>
    session configuration parameter, which can be set using the
    standard command:
    
    Quando un valore stringa di caratteri viene convertito ad, o da, un tipo <type>xml</type>
    senza passare da <type>XMLPARSE</type> o <type>XMLSERIALIZE</type>,
    rispettivamente, la scelta di <literal>DOCUMENT</literal> rispetto a
    <literal>CONTENT</literal> è determinata dall'<quote>opzione XML</quote>
    del parametro di configurazione di sessione  
    <indexterm><primary>XML option</primary></indexterm>,
    che può essere impostato usando il
    comando standard
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    o la sintassi più vicina a PostgreSQL:
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
    Il valore predefinito è <literal>CONTENT</literal>, per cui tutte le forme di
    dati XML sono consentite.
   </para>

   <note>
    <para>
        Con il valore di default dell'opzione XML, non è possibile convertire direttamente
        stringhe di caratteri al tipo <type>xml</type> se contengono una
        dichiarazione di tipo di documento, perchè la definizione di frammenti di contenuto XML
        non le accetta. Se si ha bisogno di farlo, usare <literal>XMLPARSE</literal>
        o cambiare l'opzione XML.
    </para>
   </note>

   </sect2>

   <sect2>
    <title>Gestire la codifica</title>
   <para>
    
    Bisogna avere molta cura quando ci si occupa di codifiche multiple di
    caratteri nel client, nel server e nei dati XML passati tramite essi.
    Quando si utilizza il modo testo per passare query al server e i risultati
    delle query al client (che è il modo normale), PostgreSQL
    converte tutti i dati carattere, passati tra il client ed il
    server e viceversa, alla codifica di caratteri della rispettiva
    fine; vedere <xref linkend="multibyte" />. Questo comprende
    rappresentazioni stringa di valori XML, come negli esempi precedenti.
    Questo normalmente significherebbe che dichiarazioni di codifica contenute 
    dentro dati XML potrebbero diventare non valide quando i dati carattere vengono
    convertiti ad altre codifiche mentre viaggiano tra il client ed il server,
    mentre la dichiarazione di codifica incorporata non è stata cambiata. Per
    far fronte a questo tipo di comportamento, una dichiarazione di codifica
    contenuta in una stringa di caratteri in input ad un tipo <type>xml</type> viene 
    <emphasis>ignorata</emphasis>, e si assume che il suo contenuto 
    sia nell'attuale codifica del server. Di conseguenza, per una corretta
    elaborazione, tali stringhe di caratteri di dati XML dovranno essere mandate
    dal client nella codifica corrente del client. È
    responsabilità del client, o di convertire il documento alla
    codifica corrente del server prima di inviarlo al server, oppure
    modificare opportunamente la codifica del client. In output, i valori di
    tipo <type>xml</type> non dovranno avere una dichiarazione di codifica, e
    i client dovranno assumere che il dato sia nella corrente codifica del
    client.
   </para>


   <para>
    Quando si utilizza il modo binario per passare parametri delle query al server
    e risultati delle query indietro al client, nessuna conversione viene effettuata
    per il set di caratteri, per cui la situazione è differente. In questo caso,
    una dichiarazione di codifica nei dati XML sarà osservata, ed in sua
    assenza, il dato verrà assunto essere in UTF-8 (come richiesto dallo
    standard XML; notare che PostgreSQL non supporta UTF-16 per
    niente). In output, i dati dovranno avere una dichiarazione di codifica
    che specifica la codifica del client, a meno che la codifica del client non sia
    UTF-8, in quel caso essa può essere omessa.
   </para>

   <para>
    
    Come è logico, l'elaborazione di dati XML con PostgreSQL sarà meno
    soggetta a errori e più efficiente se la codifica dei dati XML, la codifica
    del client e la codifica del server sono le stesse. Poichè i dati XML sono
    internamente elaborati in UTF-8, i calcoli saranno più efficienti se anche la
    codifica del server è UTF-8.
   </para>

   <caution>
    <para>
        Qualche funzione relativa all'XML potrebbe non funzionare su dati non ASCII
        quando la codifica del server non è UTF-8. Questo è un problema noto per
        <function>xpath()</function> in particolare.
    </para>
   </caution>
   </sect2>

   <sect2>
   <title>Accedere ai valori XML</title>

   <para>
    
    Il tipo dato <type>xml</type> è insolito in quanto non fornisce
    nessun operatore di confronto. Questo perchè non c'è un
    algoritmo di comparazione ben definito ed universalmente utilizzato per i
    dati XML. Una conseguenza di questo è che non possono essere richiamate righe
    confrontando una colonna <type>xml</type> con un valore di ricerca. I valori XML
    dovranno quindi essere normalmente accompagnati da un campo chiave separato
    tipo un ID. Una soluzione alternativa per confrontare valori XML
    è di convertirli prima in stringhe di caratteri, ma si noti che
    i confronti di stringhe di caratteri hanno poco a che fare con un metodo
    di confronto XML utile.
   </para>

   <para>
    Poichè non ci sono operatori di confronto per il tipo dato
    <type>xml</type>, non è possibile creare un indice direttamente
    su una colonna di questo tipo. Se si desidera una ricerca veloce nei
    dati XML, una possibile soluzione può essere la conversione ad
    un tipo stringa di caratteri e indicizzarla, o indicizzare un'espressione XPath.
    La query effettiva dovrebbe naturalmente essere adeguata per
    la ricerca di espressioni indicizzate.
    
   </para>

   <para>
    La funzionalità ricerca di testo in PostgreSQL può anche essere usata
    per velocizzare ricerche di documenti completi di dati XML. Il necessario supporto
    di pre-elaborazione, però, non è ancora disponibile nella distribuzione
    PostgreSQL.
   </para>
   </sect2>
  </sect1>

  &array;

  &rowtypes;


  <sect1 id="datatype-oid">
   <title>Tipi identificatori di oggetto</title>

   <indexterm zone="datatype-oid">
    <primary>identificatore di oggetto</primary>
    <secondary>tipo dato</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <para>
    
    Gli identificatori di oggetto (OIDs) sono usati internamente da
    <productname>PostgreSQL</productname> come chiavi primarie per diverse
    tabelle di sistema.  Gli OID non vengono aggiunti alle tabelle create
    dagli utenti, a meno che sia stato specificato <literal>WITH OIDS</literal>
    quando è stata creata la tabella, o sia stata abilitata la variabile
    di configurazione <xref linkend="guc-default-with-oids" />. I tipi <type>oid</type> rappresentano
    un identificatore di oggetti.  Ci sono anche diversi alias per i tipi
    <type>oid</type>: <type>regproc</type>, <type>regprocedure</type>,
    <type>regoper</type>, <type>regoperator</type>, <type>regclass</type>,
    <type>regtype</type>, <type>regconfig</type>, e <type>regdictionary</type>.
    La <xref linkend="datatype-oid-table" /> ne mostra una veduta d'insieme.
   </para>

   <para>
    
    Il tipo <type>oid</type> attualmente è implementato come un intero
    di quattro byte senza segno. Per cui, non è abbastanza grande da fornire
    l'unicità nell'intero database in database di grandi dimensioni, o anche in grandi
    tabelle individuali. Per cui, usare una colonna OID come chiave primaria, in una
    tabella creata dall'utente, è sconsigliato. Gli OID sono usati al meglio solo per
    riferimenti alle tabelle di sistema.
   </para>

   <para>
    
    Il tipo <type>oid</type> stesso ha poche altre operazioni oltre al confronto.
    Esso può, tuttavia, essere convertito a intero e quindi manipolato usando
    gli operatori standard degli interi. (Attenzione alla possibile confusione nella conversione
    da con segno a senza segno se si esegue questa operazione).
   </para>

   <para>
    I tipi alias OID non hanno loro proprie operazioni tranne che per
    routine specializzate di input e output. Queste routine sono in grado
    di accettare e visualizzare nomi simbolici per oggetti di sistema, oltre che
    il valore numerico grezzo utilizzato dal tipo <type>oid</type>. I tipi alias
    consentono la ricerca semplificata di valori OID per gli oggetti. Per esempio,
    per esaminare il <structname>pg_attribute</structname> delle righe relative a una tabella
    <literal>mytable</literal>, è possibile scrivere:
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    piuttosto che:
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
    While that doesn't look all that bad by itself, it's still oversimplified.
    A far more complicated sub-select would be needed to
    select the right OID if there are multiple tables named
    <literal>mytable</literal> in different schemas.
    The <type>regclass</type> input converter handles the table lookup according
    to the schema path setting, and so it does the <quote>right thing</quote>
    automatically.  Similarly, casting a table's OID to
    <type>regclass</type> is handy for symbolic display of a numeric OID.

<!-- /TODO !!!! -->
    Mentre non sembra vedere il peggio di se stesso, è comunque ultra semplificato.
    Una vasta e complicata sub-select sarebbe necessaria per
    selezionare il giusto OID se ci sono più tabelle chiamate
    <literal>mytable</literal> in differenti schemi.
    Il convertitore in input a <type>regclass</type> gestisce la ricerca di tabelle secondo
    l'impostazione del percorso di schema, e così  fa la  <quote>cosa giusta</quote>
    automaticamente. Similmente, convertire un OID di tabella a
    <type>regclass</type> è utile per la visualizzazione simbolica di un UID numerico.
   </para>

    <table id="datatype-oid-table">
     <title>Tipi identificatori di oggetto</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Riferimenti</entry>
        <entry>Descrizione</entry>
        <entry>Esempio di valori</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</type></entry>
        <entry>qualsiasi</entry>
        <entry>identificatori numerico di oggetto</entry>
        <entry><literal>564182</literal></entry>
       </row>

       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>nome di funzione</entry>
        <entry><literal>sum</literal></entry>
       </row>
       
    <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>tipi funzione con argomento</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>

       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>nome operatore</entry>
        <entry><literal>+</literal></entry>
       </row>

       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>tipi operatore con argomento</entry>
        <entry><literal>*(integer,integer)</literal> or <literal>-(NONE,integer)</literal></entry>
       </row>

       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>nome relazione</entry>
        <entry><literal>pg_type</literal></entry>
       </row>

       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>nome tipo dato</entry>
        <entry><literal>integer</literal></entry>
       </row>

       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>configurazione ricerca testo</entry>
        <entry><literal>english</literal></entry>
       </row>

       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>dizionario ricerca testo</entry>
        <entry><literal>simple</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Tutti i tipi alias di OID accettano nomi qualificati da schema, e visualizzano
    in output nomi qualificati da schema se l'oggetto non viene
    trovato nel percorso di ricerca corrente senza essere qualificato.
    I tipi alias <type>regproc</type> e <type>regoper</type> accettano solo nomi in
    input che sono unique (non sovraccaricati), per cui essi sono di uso
    limitato; per la maggior parte degli usi sono più adatti
    <type>regprocedure</type> o <type>regoperator</type>. Per <type>regoperator</type>,
    gli operatori costituiti da un solo elemento (unari) sono identificati scrivendo
    <literal>NONE</literal> per l'operando non usato.
    
   </para>

   <para>
    Una proprietà supplementare dei tipi alias di OID è la creazione di 
    dipendenze. Se una
    costante di uno di questi tipi compare in una espressione memorizzata
    (tipo una espressione o vista di default di colonna), essi creano una dipendenza
    dall'oggetto referenziato. Per esempio, se una colonna ha una espressione
    di default <literal>nextval('my_seq'::regclass)</literal>,
    <productname>PostgreSQL</productname>
    capisce che l'espressione predefinita dipende dalla sequenza
    <literal>my_seq</literal>; Il sistema non lascerà che la sequenza venga eliminata senza che
    sia rimossa prima l'espressione di default.
   </para>

   <para>
    Un altro tipo di identificatore usato dal sistema è <type>xid</type>, o identificatore
    di transazione (abbreviato <abbrev>xact</abbrev>). Questo è il tipo di dato delle colonne di sistema
    <structfield>xmin</structfield> e <structfield>xmax</structfield>. Gli identificatori di transazione sono quantità a 32 bit.
   </para>

   <para>
    Un terzo tipo di identificatore usato dal sistema è <type>cid</type>, o
    identificatore di comando. Questo è il tipo dato delle colonne di sistema
    <structfield>cmin</structfield> e <structfield>cmax</structfield>.Gli identificatori di comando sono anch'essi a 32 bit.
   </para>

   <para>
    
    Infine, un tipo di identificatore usato dal sistema è <type>tid</type>, o identificatore
    di tupla (identificatore di riga). Questo è il tipo di dato per la colonna di sistema
    <structfield>ctid</structfield>. Un ID di tupla è una coppia
    (numero blocco, indice di tupla nel blocco) che identifica la locazione
    fisica della riga dentro la tabella.
   </para>

   <para>
    (Le colonne di sistema vengono ulteriormente spiegate in <xref
    linkend="ddl-system-columns" />).
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <title>Pseudo-tipi</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>


   <para>
    I tipi sistema di <productname>PostgreSQL</productname> contengono un
    numero di elementi per usi speciali che sono collettivamente chiamati
    <firstterm>pseudo-tipi</firstterm>. Un pseudo-tipo non può essere usato come
    un tipo di dato di colonna, ma può essere usato per dichiarare un'argomento
    di funzione o il tipo di un risultato. Ugnuno degli pseudo-tipi disponibili è
    utile in situazioni dove il comportamento di una funzione non
    corrisponde semplicemente a prendere o restituire un valore di uno specifico 
    tipo di dato <acronym>SQL</acronym>. La <xref
    linkend="datatype-pseudotypes-table" /> elenca gli 
    pseudo-tipi esistenti.
   </para>

    <table id="datatype-pseudotypes-table">
     <title>Pseudo-tipi</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Nome</entry>
        <entry>Descrizione</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</type></entry>
        <entry>Indica che una funzione accetta ogni input di qualsiasi tipo dato.</entry>
       </row>

       <row>
        <entry><type>anyarray</type></entry>
        <entry>Indica che una funzione accetta ogni tipo dato array
        (vedere <xref linkend="extend-types-polymorphic" />).</entry>
       </row>

       <row>
        <entry><type>anyelement</type></entry>
        <entry>Indica che una funzione accetta ogni tipo dato
        (vedere <xref linkend="extend-types-polymorphic" />).</entry>
       </row>

       <row>
        <entry><type>anyenum</type></entry> 
        <entry>Indica che una funzione accetta ogni tipo dato enum
        (vedere <xref linkend="extend-types-polymorphic" /> e
        <xref linkend="datatype-enum" />).</entry>
       </row>

       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Indica che una funzione accetta ogni tipo dato non-array
        (vedere <xref linkend="extend-types-polymorphic" />).</entry>
       </row>

       <row>
        <entry><type>cstring</type></entry>
        <entry>Indica che una funzione accetta o restituisce una stringa C terminata con null.</entry>
       </row>

       <row>
        <entry><type>internal</type></entry>
        <entry>Indica che una funzione accetta o restituisce un tipo dato interno
        al server.</entry>
       </row>

       <row>
        <entry><type>language_handler</type></entry>
        <entry>Viene dichiarato un gestore di chiamata al linguaggio procedurale per restituire un <type>language_handler</type>.</entry>
       </row>

       <row>
        <entry><type>record</type></entry>
        <entry>Identifica una funzione che restituisce un tipo riga non specificato.</entry>
       </row>

       <row>
        <entry><type>trigger</type></entry>
        <entry>Viene dichiarata una funzione trigger per restituire un <type>trigger.</type></entry>
       </row>

       <row>
        <entry><type>void</type></entry>
        <entry>Indica che una funzione non restituisce nessun valore.</entry>
       </row>

       <row>
        <entry><type>opaque</type></entry>
        <entry>Un nome tipo obsoleto che serviva in precedenza per tutti gli usi di cui sopra.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>


   <para>
    
    Funzioni codificate in C (sia incorporate che caricate dinamicamente) possono essere
    dichiarate per accettare o restituire ognuno di questi specifici pseudo tipi di dati. Spetta
    all'autore della funzione il compito di garantire che la funzione si comporti in sicurezza
    quando viene usato un pseudo-tipo come tipo di argomento.
   </para>

   <para>
    Funzioni codificate in linguaggi procedurali possono usare pseudo-tipi solo come
    consentito dal loro linguaggio di implementazione. Al momento tutti i linguaggi
    procedurali proibiscono l'uso di un pseudo-tipo come tipo di argomento, e consentono
    solo <type>void</type> e <type>record</type> come tipo di risultato (più
    <type>trigger</type> quando la funzione viene utilizzata come un trigger). Alcuni supportano
    anche funzioni polimorfiche utilizzando i tipi <type>anyarray</type>,
    <type>anyelement</type>, <type>anyenum</type>, e <type>anynonarray</type>.
   </para>

   <para>
    Lo pseudo-tipo <type>internal</type> è usato per dichiarare funzioni
    che sono intese solo per essere chiamate internamente al sistema di
    database, e non da chiamate dirette in una query <acronym>SQL</acronym>.
    Se una funzione ha almeno un argomento tipo <type>internal</type>
    allora non può essere chiamata da <acronym>SQL</acronym>. Per
    preservare la sicurezza di tipo di questa restrizione è importante
    seguire questa regola di codificazione: non creare nessuna funzione che viene
    dichiarata per restituire <type>internal</type> a meno che non abbia almeno un
    argomento <type>internal</type>.
   </para>

  </sect1>

 </chapter>

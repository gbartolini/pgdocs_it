<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

 <chapter id="mvcc">
  <title>Controllo concorrente</title>

  <indexterm>
   <primary>concorrenza</primary>
  </indexterm>

  <para>
Questo capitolo descrive il comportamento del sistema di database
<productname>PostgreSQL</productname> quando due o più
sessioni provano ad accedere agli stessi dati contemporaneamente. Gli obiettivi
in questa situazione sono di permettere un accesso efficiente per tutte le sessioni
mentre si mantiene una severa integrità dei dati. Ogni sviluppatore
di applicazioni database dovrebbe essere familiare con gli argomenti trattati
in questo capitolo.
  </para>

  <sect1 id="mvcc-intro">
   <title>Introduzione</title>

   <indexterm>
    <primary>MVCC</primary>
   </indexterm>

   <para>
<productname>PostgreSQL</productname> fornisce agli sviluppatori un ricco insieme di strumenti
per gestire l'accesso concorrente ai dati. Internamente, 
la consistenza dei dati è mantenuta usando un modello multiversione
(Multiversion Concurrency Control, <acronym>MVCC</acronym>).
Questo significa che mentre una transazione interroga un database, vede
un'istantanea dei dati (una <firstterm>versione del database</firstterm>)
come era poco prima, senza curarsi dello stato attuale dei dati sottostanti.
Questo protegge una transazione dal vedere dati inconsistenti che 
potrebbero essere causati da (altre) transazioni di update concorrenti sulle stesse
righe di dati, fornendo un  <firstterm>isolamento di transazione</firstterm>
per ogni sessione di database. <acronym>MVCC</acronym>, evitando
le metodologie di lock esplicite dei sustemi di database tradizionali,
minimizano i lock in modo da permettere performance elevate in
sistemi multiutente.
   </para>

   <para>
Il vantaggio principale dell'uso del modello di controllo concorrente <acronym>MVCC</acronym> 
piuttosto che i meccanismi di lock è che nell'<acronym>MVCC</acronym>
i lock acquisiti per interrogare dati (lettura), non vanno in conflitto 
con i lock acquisiti per scrivere dati, e così 
la lettura non blocca mai la scrittura e la scrittura non blocca mai la lettura.
   </para>

   <para>
Funzionalità di locking a livello di riga e tabella sono comunque disponibili 
in <productname>PostgreSQL</productname> per applicazioni che non si adattano
facilmente al comportamento <acronym>MVCC</acronym>. Comunque, un uso appropriato
di <acronym>MVCC</acronym> generalmente risulterà in performance migliori 
rispetto ai lock. Inoltre, i lock consultivi prevedono un meccanismo 
per l'acquisizione dei lock che non sono legati
a una singola transazione.
   </para>
  </sect1>

  <sect1 id="transaction-iso">
   <title>Isolamento transazionale</title>

   <indexterm>
    <primary>isolamento transazionale</primary>
   </indexterm>

   <para>
Lo standard <acronym>SQL</acronym> definisce quattro livelli di 
isolamento transazionale in termini di tre fenomeni che devono essere
preventivati tra transazioni concorrenti. Questi fenomeni indesiderati sono:

    <variablelist>
     <varlistentry>
      <term>
       lettura sporca
       <indexterm><primary>lettura sporca</primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione legge i dati scritti da una transazione concorrente che non ha fatto un commit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lettura non ripetibile
       <indexterm><primary>lettura non ripetibile </primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione legge di nuovo dati che ha letto precedentemente e scopre che i 
dati sono stati modificati da un'altra transazione (che ha eseguito un commit dopo la 
lettura iniziale).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lettura fantasma
       <indexterm><primary>lettura fantasma</primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione esegue di nuovo una query che restituisce un insieme di righe che soddisfa
una condizione di ricerca e scopre che l'insieme di righe che soddisfano la condizione 
è cambiata a causa di un'altra transazione che ha eseguito un commit di recente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <indexterm>
     <primary>livello di isolamento transazionale</primary>

    </indexterm>
I quattro livelli di isolamento transazionale e i comportamenti corrispondenti
sono descritti in <xref linkend="mvcc-isolevel-table"/>.
   </para>

    <table tocentry="1" id="mvcc-isolevel-table">
     <title>Livelli di isolamento di transazione <acronym>SQL</acronym></title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>
         Livello di isolamento
        </entry>
        <entry>
         Lettura sporca
        </entry>
        <entry>
         Lettura non ripetibile
        </entry>
        <entry>
         Lettura fantasma
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         Lettura che non ha fatto commit
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Lettura che ha fatto commit
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Lettura ripetibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Serializzabile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
In <productname>PostgreSQL</productname>, è possibile richiedere uno qualsiasi 
dei quattro livelli standard di isolamento di transazione. Ma internalmente, ci sono 
solo due distinti livelli di isolamento, che corrispondono ai livelli Read
Committed e Serializable. Quando si sceglie il livello Read Uncommitted 
in realtà si otterrà Read Committed, e quando si sceglie 
Repeatable Read in realtà si otterrà Serializable, così il livello di isolamento effettivo
potrebbe essere più stretto di quello scelto. Questo è permesso dallo standard SQL:
i quattro livelli di isolamento definiscono solo quali fenomeni 
non devono accadere, non definiscono quali fenomeni devono accadere.
La ragione per la quale <productname>PostgreSQL</productname>
fornisce solo due livelli di isolamento è che questo è l'unico modo sensato
per gestire i livelli di isolamento standard nell'architettura 
di controllo concorrente. Il comportamento dei livelli di isolamento 
è spiegato in dettaglio nelle sottosezioni seguenti.
   </para>

   <para>
Per impostare il livello di isolamento transazionale di una transazione, usare 
il comando <xref linkend="sql-set-transaction"/>.
   </para>

  <sect2 id="xact-read-committed">
   <title>Livello di isolamento  Read Committed </title>

   <indexterm>
    <primary>livello di isolamento transazionale</primary>
    <secondary>read committed</secondary>
   </indexterm>

   <para>
<firstterm>Read Committed</firstterm> è il livello di isolamento predefinito
in <productname>PostgreSQL</productname>. Quando una transazione usa 
questo livello di isolamento, una query <command>SELECT</command> 
(senza clausola <literal>FOR UPDATE/SHARE</literal>) vede solo i dati 
che sono stati sottoposti a commit prima che query iniziasse; essa non vede mai nè 
i dati non sottoposti a commit nè i cambiamenti sottoposti a commit da transazioni  
concorrenti durante l'esecuzione
della query.  In effetti, una query <command>SELECT</command> vede un'istantanea
del database nell'istante in cui è partita.
Ad ogni modo,  <command>SELECT</command> vede gli effetti
di update precedenti eseguite all'interno della propria transazione, 
anche se non sono ancora stati sottoposti a commit. Notare inoltre che due 
comandi <command>SELECT</command> possono vedere dati differenti, anche 
se sono all'interno di una singola transazione, se altre transazioni 
eseguono cambiamenti durante l'esecuzione della prima <command>SELECT</command>.
   </para>

   <para>
I comandi <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
FOR UPDATE</command>, e <command>SELECT FOR SHARE</command> 
si comportano allo stesso modo di <command>SELECT</command>
che sono state sottoposte a commit dopo il momento di inizio del comando. In ogni caso, tale
riga potrebbe essere già stata aggiornata (o cancellata, o sottoposta a lock) da un'altra
    another concurrent transaction by the time it is found.  In this case, the
transazione concorrente nel momento che viene trovata. In questo caso, 
    would-be updater will wait for the first updating transaction to commit or
    roll back (if it is still in progress).  
    If the first updater rolls back,
Se la prima transazione esegue un rollback,
allora i suoi effetti sono negati e la seconda transazione di aggiornamento può procedere 
con l'aggiornamento della riga trovata originariamente. Se la prima transazione esegue un commit, la seconda
ignorerà la riga se la transazioni l'ha cancellata,
altrimenti tenterà di applicare la sua operazione alla versione aggiornata della riga. 
La condizione di ricerca del comando (la clausola <literal>WHERE</literal>) viene 
rivalutata per vedere se la versiona ggiornata della riga corrisponde ancora alla condizione di ricerca.
Se si, la seconda transazione procede con le sue operazioni
usando la versione aggiornata della riga. Nel caso di 
<command>SELECT FOR UPDATE</command> e <command>SELECT FOR
SHARE</command>, questo significa che è la versione aggiornata della riga che
viene sottoposta a lock e restituita al client.
   </para>
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->

   <para>
A causa della regola sopra, è possibile, per un comando di aggiornamento, vedere 
un'istantanea inconsistene: può vedere gli effetti di comandi di aggiornamento
concorrenti sulle stesse righe che sta tentando di aggiornare, ma non vede 
gli effetti di quei comandi sulle altre righe nel database.
Questo comportamento rende la modalità Read Committed inadatta a comandi che 
coinvolgono condizioni di ricerca complesse; in ogni caso, va bene per casi più semplici.
Per esempio, considerare l'aggiornamento di saldi bancari con transazioni tipo:

<screen>
BEgin;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
</screen>

Se due di quelle transazioni provano a cambiare concorrentemente il saldo dell'account 
12345, chiaramente si vorrà che la seconda transazione cominci con la versione 
aggiornata della riga di account. Dato che ogni comando incluisce solamente su una riga 
predetermiata, lasciargli vedere la versione aggiornata della riga non crea 
nessun problema di inconsistenza.
   </para>

   <para>
Un utilizzo più complesso può produrre risultati non desiderati in modalità
Read Committed. Per esempio, considerare un comando <command>DELETE</command>
che opera su dati che sono stati sia aggiunti che rimossi dai suoi 
criteri di restrizione da un altro comando, per es., sia
<literal>website</literal> una tabella  con due righe con
<literal>website.hits</literal> uguale a <literal>9</literal> e
<literal>10</literal>:

<screen>
BEgin;
UPDATE website SET hits = hits + 1;
-- eseguito da un'altra sessione:  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

<command>DELETE</command> non avrà effetti dato che 
c'è una riga <literal>website.hits = 10</literal> prima e dopo 
l'<command>UPDATE</command>. Questo accade perchè 
il valore di riga precedentemente aggiornato <literal>9</literal> viene saltato, e quando
l'<command>UPDATE</command> è completo e <command>DELETE</command>
ottiene un lock, il nuovo valore di riga non è più <literal>10</literal> ma
<literal>11</literal>, che non corrisponde più ai criteri di ricerca.
   </para>

   <para>
Dato che la modalità Read Committed comincia ogni comando con una nuova istantanea
che include tutte le transazioni sottoposte a commit fino a quell'istante,
i comandi successivi nella stessa transazione vedranno gli effetti 
della transazione concorrente sottoposta a commit in ogni caso. Il punto della questione 
è se un <emphasis>singolo</emphasis> comando ha o meno una visione assolutamente consistente del database.
   </para>

   <para>
L'isolamento transazionale parziale fornito dalla modalità Read Committed
è adeguato per molte applicazioni, e questa modalità è veloce e semplice da usare;
comunque, non è sufficiente per tutti i casi. Le applicazioni che 
fanno query e aggiornamenti complessi potrebbero richiedere una visione consistente del database
più rigorosa che quella fornita dalla modalità Read Committed.
   </para>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Livello di isolamento serializzabile</title>

   <indexterm>
    <primary>livello di isolamento transazionale</primary>
    <secondary>serializzabile</secondary>
   </indexterm>

   <para>
Il livello di isolamento <firstterm>Serializable</firstterm> fornisce l'isolamento
transazionale più rigido. Questo livello emula l'esecuzione di transazioni seriali,
come se le transazioni fossero state eseguite una dopo l'altra, in maniera seriale,
invece che concorrentemente. Comunque, applicazioni che usano questo livello devono 
essere preparate a ritentare le transazioni dopo fallimenti della serializzazione.
   </para>

   <para>
Quando una transazione usa il livello serializzabile,
una query <command>SELECT</command> vede i dati sottoposti a commit prima che la transazione sia iniziata;
non vede mai nè dati non sottoposti a commit nè cambiamenti
sottoposti a commit durante l'esecuzione di transazione 
da parte di transazioni concorrenti. (Comunque, 
la query vede gli effetti di aggiornamenti precedenti
eseguiti all'interno della propria transazione, anche se non sono ancora state 
sottoposte a commit). Questo è diverso dal Read Committed nel quale 
una query in una transazione serializzabile 
vede un'istantanea all'inizio della  <emphasis>transazione</emphasis>,
non all'inizio della quey corrente all'interno della transazione. Così,
comandi <command>SELECT</command> successivi all'interno di una <emphasis>singola</emphasis>
transazione vedono gli stessi dati, per es., non vedono cambiamenti fatti 
da altre transazioni che sono stati sottoposti a commit dopo che le proprie transazioni sono partite.
(Questo comportamento può essere ideale per applicazioni di riportistica).
   </para>

   <para>
I comandi <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
FOR UPDATE</command>, e <command>SELECT FOR SHARE</command> 
si comportano come <command>SELECT</command>
in termini di ricerca di righe: trovano solo righe che sono state sottoposte a commit
dal momento di inizio della transazione. Comunque, quella riga
potrebbe essere già stata aggiornata (o cancellata, o sottoposta a lock) da
un'altra transazione concorrente, nel momento in cui è stata trovata. In questo caso,
la transazione serializzabile aspetterà che la prima transazione esegua un commit o un
rool back (se è ancora in corso). Se la prima transazione esegue un rollback, 
allora i suoi effetti sono negati e la transazione serializzabile può procedere
con l'aggiornamento della riga trovata originariamente. Ma se la prima transazione esegue un commit
(ed effettivamente aggiorna o cancella la riga, non esegue semplicemente un lock)
allora la transazione serializzabile sarà sottoposta a rollback con il messaggio

<screen>
ERROR:  could not serialize access due to concurrent update
</screen>

dato che una transazione serializabile non può modificare i eseguire lock su righe 
cambiate da altre transzioni dopo che la transazione serializzabile è iniziata.
   </para>

   <para>
Quando l'applicazione riceve questo messaggio di errore, dovrebbe 
annullare la transazione corrente e riprovare l'intera transazione dall'inizio.
La seconda volta, la transazione vedrà il cambiamento sottoposto a commit precedentemente
come parte della sua visione iniziale del database,
così non c'è conflitto logico nell'usare la nuova versione della riga 
come punto di partenza per la nuova transazione.
   </para>

   <para>
Notare che solo transazioni di aggiornamento potrebbero necessitare di essere riprovate; 
transazioni a sola lettura non avranno mai conflitti di serializzazione.
   </para>

   <para>
La modalità Serializable fornisce una garanzia rigorosa che ogni 
transazione abbia una visione completamente consistente del database. Comunque,
l'applicazione dev'essere preparata a ritentare le transazioni quando aggiornamenti concorrenti
rendono impossibile l'illusione di esecuzione seriale.
Dato che il costo di rifare transazioni complesse può essere significativo,
la modalità Serializable è raccomandata solo quando transazioni di aggiornamento contengono
logiche sufficientemente complesse che potrebbero fornire risposte sbagliate in modalità
Read Committed. Di solito, la modalità Serializable è necessaria quando 
una transazione esegue diversi comandi successivi che devono avere
visioni identiche del database.
   </para>

   <sect3 id="mvcc-serializability">
    <title>Isolamento serializzabile contro serializzabilità reale</title>

   <indexterm>
    <primary>serializzabilità</primary>
   </indexterm>

   <indexterm>
    <primary>lock di predicati</primary>
   </indexterm>

   <para>
Il significato intuitivo (e la definiziona matematica) di 
esecuzione <quote>serializzabile</quote> è che qualsiasi due transazioni che hanno 
effettuato un commit con successo appariranno come se fossero state eseguite in maniera strettamente
seriale, una dopo l'altra - sebbene quale appaia come eseguita prima potrebbe
non  essere prevedibile in anticipo. È importante rendersi conto che vietare  
i comportamenti indesiderati elencati nella <xref linkend="mvcc-isolevel-table"/>
non è sufficiente a garantire una vera serializzazione, e infatti 
la modalità Serializable di <productname>PostgreSQL</productname> <emphasis>non
garantisce l'esecuzione serializzabile in questo senso</emphasis>. Come esempio,
considerare una tabella <structname>mytab</structname>, contenente inizialmente: 
<screen>
 class | value 
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200
</screen>
Supporre che la transazione serializzabile A calcola:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 1;
</screen>
e poi inserisce il risultato (30) come <structfield>valore</structfield> in una 
nuova riga con <structfield>class</structfield><literal> = 2</literal>. Concorrentemente, la transazione
serializzabile B calcola:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 2;
</screen>
e ottiene il risultato 300, che inserisce in una nuova riga con
<structfield>class</structfield><literal> = 1</literal>. Quindi entrambe le transazioni fanno il commit.
Nessuno dei comportamenti indesiderati elencati si è presentato, ma si otterrà
un risultato che non potrebbe essere successo in nessun ordine serialmente. 
Se A è stata eseguita prima di B, B avrebbe calcolato la somma 330, non 300, 
e similmente l'altro ordine sarebbe risultato in una somma diversa di quella calcolata da A.
   </para>

   <para>
Per garantire vera serializzazione matematica, è necessario per un sistema di   
database assicurare il <firstterm>predicate locking</firstterm>, che significa che 
una transazione non può inserire o modificare una riga che potrebbe corrispondere
a una condizione <literal>WHERE</literal> di una query in un'altra transazione
concorrente. Per esempio, una volta che la transazione A ha eseguito la query 
<literal>SELECT ... WHERE class = 1</literal>, un sistema di <firstterm>predicate locking</firstterm>
eviterebbe che la transzione B inserisse qualsiasi nuova riga con class 1 finchè
A ha fatto commit.
     <footnote>
      <para>
Essenzialmente, un sistema di <firstterm>predicate locking</firstterm> previene 
letture fantasma restringendo cosa viene scritto, mentre MVCC le previene restringendo cosa
viene letto.
      </para>
     </footnote>
Tale sistema di locking è complesso da implementare
e estremamente costoso in esecuzione, dato che ogni sessione deve
fare attenzione ai dettagli di ogni query eseguita da ogni transazione concorrente.
E questa grande spesa è per la maggior parte inutile, dato che in pratica
la maggior parte della applicazioni non fanno il tipo di cose che potrebbero generare problemi.
(Certamente l'esempio sopra è abbastanza forzato ed è improbabile che rappresenti 
software reale). Per queste ragioni, 
<productname>PostgreSQL</productname> non implementa il predicate locking.
   </para>

   <para>
In casi dove la possibilità di esecuzione non-serializzabile è realmente
un azzardo, è possibile prevenire i problemi con un uso appropriato di 
lock esplicito. Maggiori dettagli appaiono nelle sezioni seguenti.
   </para>
  </sect3>
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
   <title>Lock esplicito</title>

   <indexterm>
    <primary>lock</primary>
   </indexterm>

   <para>
<productname>PostgreSQL</productname> fornisce varie modalità di lock
per controllare accessi concorrenti ai dati nelle tabelle. Queste modalità possono
essere usate per fare dei lock controllate dall'applicazione in situazioni dove
<acronym>MVCC</acronym> non fornisce ilcomportamento desiderato. Inoltre, 
la maggior parte dei comandi <productname>PostgreSQL</productname> acquisiscono 
automaticamente lock delle modalità appropriate per assicurare che tabelle 
a cui si fa riferimento non siano cancellate o modificate in modi incompatibili mentre
il comando è in esecuzione. (Per esempio,  <command>TRUNCATE</command> non può essere eseguito  
concorrentemente ad altre operazioni sulla stessa tabella in maniera sicura, e così ottiene
un lock esclusivo sulla tabella per assicurarlo).
   </para>

   <para>
Per esaminare un elenco dei lock attualmente presenti in un server database,
usare la vista di sistema <link linkend="view-pg-locks"><structname>pg_locks</structname></link>.
Per maggiori informazioni sul monitoraggio dello stato del sottosistema di gestione 
dei lock, si veda <xref linkend="monitoring"/>.
   </para>

  <sect2 id="locking-tables">
   <title>Table-Level Locks</title>

   <indexterm zone="locking-tables">
    <primary>lock</primary>
   </indexterm>

   <para>
L'elenco sottostante mostra le modalità di lock disponibili a i contesti in cui 
sono usati automaticamente da 
<productname>PostgreSQL</productname>.  È anche possibile ottenere uno qualsiasi di questi lock 
esplicitamente col comando <xref linkend="sql-lock"/>.
Ricordare che tutte queste modalità di lock sono lock a livello di tabella, 
anche se il nome contiene la parola <quote>row</quote>; i nomi
delle modalità di lock sono storici.
In qualche modo i nomi rispecchiano l'utilizzo tipico di ogni modalità di lock -
ma la semantica è sempre la stessa. L'unica vera differenza 
tra una modalità di lock e un'altra è l'insieme di modalità di lock con le quali 
ognuna va in conflitto (si veda <xref linkend="table-lock-compatibility"/>).
Due transazioni non possono ottenere lock di modalità che vanno in conflitto
sulla stessa tabella nello stesso momento. (Comunque, una transazione non va mai in conflitto 
con sè stessa. Per esempio, potrebbe ottenere
un lock <literal>ACCESS EXCLUSIVE</literal> e più tardi un lock 
<literal>ACCESS SHARE</literal> sulla stessa tabella). Modalità di lock che non vanno 
in conflitto possono essere trattenute concorrentemente da molte transazioni. Notare  
in particolare che alcune modalità di lock vanno in conflitto con sè stesse (per esempio,  
un lock <literal>ACCESS EXCLUSIVE</literal> non può essere trattenuto da più di una transazione alla volta)
mentre gli altri non vanno in conflitto con sè stessi (per esempio, 
un lock <literal>ACCESS SHARE</literal> può essere trattenuto da molteplici transazioni).
   </para>

     <variablelist>
      <title>Modalità di lock a livello di tabella</title>
      <varlistentry>
       <term>
        <literal>ACCESS SHARE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto solamente con la modalità di lock <literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
Il comando <command>SELECT</command> acquisisce un lock di questo tipo sulle tabelle    
referenziate. In generale, qualsiasi query che <emphasis>legge</emphasis> una tabella
e non la modifica acquisirà questo tipo di lock.    
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ROW SHARE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità di lock <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
I comandi <command>SELECT FOR UPDATE</command> e <command>SELECT FOR SHARE</command>
acquisiscono un lock di questo tipo sulla tabella/e richieste (in aggiunta a 
dei lock <literal>ACCESS SHARE</literal> su qualsiasi altra tabella 
che è referenziata ma non selezionata <option>FOR UPDATE/FOR SHARE</option>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ROW EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
VA in conflitto con le modalità <literal>SHARE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
I comandi <command>UPDATE</command>,
<command>DELETE</command>, e <command>INSERT</command>
acquisiscono questa modalità di lock sulla tabella desiderata (in aggiunta a 
dei lock <literal>ACCESS SHARE</literal> su qualsiasi altra tabella referenziata).
In generale, questa modalità di lock sarà acquisita da qualsiasi comando 
che <emphasis>modifica i dati</emphasis> in una tabella.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE UPDATE EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
VA in conflitto con le modalità di lock <literal>SHARE UPDATE EXCLUSIVE</literal>,
<literal>SHARE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e 
<literal>ACCESS EXCLUSIVE</literal>.
Questa modalità protegge una tabella rispetto 
a cambiamenti di schema concorrenti e al <command>VACUUM</command>.
        </para>

        <para>
Acquisito da <command>VACUUM</command> (senza <option>FULL</option>),
<command>ANALYZE</command> e <command>CREATE INDEX CONCURRENTLY</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità <literal>ROW EXCLUSIVE</literal>,
<literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
Questa modalità protegge una tabella rispetto a cambiamenti di dato concorrente.
        </para>

        <para>
Acquisito da <command>CREATE INDEX</command>
(senza <option>CONCURRENTLY</option>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE ROW EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità <literal>ROW EXCLUSIVE</literal>,
<literal>SHARE UPDATE EXCLUSIVE</literal>,
<literal>SHARE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
Acquisito da <command>CREATE TRIGGER</command>,
<command>CREATE RULE</command> (ad eccezione di regole <literal>ON SELECT</literal>)
ed in alcuni casi <command>ALTER TABLE</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità <literal>ROW SHARE</literal>, <literal>ROW
EXCLUSIVE</literal>, <literal>SHARE UPDATE
EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
Questa modalità permette solo lock  <literal>ACCESS SHARE</literal> concorrenti,
per es., con una transazione che possiede questo tipo di lock  
possono procedere in parallelo solo le letture dalla tabella.
        </para>

        <para>
Questa modalità di lock non viene acquisita automaticamente su tabelle utente da
nessun comando <productname>PostgreSQL</productname>. Comunque viene acquisita
su certi cataloghi di sistema in alcune operazioni.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ACCESS EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con lock di tutti i tipi (<literal>ACCESS
SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
EXCLUSIVE</literal>, <literal>SHARE UPDATE
EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>).
Questa modalità garantisce che chi possiede il lock 
sia l'unica transazione che ha accesso alla tabella in qualsiasi modo.
        </para>

        <para>
Acquisito dai comandi <command>DROP TABLE</command>,
<command>TRUNCATE</command>, <command>REINDEX</command>,
<command>CLUSTER</command> e <command>VACUUM FULL</command>, 
così come la maggior parte delle varianti di <command>ALTER TABLE</command>.
Questa, inoltre, è la moda predefinita per le istruzioni <command>LOCK TABLE</command>
che non specificano una modalità esplicitamente.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
      <para>
Solamente un lock <literal>ACCESS EXCLUSIVE</literal> blocca un'istruzione 
<command>SELECT</command> (senza <option>FOR UPDATE/SHARE</option>)
      </para>
     </tip>

   <para>
    Once acquired, a lock is normally held till end of transaction.  But if a
    lock is acquired after establishing a savepoint, the lock is released
    immediately if the savepoint is rolled back to.  This is consistent with
    the principle that <command>ROLLBACK</command> cancels all effects of the
    commands since the savepoint.  The same holds for locks acquired within a
    <application>PL/pgSQL</application> exception block: an error escape from the block
    releases locks acquired within it.
   </para>



    <table tocentry="1" id="table-lock-compatibility">
     <title>Modalità di lock che vanno in conflitto</title>
     <tgroup cols="9">
      <colspec colnum="2" colname="lockst"/>
      <colspec colnum="9" colname="lockend"/>
      <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
      <thead>
       <row>
        <entry morerows="1">Modalità di lock richiesta</entry>
        <entry spanname="lockreq">Modalità di lock corrente</entry>
       </row>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry>ROW SHARE</entry>
        <entry>ROW EXCLUSIVE</entry>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry>SHARE</entry>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry>EXCLUSIVE</entry>
        <entry>ACCESS EXCLUSIVE</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ACCESS EXCLUSIVE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-rows">
    <title>Lock a livello di riga</title>

    <para>
In aggiunta ai lock a livello di tabella, ci sono lock a livello di riga, che 
possono essere lock esclusivi o condivisi. Un lock esclusivo 
su una specifica riga viene automaticamente acquisito quando la riga viene aggiornata
o cancellata. Il lock è conservato fino a che la transazione fa un commit o un rollback, 
esattamente come lock a livello di tabella. Lock a livello di riga 
non hanno effetto sull'interrogazione dei dati; bloccano solo <emphasis>scritture sulla stessa riga</emphasis>.
    </para>

    <para>
Per ottenere un lock di riga esclusivo su una riga senza modificare effettivamente la riga,
selezionare la riga con <command>SELECT FOR
UPDATE</command>.  Notare che una volta che il lock di riga viene acquisito,  
la transazione può aggiornare la riga molte volte senza
temere conflitti.
    </para>

    <para>
Per acquisire un lock di riga condiviso, selezionare la riga con  
<command>SELECT FOR SHARE</command>. Un lock condiviso non previene il fatto
che altre transazioni possano acquisire lo stesso lock condiviso. Comunque,
nessuna dtransazione ha il permesso di aggiornare, cancellare, o ottenere un lock esclusivo su una
riga sulla quale qualsiasi altra transazione mantiene un lock condiviso. Qualsiasi tentativo
di farlo si bloccherà finchè il lock non viene rilasciato.
    </para>

    <para>
<productname>PostgreSQL</productname> non mantiene nessuna informazione
sulle righe modificate in memoria, così non c'è un limite per il numero 
di righe con lock contemporanee. Comunque, fare il lock di una riga 
potrebbe causare una scrittura su disco, per es., <command>SELECT FOR
UPDATE</command> modifica le righe selezionate per contrassegnarle come sottoposte a lock, 
e quindi risulterà in scritture su disco.
    </para>

    <para>
In aggiunta a lock di tabella e riga, vengono usati locki condivisi/esclusivi a livello di pagina
per controllare gli accessi in lettura/scrittura alle pagine della tabella nel buffer condiviso.
Questi lock sono rilasciati immediatamente dopo che una riga viene "fetched" o 
aggiornata. Gli sviluppatori di applicazioni normalmente non devono preoccuparsi dei lock 
di pagina, ma sono menzionati qui per completezza.
    </para>

   </sect2>

   <sect2 id="locking-deadlocks">
    <title>Deadlock</title>

    <indexterm zone="locking-deadlocks">
     <primary>deadlock</primary>
    </indexterm>

    <para>
L'uso di lock espliciti può incrementare la probabilità di  
<firstterm>deadlock</firstterm>, in cui due (o più) transazioni 
mantengono entrambe lock che gli altri vogliono. Per esempio, se la transazione uno
acquisisce un lock esclusivo sulla tabella A e successivamente prova ad acquisire 
un lock esclusivo sulla tabella B, mentre la transazione 2 ha già
eseguito un lock esclusivo sulla tabella B e adesso vuole un lock esclusivo sulla
tabella A, allora nessuna delle due può procedere.
<productname>PostgreSQL</productname> riconosce automaticamente 
situazioni di deadlock e le risolve annullando una delle transazioni coinvolte,
permettendo all'altra/e di completarsi.
(È difficile predirre esattamente quale transazione sarà annullata
e quindi non si dovrebbe farci affidamento).
    </para>

    <para>
Notare che i deadlock possono avvenire anche come risultato di lock di riga
(e così, possono accadere anche se non viene usato un lock esplicito).
Considerare il caso in cui due transazioni concorrenti 
modificano una tabella. La prima transazione esegue:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</screen>

Questo acquisisce un lock di riga sulla riga con il numero di account specificato.
Quindi, la seconda transazione esegue:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</screen>

La prima istruzione <command>UPDATE</command> ottiene con successo
un lock di riga sulla riga specificata, e così riesce ad aggiornare con successo quella riga.
Comunque, la seconda istruzione <command>UPDATE</command>
scopre che la riga che sta tentando di aggiornare è già stata sottoposta a lock, 
e quindi aspetta che la transazione che aveva acquisito il lock sia completa.
La transazione due aspetta quindi che la transazione uno dia completata prima di 
continuare l'esecuzione. Ora, la transazione uno esegue:

<screen>
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</screen>

La transazione uno tenta di ottenere un lock di riga sulla riga specificata,
ma non può: la transazione due possiede già quel lock.
Così aspetta che la transazione due sia completa. Così,
la transazione uno è bloccata sulla transazione due, e la transazione due
è bloccata sulla transazione uno: una condizione di deadlock.
<productname>PostgreSQL</productname> si accorge di questa situazione 
e annulla una delle transazioni.
    </para>

    <para>
La miglior difesa contro i deadlock, generalmente, è evitare che diventi
certo che tutte le applicazioni che usano un database acquisiscano
lock su molteplici oggetti in un ordine costante. Nell'esempio 
sopra, se entrambe le transazioni 
hanno aggiornato le righe nello stesso ordine, non si saranno verificati deadlock.
Si dovrebbe esser sicuri che il primo lock acquisito su un oggetto in una transazione
è nella modalità più restrittiva che sarà necessaria a quell'oggetto.
Se non è fattibile verificarlo in anticipo,  
allora i deadlock possono essere gestiti al volo ritentando le transazioni
annullate a causa di deadlock.
    </para>

    <para>
Finchè nessuna situazione di deadlock viene riscontrata, una transazione che cerca
o un lock di tabella o un lock di riga aspetterà indefinitamente che i lock in conflitto 
siano rilasciati. Questo significa che è una cattiva idea per le applicazioni 
trattenere transazioni aperte per lunghi periodi di tempo
(per es., mentre aspettano input dell'utente).
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Lock consultivi</title>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>consultivo</secondary>
    </indexterm>

    <para>
<productname>PostgreSQL</productname> fornisce dei mezzi per
la creazione di lock che hanno significati definiti dall'applicazione. Questi vengono
chiamati <firstterm>lock consultivi</firstterm>, dato che il sistema non impone 
il loro urtilizzo - è compito dell'applicazione usarli correttamente.
I lock consultivi possono essere utili per strategie di locking 
che sono poco maneggevoli per il modello MVCC. Una  volta acquisito, un
lock consultivo viene tenuto fino a che non viene rilasciato esplicitamente o se la sessione termina.
A differenza dei lock standard, i lock consultivi non rispettano
la semantica transazionale: un lock acquisito durante una transazione
che successivamente è sottoposto a rollback sarà ancora trattenuto seguendo il rollback,
e anche un unlock entra in vigore anche se le la transazione chiamante successivamente fallisce.
Lo stesso lock può essere acquisito molteplici volte dal processo a cui appartiene:
per ogni richiesta di lock  ci deve essere una corrispondente
richiesta di unlock prima che venga effettivamente rilasciato. (Se una sessione
possiede già un dato lock, avranno luogo richieste aggiuntive,  anche se altre sessioni
sono in attesa del lock). Come tutti i lock in 
<productname>PostgreSQL</productname>, un elenco completo dei lock consultivi
legati a una qualsiasi sessione possono essere trovati nella vista di sistema
<link linkend="view-pg-locks"><structname>pg_locks</structname></link>
    </para>

    <para>
I lock consultivi vengono allocati fuori dal pool di memoria condivisa di cui 
la dimensione viene definita dalle variabili di configurazione
<xref linkend="guc-max-locks-per-transaction"/> e
<xref linkend="guc-max-connections"/>.
Si deve fare attenzione a non esaurire questa
memoria o il server sarà incapace di concedere del tutto qualsiasi lock. 
Questo impone un limite superiore sul numero di lock consultivi 
concessi dal server, tipicamente in decine o centinaia di migliaia
dipendentemente da come è configurato il server.
    </para>

    <para>
Un utilizzo comune dei lock consultivi è di emulare strategie di lock 
pessimistiche tipiche dei sistemi di gestione di dati chiamti <quote>flat file</quote>.
Mentre una flag immagazzinata in una tabella potrebbe essere usata per lo stesso scopo,
i lock consultivi sono più veloci, evitando che MVCC si gonfi, e sono automaticamente 
puliti dal server alla fine della sessione.
In certi casi, usare questo metodo di locking consultivo, specialmente in query 
che coinvolgono ordinamento esplicito e clausole <literal>LIMIT</literal>, si deve fare attenzione
a controllare i lock acquisiti a causa dell'ordine in cui le espressioni SQL 
vengono valutate. Per esempio:
<screen>
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- pericoloso!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</screen>
Nelle query sopra, la seconda forma è pericolosa perchè non è garantito che la 
<literal>LIMIT</literal> venga applicata prima che la funzione di locking sia eseguita.
Questo potrebbe causare che alcuni lock che l'applicazione non si aspettava siano acquisiti, 
per cui fallirebbe nel tentativo di rilasciarli
(finchè la sessione non finisce).
Dal punto di vista dell'applicazione, quei lock 
sarebbero pendenti, anche se ancora visibili in
<structname>pg_locks</structname>.
    </para>

    <para>
Le funzioni poste per manipolare lock consultivi sono descritte in  
<xref linkend="functions-advisory-locks"/>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
   <title>Controlli di consistenza dei dati a livello di applicazione</title>

   <para>
Dato che le letture in <productname>PostgreSQL</productname>
non eseguono lock dei dati, malgrado il livello di isolamento transazionale,
i dati letti da una transazione possono essere sovrascritti 
da un'altra transazione concorrente. In altre parole, 
se una riga viene restituita da <command>SELECT</command> non significa che 
la riga è ancora la corrente nell'istante che è restituita (per es., a volte 
dopo che la query attuale è cominciata). La riga potrebbe essere stata modificata o
cancellata da una transazione che ha già fatto un commit dopo che la 
<command>SELECT</command> è iniziata.
Anche se la riga è comunque valida <quote>ora</quote>, potrebbe essere cambiato o  
cancellato 
prima che la transazione corrente faccia un commit o un rollback.
   </para>

   <para>

Un altro modo di pensare a questo è che ogni transazione vede
un'istantanea del contenuto del database, e concorrentemente  
transazioni in esecuzione  potrebbero vedere differenti istantanee. Così 
l'intero concetto di <quote>ora</quote> in qualche modo è comunque non ben definito. 
Normalmente non è 
un gran problema se le applicazioni client sono isolate l'una dall'altra,
me se i client possono comunicare attraverso canali esterni al database
allora potrebbe verificarsi molta confusione. 
   </para>

   <para>
Per assicurare la validità della riga corrente e proteggerla rispetto 
ad aggiornamenti concorrenti si deve usare <command>SELECT FOR UPDATE</command>,
<command>SELECT FOR SHARE</command> o un'istruzione <command>LOCK TABLE</command> appropriata. 
(<command>SELECT FOR UPDATE</command>
e <command>SELECT FOR SHARE</command> eseguono un lock solamente sulle 
righe restituite rispetto a agiornamenti concorrenti, mentre <command>LOCK
TABLE</command> esegue un lock sull'intera tabella). Questo dovrebbe essere messo in conto
quando si portano applicazioni a <productname>PostgreSQL</productname>
da altri ambienti.
   </para>

   <para>
I controlli di validità globale richiedono ulteriori considerazioni con <acronym>MVCC</acronym>.
Per esempio, un'applicazione bancaria potrebbe voler controllare che la somma
di tutti i crediti in una tabella uguagli la somma dei debiti in un'altra tabella,
mentre entrambe le tabelle vengono aggiornate attivamente. Confrontare i risultati di 
due comandi <literal>SELECT sum(...)</literal>  successivi non funzionerà correttamente in modalità 
Read Committed, dato che la seconda query probabilmente includerà i risultati 
di transazioni non contate dalla prima. Fare le due somme in una singola transazione serializzabile
fornirà una fotografia accurata solo degli effetti di transazioni che hanno fatto un commit 
prima che la transazione serializzabile cominciasse - ma si potrebbe legittimamente 
meravigliarsi se la risposta è ancora rilevante al momento della consegna.
Se la transazione serializzabile da sola ha applicato alcuni cambiamenti prima di tentare 
di fare un controllo di consistenza, 
l'utilità di questo  controllo è cmunque molto dibattuta, dato che adesso include alcuni 
ma non tutti i cambiamenti post-transazione. In quei casi 
una persona prudente potrebbe desiderare di fare un lock su tutte le tabelle necessarie al controllo,
per ottenere un'immagine indiscutibile della realtà corrente. Un lock in modalità
<literal>SHARE</literal> (o superiore) garantisce che non ci siano 
cambiamenti non sottoposti a commit nella tabella che ha il lock, diversi da quelli 
della transazione corrente.
   </para>

   <para>
Notare anche che se si fa affidamento sul locking esplicito per prevenire cambiamenti 
concorrenti, di dovrebbe usare o la modalità Read Committed, altrimenti in modalità Serializable
fare attenzione a ottenere i lock prima di eseguire le query.
Un lock ottenuto da una transazione serializzabile garantisce
che nessun'altra transazione che modifichi la tabella
sia in esecuzione, ma se l'istantanea vista dalla transazione 
precede l'acquisizione del lock, potrebbe anticipare alcuni cambiamenti appena sottoposti a commit 
nella tabella. Un'istantanea di transazione serializzabile attualmente viene 
bloccata all'inizio del suo primo comando di interrogazione o modifica dei dati
(<literal>SELECT</literal>, <literal>INSERT</literal>,
<literal>UPDATE</literal> o <literal>DELETE</literal>), così
è possibile ottenere lock esplicitamente prima che l'istantanea sia 
"congelata".
   </para>
  </sect1>

  <sect1 id="locking-indexes">
   <title>Locking e indici</title>

   <indexterm zone="locking-indexes">
    <primary>indice</primary>
    <secondary>lock</secondary>
   </indexterm>

   <para>
Nonostante <productname>PostgreSQL</productname>
fornisce accesso in lettura/scrittura "non bloccante" ai dati di tabella,
l'accesso in lettura/scrittura non bloccante  non è attualmente offerto per ogni
metodo di accesso agli indici implementato
in <productname>PostgreSQL</productname>.
I diversi tipi di indice sono gestiti nel seguente modo:

    <variablelist>
     <varlistentry>
      <term>
       indici B-tree e <acronym>gist</acronym> 
      </term>
      <listitem>
       <para>
Lock di pagina condivisi/esclusivi a breve termine sono usati per 
accessi il lettura/scrittura. I lock vengono rilasciati immediatamente dopo che ogni
indice di riga viene preso o inserito. Questi tipi di indice forniscono 
le maggiori condizioni di concorrenza senza deadlock.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       indici hash
      </term>
      <listitem>
       <para>
        Share/exclusive hash-bucket-level locks are used for read/write
        access.  Locks are released after the whole bucket is processed.
        Bucket-level locks provide better concurrency than index-level
        ones, but deadlock is possible since the locks are held longer
        than one index operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       indici <acronym>gin</acronym>
      </term>
      <listitem>
       <para>
Lock di pagina condivisi/esclusivi a breve termine sono usati per 
accessi il lettura/scrittura. I lock sono rilasciati immediatamente dopo che ogni
indice di riga viene preso o inserito. Ma si noti che l'inserimento di                  
un valore sottoposto a indice gin di solito produce diversi inserimenti 
di chiavi indice per riga, 
così gin potrebbe svolgere un considerevole lavoro per l'inserimento di un singolo valore.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
Correntemente, gli indici B-tree offrono la miglior prestazione per applicazioni 
concorrenti; dato che hanno anche maggiori caratteristiche rispetto agli indici 
hash, sono il tipo di indice raccomandato per applicazioni concorrenti
che hanno bisongno di indicizzare dati scalari. Quando si ha a che fare con
dati non scalari, i B-tree non sono utili, si dovrebbero unvece usare gli indici gist o gin. 
   </para>
  </sect1>
 </chapter>

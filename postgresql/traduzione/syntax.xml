<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="sql-syntax">
 <title>Sintassi SQL</title>

 <indexterm zone="sql-syntax">
  <primary>syntassi</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <para>
Questo capitolo descrive la sintassi di SQL. Costituisce le fondamenta
per la comprensione dei capitoli seguenti che affronteranno in dettaglio
come vengono applicati i comandi SQL per definire e modificare i dati.
 </para>

 <para>
Avvisiamo inoltre gli utenti che sono già familiari con SQL di leggere
questo capitolo attentamente perchè contiene diverse regole e concetti che
sono implementati incoerentemente tra i database SQL o che sono
specifici di <productname>PostgreSQL</productname>.
 </para>

 <sect1 id="sql-syntax-lexical">
  <title>Struttura lessicale</title>

  <indexterm>
   <primary>token</primary>
  </indexterm>

  <para>
Un input SQL consiste in una sequenza di 
<firstterm>comandi</firstterm>. Un comando è composto da una 
sequenza di <firstterm>tokens</firstterm>, trminati da un punto e virgola
(<quote>;</quote>). La fine dello stream di input termina pure il comando.
Quali token siano validi dipende dalla sintassi
del particolare comando.
  </para>

  <para>
Un token può essere una <firstterm>parola chiave</firstterm>, un
<firstterm>identificatore</firstterm>, un <firstterm>identificatore 
citato</firstterm>, un <firstterm>letterale</firstterm> (o
costante), o un simbolo speciale. I token normalmente sono
separati da spazi bianchi (spazio, tab, nuova linea), ma non dev'esserci se 
non c'è ambiguità (che è generalmente solo il caso in cui un carattere speciale
è adiacente a qualche altro tipo di token).
  </para>

   <para>
Per esempio, il seguente input e (sintatticamente) SQL valido:
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
Questa è una sequenza di tre comandi, uno per linea (anche se questo non è 
richiesto; più di un comando può stare in una linea, e i comandi possono
essere divisi su più linee).
   </para>

  <para>
Inoltre, in un input SQL ci possono essere <firstterm>commenti</firstterm>. 
Essi non sono token, sono effettivamente equivalenti a spazi bianchi.
  </para>

  <para>
La sintassi SQL non è molto coerente riguardo a cosa i token identificano come comandi 
o operandi o parametri. I primi token sono generalmente il nome del comando, così, nell'esempio sopra
parleremo di un comando <quote>SELECT</quote>, un <quote>UPDATE</quote> e
un <quote>INSERT</quote>. Ma, per esempio, il comando <command>UPDATE</command> richiede
sempre che un token <token>SET</token> appaia in una certa posizione, e 
questa particolare variazione di <command>INSERT</command> 
richiede <token>VALUES</token> per essere completo. La regole precise per la sintassi
di ogni comando sono descritte in <xref linkend="reference"/>.
  </para>

  <sect2 id="sql-syntax-identifiers">
   <title>Identificatori e parole chiave</title>

   <indexterm zone="sql-syntax-identifiers">
    <primary>identificatore</primary>
    <secondary>sintassi di</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>nome</primary>
    <secondary>sintassi di</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>aprola chiave</primary>
    <secondary>sintassi di</secondary>
   </indexterm>

   <para>
Token come <token>SELECT</token>, <token>UPDATE</token>, o
<token>VALUES</token> nell'esempio sopra sono esempi di 
<firstterm>parole chiave</firstterm>, cioè parole che hanno un significato preciso
nel linguaggio SQL. I token <token>MY_TABLE</token>
e <token>A</token> sono esempi di 
<firstterm>identificatori</firstterm>. Essi identificano nomi di
tabelle, colonne o altri oggetti del database, dipende dal comando in cui vengono 
usati. Quindi, a volte sono chiamati semplicemente <quote>nomi</quote>.
Le parole chiave e gli identificatori hanno la stessa struttura lessicale, 
quindi non è possibile sapere se un token è un identificatore
o una parola chiave senza conoscere il linguaggio.
Un elenco completo di parole chiave si trova in <xref
linkend="sql-keywords-appendix"/>.
   </para>

   <para>
Identificatori e parole chiave SQL devono cominciare con una 
lettera (<literal>a</literal>-<literal>z</literal>, ma anche lettere con
punti diacritici e lettere non Latine) o un underscore
(<literal>_</literal>).  I caratteri successivi in un identificatore o
parola chiave possono essere lettere, underscore, cifre
(<literal>0</literal>-<literal>9</literal>) o segni dollaro
(<literal>$</literal>). Notare che segni dollaro non sono permessi negli identificatori
in accordo con lo standard SQL, per questo il loro uso potrebbe rendere le applicazioni 
meno portabili. 
Lo standard SQL non definirà parole chiave che contengano 
cifre o comincino o finiscano con un underscore, cos' identificatori di questa forma sono sicuri
rispetto a possibili conflitti con esenzioni future dello standard.
   </para>

   <para>
<indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
Il sistema non usa più di <symbol>NAMEDATALEN</symbol>-1
byte di un identificatore; nomi più lunghi possono essere scritti in
comandi, ma saranno troncati. In maniera predefinita, 
<symbol>NAMEDATALEN</symbol> è 64 così la lunghezza massima per gli identificatori 
è 63 byte. Se questo limite è problematico, può essere alzato cambiando la costante
<symbol>NAMEDATALEN</symbol> in 
<filename>src/include/pg_config_manual.h</filename>.
   </para>

   <para>
    <indexterm>
     <primary>sensibilità al case</primary>
     <secondary>di comandi SQL</secondary>
    </indexterm>
Parole chiave e identificatori non quotati sono insensibili al case. Perciò:
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
può essere scritto, equivalentemente:
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
Una convenzione usata spesso è di scrivere le parole chiave in maiuscolo
e i nomi in minuscolo, per es.:
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>

   <para>
    <indexterm>
     <primary>virgolette</primary>
     <secondary>e identificatori</secondary>
    </indexterm>
C'è un altro tipo di identificatore: l'<firstterm>identificatore
delimitati</firstterm> o <firstterm>identificatore quotato</firstterm>.
Viene formato racchiudendo una sequenza di caratteri arbitraria in doppi apici
(<literal>"</literal>).  Un identificatore delimitato 
è sempre un identificatore, mai una parola chiave. Per questo 
<literal>"select"</literal> può essere usato per fare riferimento a una colonna
tabella chiamata <quote>select</quote>, mentre <literal>select</literal>
non quotato sarebbe considerato una parola chiave e
perchiò provocherebbe un errore quando usato dove ci si aspetta il nome di una tabella
o una colonna. L'esempio può essere scritto con indentificatori
quotati, in questo modo:
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>

   <para>
Identificatori quotati possono contenere qualsiasi carattere, ad eccezioni del carattere
con codice zero. (Per includere un carattere di doppi apici, scrivere due doppi apici).
Questo permette la creazione di nomi di tabelle o colonne che non sarebbero possibili altrimenti,
tipo nomi contenenti spazi o e commerciali. Viene comunque applicata la limitazione della lunghezza.
   </para>

   <para>
    <note>Nota per il revisore: TODO</note>
    <indexterm><primary>escape unicode escape</primary><secondary>in
    identificatori</secondary></indexterm> 
    A variant of quoted
    identifiers allows including escaped Unicode characters identified
    by their code points.  This variant starts
    with <literal>U&amp;</literal> (upper or lower case U followed by
    ampersand) immediately before the opening double quote, without
    any spaces in between, for example <literal>U&amp;"foo"</literal>.
    (Note that this creates an ambiguity with the
    operator <literal>&amp;</literal>.  Use spaces around the operator to
    avoid this problem.)  Inside the quotes, Unicode characters can be
    specified in escaped form by writing a backslash followed by the
    four-digit hexadecimal code point number or alternatively a
    backslash followed by a plus sign followed by a six-digit
    hexadecimal code point number.  For example, the
    identifier <literal>"data"</literal> could be written as
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    The following less trivial example writes the Russian
    word <quote>slon</quote> (elephant) in Cyrillic letters:
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>

   <para>
Se si desidera usare un carattere di escape diverso dalla barra inversa, è possibile 
specificarlo usando la clausola <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
dopo la stringa, per esempio:
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
Il carattere di escape può essere un singolo carattere piuttosto che una cifra decimale, 
il segno più, un singolo apice, doppi apici, 
o un carattere di spazio. Notare che il carattere di escape è scritto in singoli apici,
non doppi apici.
   </para>

   <para>
Per includere il carattere di escape letteralmente nell'identificatore, scriverlo
due volte. 
   </para>

   <para>
La sintassi di escape Unicode funziona solo quando la codifica del server è
<literal>UTF8</literal>.  Quando sono usate altre codifiche per il server, possono
essere specificati solo codici nell'intervallo ASCII (fino a <literal>\007F</literal>). 
Sia la forma a 4 cifre che quella a 6 cifre può essere usata per 
specificare coppie surrogate UTF-16 per comporre caratteri con codici
più grandi di U+FFFF, anche se la disponibilità della forma a 6 cifre tecnicamente la 
rende non necessaria. (Quando le coppie surrogate sono usate con server che usano codifica 
<literal>UTF8</literal>, esse sono prima combinate in un singolo codice 
che viene codificato in UTF-8).
   </para>

   <para>
Quotare un identificatore lo rende anche sensibile al case, mentre
nomi non quotati sono sempre resi in minuscolo. Per esempio, gli identificatori 
<literal>FOO</literal>, <literal>foo</literal>, e
<literal>"foo"</literal> sono considerati allo stesso modo da 
<productname>PostgreSQL</productname>, ma <literal>"Foo"</literal> e <literal>"FOO"</literal>
sono diversi da quei tre e anche tra di loro. (Il comportamento di <productname>PostgreSQL</productname> di rendere nomi non quotati in minuscolo
non è compatibile con lo standard SQL, che dice che i nomi non quotati  
dovrebbero essere resi in maiuscolo. Così, 
<literal>foo</literal>
dovrebbe essere equivalente a  <literal>"FOO"</literal>, non a
<literal>"foo"</literal>,s econdo lo standard. Se si vuole scrivere applicazioni portabili
si dovrebbe quotare sempre un particolare nome o non quotarlo mai.
   </para>
  </sect2>


  <sect2 id="sql-syntax-constants">
   <title>Costanti</title>

   <indexterm zone="sql-syntax-constants">
    <primary>costanti</primary>
   </indexterm>

   <para>
Ci sono tre tipi di <firstterm>costanti scritte implicitamente</firstterm>
in <productname>PostgreSQL</productname>:
stringhe, stringhe di bit e numeri.
Le costanti possono essere specificate anche con tipi espliciti, che possono
abilitare una rappresentazione più accurata e una gestione più efficiente 
da parte del sistema. Queste alternative sono discusse nelle sottosezioni seguenti.
   </para>

   <sect3 id="sql-syntax-strings">
    <title>Costanti stringa</title>

    <indexterm zone="sql-syntax-strings">
     <primary>stringa di caratteri</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     <indexterm>
      <primary>virgolette</primary>
      <secondary>escape</secondary>
     </indexterm>
Una costante stringa in SQL è una sequenza di caratteri arbitraria
racchiusa in apici singoli (<literal>'</literal>), per esempio 
<literal>'Questa è una stringa'</literal>.  Per includere
un carattere di singolo apice all'interno di una costante stringa,
scrivere due apici singoli adiacenti, per es.,
<literal>'Dianne''s horse'</literal>.
Notare che questo <emphasis>non</emphasis> è lo stesso di un carattere 
doppio apice (<literal>"</literal>).
    </para>

    <para>
Due costanti stringa che sono separate solamente da spazi bianchi 
<emphasis>con al meno una nuova linea</emphasis> sono concatenate
e trattate effettivamente come se la stringa sia stata scritta come una 
costante. Per esempio:
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
è equivalente a:
<programlisting>
SELECT 'foobar';
</programlisting>
     ma:
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
Non è sintassi valida. (Questo comportamento un po' bizzarro è specificato 
da <acronym>SQL</acronym>;  <productname>PostgreSQL</productname> segue lo standard).
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
    <title>Costanti striga con escape in stile C</title>

     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>

    <para>
<productname>PostgreSQL</productname> accetta anche costanti stringa di <quote>escape</quote>,
che sono un'estensione dello standard SQL.
Una costante stringa di escape viene specificata scrivendo la lettera 
<literal>E</literal> /in maiuscolo o minuscolo) appena prima dell'apertura del singolo apice,
per es., <literal>E'foo'</literal>. (Quando si continua una stringa di escape
attraverso linee, scrivere <literal>E</literal> solo prima dell'apertura del primo 
apice).
All'interno di una stringa di escape, un carattere barra inversa (<literal>\</literal>) indica
l'inizio di una sequenza <firstterm>backslash escape</firstterm> stile C, in cui la combinazione
della barra inversa e il seguente carattere/i rappresenta un valore speciale, 
come mostrato nella  <xref linkend="sql-backslash-table"/>.
    </para>

     <table id="sql-backslash-table">
      <title>Sequenze di escape con barre inverse</title>
      <tgroup cols="2">
      <thead>
       <row>
        <entry>Sequenza di escape con barra inversa</entry>
        <entry>Interpretazione</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
        <entry>backspace</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
        <entry>form feed</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>nuova linea</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>ritorno carrello</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>tab</entry>
       </row>
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
        <entry>valore ottale di byte</entry>
       </row>
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>valore esadecimale di byte</entry>
       </row>
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>valore esadecimale di carattere Unicode a 16 or 32-bit</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>
Qualsiasi altro
carattere che segue una barra inversa viene preso letteralmente. Per questo,
per includere un carattere di barra inversa, scrivere due barre inverse (<literal>\\</literal>).
Inoltre, in una stringa di escape può esssere incluso un singolo apice scrivendo
<literal>\'</literal>, in aggiunta al normale modo <literal>''</literal>.
    </para>

    <para>
È propria responsabilità che le sequenze di byte create,
specialmente quando si usano escape ottali o esadecimali, compongano
caratteri validi nella codifica di caratteri del server. Quando la codifica del server è 
UTF-8, allora dovrebbero essere usati escape Unicode o la sintassi di escape alternativa Unicode, spiegata in 
<xref linkend="sql-syntax-strings-uescape"/>.
(L'alternativa sarebbe usare codifica UTF-8 a mano e scrivere
i byte, ,a sarebbe molto ingombrante).
    </para>

    <para>
La sintassi escape Unicode funziona a pieno solo quando la codifica del server 
è <literal>UTF8</literal>.  Quando sono usate altre codifiche del server,
possono essere specificati solo codici nell'intervallo ASCII (fino
a <literal>\u007F</literal>). Sia la forma a 4 cifre che quella a 8 cifre 
possono essere usate per specificare coppie surrogate UTF-16 per comporre
caratteri con codici maggiori di U+FFFF, anche se 
la disponibilità della forma a 8 cifre tecnicamente lo rende non necessario.
(Quando coppie surrogate sono usate con server codificati <literal>UTF8</literal>,
vengono prima combinate in singoli codici che poi sono codificate in UTF-8).
    </para>

    <caution>
    <para>
Se il parametro di configurazione 
<xref linkend="guc-standard-conforming-strings"/> è <literal>off</literal>,
allora <productname>PostgreSQL</productname> riconosce escape backslash 
sia in costanti stringa normali che escape. Comunque, a partire da 
<productname>PostgreSQL</productname> 9.1, in maniera predefinita sarà impostato <literal>on</literal>, ciò
significa che escape backslash sono riconosciuti solo in costanti stringa di escape.
Questo comportamento è più attinente allo standard, ma potrebbe rompere applicazioni
che si basano sul comportamento storico, dove gli escape backslash erano sempre riconosciuti.
Come workaround, è possibile impostare questo parametro 
a <literal>off</literal>, ma è meglio abituarsi a non usare escape backslash.
Se si ha bisogno di usare l'escape backslash per rappresentare un carattere speciale, 
scrivere la costante stringa con una <literal>E</literal>.
    </para>

    <para>
In aggiunta a <varname>standard_conforming_strings</varname>, i parametri di configurazione
<xref linkend="guc-escape-string-warning"/> e 
<xref linkend="guc-backslash-quote"/> governano il trattamento delle barre inverse
nelle costanti stringa.
    </para>
    </caution>

    <para>
Il carattere con il codice zero non può apparire in una costante stringa.
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
    <title>Costanti stringa con escape Unicode</title>

    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>escape Unicode</primary>
     <secondary>in costanti stringa</secondary>
    </indexterm>

    <para>
<productname>PostgreSQL</productname> supporta anche un altro tipo di 
sintassi di escape per stringhe che permette di specificare caratteri arbitrari Unicode
attraverso il codice. Una stringa costante di escape Unicode 
comincia con <literal>U&amp;</literal> (lettera U maiuscola o minuscola seguita 
da e commerciale) immediatamente prima l'apice di apertura. senza spazi tra di loro,
per esempio <literal>U&amp;'foo'</literal>. (Notare che questo crea un'ambiguità
con l'operatore <literal>&amp;</literal>. Usare spazi intorno all'operatore per evitare 
questo problema). All'interno degli apici, possono essere spèecificati
caratteri Unicode in formato escape scrivendo una barra inversa seguita dal codice  a 
4 cifre esadecimali o alternativamente una barra inversa seguita da un segno più
seguito da un codice a sei cifre esadecimali. Per esempio,
la stringa <literal>'data'</literal> potrebbe essere scritta come 
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
Questo esempio scrive la parola russa <quote>slon</quote> (elefante)
in alfabeto cirillico.
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>

    <para>
Se si desidera usare un carattere di escape diverso dalla barra barra inversa, 
può essere specificato usando la clausola
<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
dopo la stringa, per esempio:
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
Il carattere di escape può essere qualsiasi singolo carattere diverso da 
una cifra esadecimale, il segno più, un apice singolo, un doppio apice, 
o un carattere di spazio.
    </para>

    <para>
La sintassi escape Unicode funziona solo quando la codifica del server è
<literal>UTF8</literal>. Quando sono usate altre codifiche per il server, 
possono essere specificati solo codici nell'intervallo ASCII (fino a <literal>\007F</literal>).
Possono essere usate sia la forma a 4 cifre che quella a 6 cifre per specificare
coppie surrogate UTF-16 per comporre caratteri con 
codici maggiori di U+FFFF, anche se la disponibilità della forma a 6 cifre
lo rende non necessario. (Quando coppie surrogate vengono usate con serve 
che utilizzano codifica <literal>UTF8</literal>, sono prima di tutto 
combinate in un singolo codice che poi viene codificato in UTF-8).
    </para>

    <para>
Comunque, la sintassi escape Unicode per costanti stringa funziona solo
quando il parametro di configurazione <xref linkend="guc-standard-conforming-strings"/>
è impostato ad on. Questo perchè altrimenti questa sintassi potrebbe condondere
client che effettuano il parsing di istruzioni SQL al punto da provocare
a injenction SQL e problemi di sicurezza simili. Se il parametro è 
impostasto ad off, questa sintassi sarà rifiutata generando un messaggio di errore.

    </para>

    <para>
Per includere il carattere di escape letteralmente nella stringa, scriverlo due volte.
    </para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
    <title>Costanti stringa quitate da dollari</title>

     <indexterm>
      <primary>quotare con dollaro</primary>
     </indexterm>

    <para>
Mentre la sintassi standard per specificare costanti stringa di solito è conveniente,
può essere difficile da capire quando la stringa desiderata
contiene moli singoli apici o barre inverse, dato che ognuna di queste deve
essere raddoppiata. Per permettere query più leggibili in quelle situazioni,
<productname>PostgreSQL</productname>   fornisce un altro modo, chiamato 
<quote>quotazione con dollari</quote>, per scrivere costanti stringa.
Una costante stringa quotata con dollari consiste di 
un segno dollaro (<literal>$</literal>), un <quote>tag</quote> di zero 
o più caratteri, un altro segno dollaro, una sequenza di caratteri arbitraria
che costituisce il contenuto della stringa, un segno dollaro, lo stesso tag che ha cominciato 
la sequenza, e un sengo dollaro. Per esempio, ecco due 
modi diversi di specificare la stringa <quote>Dianne's horse</quote>
usando la quotazione con dollari:
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
Si noti che all'interno della stringa quotata con dollari, i songoli apici possono essere
usati senza il bisogno di essere sottoposti ad escape. Effettivamente, nessun carattere
usato all'interno di una stringa quotata da dollari viene sottoposto ad escape: il contenuto della stringa è sempre
scritto letteralmente. Le barre inverse non sono speciali, e non lo sono nemmeno 
i segni dollaro, a meno che non siano parte di una sequenza corrispondente al tag d'apertura.
    </para>

    <para>
È possibile annidare costanti stringa quotate con dollari scegliendo tag diversi 
ad ogni livello di annidamento. Questo viene usato comunemente per scrivere 
definizioni di funzione. Per esempio:
<programlisting>
$function$
BEgin
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
Qui, la sequenza <literal>$q$[\t\r\n\v\\]$q$</literal> rappresenta una 
stringa quotata da dolarri <literal>[\t\r\n\v\\]</literal>, che 
sarà riconosciuta quando il corpo della funzione viene eseguito 
da <productname>PostgreSQL</productname>. Ma dal momento che la sequenza non corrisponde 
al delimitatore esterno della quotazione dollaro <literal>$function$</literal>, 
è solamente qualche carattere in più all'interno della costante per come la stringa 
esterna è concepita.
    </para>

    <para>
Il tag, se presente, di una stringa quotata da dollari, segue le stesse regole
di un identificatore non quotato, eccetto che non può contenere un segno dollaro.
I tage sono sensibili al case, così <literal>$tag$Contenuto della stringa$tag$</literal>
è corretto, ma <literal>$TAG$Contenuto della stringa$tag$</literal> non lo è.
    </para>

    <para>
Una stringa quotata da dollari che seque una parola chiave o un identificatore dev'essere
separata da essa da spazi bianchi; altrimenti il delimitatore di quotazione
sarebbe preso come parte del precedente identificatore.
    </para>

    <para>
La quotazione con dollari non fa parte dello standard SQL, ma spesso è un modo 
più conveniente di scrivere letterali stringa complicati rispetto alla sintassi
con singoli apici che aderisce allo standard. È particolarmente utile quando 
si rappresentano costanti stringa all'interno di altre costanti, come spesso è necessario 
in definizioni di funzioni procedurali. Con la sintassi a singolo apice, ogni barra inversa
nell'esempio sopra dovrebbe essere scritta come quattro barre inverse,
che sarebbero ridotte a due barre inverse nel parsing della costante stringa originale,
e quindi ad una quando viene ri-eseguito il parsing della costante stringa interna 
durante l'esecuzione della funzione.
    </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
    <title>Costanti stringa di bit</title>

    <indexterm zone="sql-syntax-bit-strings">
     <primary>stringa di bit</primary>
     <secondary>costante</secondary>
    </indexterm>

    <para>
Le costanti stringa di bit somigliano a costanti stringa regolari con una 
<literal>B</literal> (maiuscola o minuscola) immediatamente prima dell'apice di
apertura (senza spazi), per es.,
<literal>B'1001'</literal>.  I soli caratteri permessi all'interno di
costanti a stringa di bit sono <literal>0</literal> e 
<literal>1</literal>.
    </para>

    <para>
Alternativamente, le costanti stringa di bit possono essere specificate in notazione
esadecimale, usando una <literal>X</literal> in testa (maiuscola o minuscola),
per es., <literal>X'1FF'</literal>.  Questa notazione è equivalente a
una costante stringa di bit con quattro cifre binarie per ogni cifra esadecimale.
    </para>

    <para>
Tutt'e due le forme di costanti stringa di bit possono essere estese
su più linee nello stesso modo di costanti stringa regolari.
La quotazione con dollari non può essere usata in una costante stringa di bit.
    </para>
   </sect3>

   <sect3>
    <title>Costanti numeriche</title>

    <indexterm>
     <primary>numerica</primary>
     <secondary>costante</secondary>
    </indexterm>

    <para>
Le costanti numeriche sono accettate in queste forme:
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
dove <replaceable>digits</replaceable> è una o più cifre
(da 0 a 9). Deve esserci almeno una cifra prima o dopo il punto decimale,
se usato. Almeno una cifra deve seguire l'indicatore di esponente  (<literal>e</literal>), 
se presente. Non ci puà essere nessuno spazio o altro carattere incluso nella 
costante. Si noti che qualsiasi segno più o meno in testa non viene considerato 
parte della costante; è un operatore applicato alla costante.
    </para>

    <para>
Questi sono esempi di costanti numeriche valide:
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

    <para>
<indexterm><primary>integer</primary></indexterm>
<indexterm><primary>bigint</primary></indexterm>
<indexterm><primary>numeric</primary></indexterm>
Una costante numerica che non contiene nè un punto decimale e nemmeno un 
esponente viene supposto sia del tipo <type>integer</type> se il suo valore
rientra nel tipo <type>integer</type> (32 bit); altrimenti si presume 
essere del tipo <type>bigint</type> se il suo valore rientra 
nel tipo <type>bigint</type> (64 bit); altrimenti 
viene cosiderata di tipo <type>numeric</type>. Le costanti che contengono punti decimali
e/o esponenti sono sempre considerate essere del tipo 
<type>numeric</type>.
    </para>

    <para>
Il tipo di dato assegnato inizialmente a una costante numerica è solo
un punto di partenza per gli algoritmi di risoluzione del tipo. Nella maggior parte dei casi
la costante sarà forzata automaticamente al tipo appropriato 
in funzione del contesto. Quando necessario, è possibile forzare 
che un valore numerico sia interpretato come un tipo di dato specifico
convertendolo. <indexterm><primary>conversione di tipo</primary></indexterm>
Per esempio, è possibile forzare che un valore numerico sia trattato come 
<type>real</type> (<type>float4</type>) scrivendo:

<programlisting>
REAL '1.23'  -- stile stringa
1.23::REAL   -- stile PostgreSQL (storico)
</programlisting>

Questi effettivamente sono solo casi speciali delle notazioni di conversione 
discusse successivamente.
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
    <title>Costanti di altri tipi</title>

    <indexterm>
     <primary>tipo di dato</primary>
     <secondary>costante</secondary>
    </indexterm>

    <para>
Una costante di un tipo <emphasis>arbitrario</emphasis> può essere 
specificata usando una delle seguenti notazioni:
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
Il testo della costante stringa viene passato alla routine di conversione
per il tipo chiamato <replaceable>type</replaceable>. Il risultato
è una costante del tipo indicato. La conversione esplicita di tipo
può essere omessa se non c'è ambiguità sul tipo della costante (per esempio, 
quando è assegnata direttamente a una colonna di tabella), nel qual caso 
viene forzata automaticamente.
    </para>

    <para>
La costante stringa può essere scritta usando sia la normale notazione SQL
sia la quotazione con dollari.
    </para>

    <para>
È inoltre possibile specificare la forzatura a un tipo usando una sintassi simile
ad una funzione:
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
ma non tutti i nomi di tipo possono essere usati in questo modo; si veda <xref
linkend="sql-syntax-type-casts"/> per dettagli.
    </para>

    <para>
<note>
    <para>
        Nota per il revisore: TODO
    </para>
</note>
     The <literal>::</literal>, <literal>CAST()</literal>, and 
     function-call syntaxes can also be used to specify run-time type
     conversions of arbitrary expressions, as discussed in <xref
     linkend="sql-syntax-type-casts"/>.  To avoid syntactic ambiguity, the
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax can only be used to specify the type of a simple literal constant.
     Another restriction on the
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax is that it does not work for array types; use <literal>::</literal>
     or <literal>CAST()</literal> to specify the type of an array constant.
    </para>

    <para>
La sintassi <literal>CAST()</literal> è conforme a SQL. La sintassi
<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
è una generalizzazione dello standard: SQL specifica questa sintassi solo
per pochi tipi di dato, ma <productname>PostgreSQL</productname> la permette 
per tutti i tipi. La sintassi con
<literal>::</literal> è storica di <productname>PostgreSQL</productname>,
come la sintassi a chiamata di funzione.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
   <title>Operatori</title>

   <indexterm zone="sql-syntax-operators">
    <primary>operatore</primary>
    <secondary>syntassi</secondary>
   </indexterm>

   <para>
Un nome di operatore è una sequenza di caratteri, fino a <symbol>NAMEDATALEN</symbol>-1
(63 come predefinito), dal seguente elenco:
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

ci sono comunque alcune restrizioni sui nomi di operatore:
    <itemizedlist>
     <listitem>
      <para>
<literal>--</literal> e <literal>/*</literal> non possono apparire
nel nome di un operatore, dato che saranno presi come inizio di un commento.
      </para>
     </listitem>

     <listitem>
      <para>
Un nome di operatore comporto da molteplici caratteri non può terminare con <literal>+</literal> o <literal>-</literal>,
a meno che il nome contenga anche almeno uno di questi caratteri:
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
Per esempio, <literal>@-</literal> è un nome di operatore permesso,
ma <literal>*-</literal> no. Questa restrizione permette a 
<productname>PostgreSQL</productname> di effettuare il aprsing di query 
che rispettano lo standard SQL senza richiedere spazi tra i token.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
Quando si lavora con nomi di operatori SQL non standard, si avrà di solito bisogno
di separare operatori adiacenti con spazi per evitare ambiguità.
Per esempio, se si è definito un operatore unario di sinistra chiamato <literal>@</literal>,
non si puà scrivere <literal>X*@Y</literal>; si deve scrivere 
<literal>X* @Y</literal> per essere sicuri che
<productname>PostgreSQL</productname> lo legga come due nomi di operatore 
e non uno.
   </para>
  </sect2>

  <sect2>
   <title>Caratteri speciali</title>

  <para>
Alcuni caratteri che non sono alfanumerici hanno un significato speciale
che è diverso dall'essere un operatore. Dettagli sull'utilizzo possono essere 
trovati nel luogo dove il rispettivo elemento di sintassi è descritto.
Questa sezione esiste solo per notificarne l'esistenza e riassumere 
gli scopi di questi caratteri.

   <itemizedlist>
    <listitem>
     <para>
Un segno dollatro  (<literal>$</literal>) seguito da cifre viene usato
per rappresentare un parametro posizionale nel corpo di una definizione di funzione
o di una funzione preparata. In altri contesti il segno dollaro
può essere parte di un identificatore o di una costante stringa quotata con dollari.
     </para>
    </listitem>

    <listitem>
     <para>
Le parentesi tonde (<literal>()</literal>) hanno il loro solito significato 
di raggrupare espressioni ed esprimere le precedenze. In alcuno casi
le parentesi sono richieste come parte della sintassi fissata di 
un particolare comando SQL.
     </para>
    </listitem>

    <listitem>
     <para>
Le parentesi quadre (<literal>[]</literal>) vengono usate per selezionare elementi
di un array. Si veda <xref linkend="arrays"/> per maggiori informazioni sugli array.
     </para>
    </listitem>

    <listitem>
     <para>
Le virgole (<literal>,</literal>) sono usate in alcuni costrutti 
sintattici per separare gli elementi di un elenco.
     </para>
    </listitem>

    <listitem>
     <para>
Il punto e virgola (<literal>;</literal>) termina un comando SQL.
Non può apparire all'interno di un comando, eccetto all'interno di una 
costante stringa o indetificatore quotato.
     </para>
    </listitem>

    <listitem>
     <para>
I due punti (<literal>:</literal>) sono usati per selezionare
<quote>fette</quote> di un array. (Si veda <xref
linkend="arrays"/>). In certi dialetti SQL (tipo Embedded SQL), 
i due punti sono usati come prefisso per i comi di variabili.
     </para>
    </listitem>

    <listitem>
     <para>
L'asterisco (<literal>*</literal>) viene usato in alcuni contesti per denotare
tutti i campi della riga di una tabella o valori composti. Ha inoltre
un significato speciale quando usato come argomento di una funzione aggregata,
cioè che l'aggregata non richiede nessun parametro esplicito.
     </para>
    </listitem>

    <listitem>
     <para>
Il punto (<literal>.</literal>) viene usato in costanti numeriche,
e per separare nomi di schemi, tabelle e colonne.
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
   <title>Commenti</title>

   <indexterm zone="sql-syntax-comments">
    <primary>commento</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>

   <para>
    A comment is a sequence of characters beginning with
Un commento è una sequenza di caratteri che cominciano con 
    double dashes and extending to the end of the line, e.g.:
doppi trattini e si estende fino alla fine della linea, per es.:
<programlisting>
-- This is a standard SQL comment
</programlisting>
   </para>

   <para>
In alternativa, possono essere usati commenti stile C:
<programlisting>
/* multiline comment
 * with nesting: /* nested block comment */
 */
</programlisting>
dove il commento inizia con <literal>/*</literal> e si estende fino all'occorrenza corrispondente
<literal>*/</literal>. Questi blocchi di commenti possono essre annidati, come specificato nello standard SQL
ma non dal C, così è possibile commentare blocchi di commenti più grandi di codice che potrebbe 
contenere blocchi di commenti.
   </para>

   <para>
Un commento viene rimosso dallo stream di input prima di ulteriori analisi di sintassi 
e viene effettivamente sostituito da spazi bianchi.
   </para>
  </sect2>

  <sect2 id="sql-precedence">
   <title>Precedenza lessicale</title>

   <indexterm zone="sql-precedence">
    <primary>operatore</primary>
    <secondary>precedenza</secondary>
   </indexterm>

   <para>
<note>
    <para>
        Nota per il revisore: TODO
    </para>
</note>
    <xref linkend="sql-precedence-table"/> shows the precedence and
    associativity of the operators in <productname>PostgreSQL</productname>.
    Most operators have the same precedence and are left-associative.
    The precedence and associativity of the operators is hard-wired
    into the parser.  This can lead to non-intuitive behavior; for
    example the Boolean operators <literal>&lt;</literal> and
    <literal>&gt;</literal> have a different precedence than the Boolean
    operators <literal>&lt;=</literal> and <literal>&gt;=</literal>.  Also, you will
    sometimes need to add parentheses when using combinations of
    binary and unary operators.  For instance:
<programlisting>
SELECT 5 ! - 6;
</programlisting>
sarà sottoposto a parsing come:
<programlisting>
SELECT 5 ! (- 6);
</programlisting>
    because the parser has no idea &mdash; until it is too late
    &mdash; that <token>!</token> is defined as a postfix operator,
    not an infix one.  To get the desired behavior in this case, you
    must write:
<programlisting>
SELECT (5 !) - 6;
</programlisting>
Questo è il prezzo che si paga per l'estendibilità.
   </para>

   <table id="sql-precedence-table">
    <title>Precedenza degli operatori (decrescente)</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Operatore/Elemento</entry>
       <entry>Associatività</entry>
       <entry>Descrizione</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
       <entry>sinistra</entry>
       <entry>separatore di nomi di  tabella/colonna</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
       <entry>sinistra</entry>
       <entry>cast di tipo in stile <productname>PostgreSQL</productname></entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>sinistra</entry>
       <entry>selezione di elemento di un array</entry>
      </row>

      <row>
       <entry><token>-</token></entry>
       <entry>destra</entry>
       <entry>meno unario</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
       <entry>sinistra</entry>
       <entry>esponenziale</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>sinistra</entry>
       <entry>moltiplicazione, divisione, modulo</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>sinistra</entry>
       <entry>addizione, sottrazione</entry>
      </row>

      <row>
       <entry><token>IS</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS UNKNOWN</literal>, <literal>IS NULL</literal></entry>
      </row>

      <row>
       <entry><token>ISNULL</token></entry>
       <entry></entry>
       <entry>test per null</entry>
      </row>

      <row>
       <entry><token>NOTNULL</token></entry>
       <entry></entry>
       <entry>test per non null</entry>
      </row>

      <row>
       <entry>(qualsiasi altro)</entry>
       <entry>sinistra</entry>
       <entry>tutti gli altri operatori nativi e definiti dall'utente</entry>
      </row>

      <row>
       <entry><token>IN</token></entry>
       <entry></entry>
       <entry>appartenenza all'insieme</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token></entry>
       <entry></entry>
       <entry>appartenenza all'intervallo</entry>
      </row>

      <row>
       <entry><token>OVERLAPS</token></entry>
       <entry></entry>
       <entry>sovrapposizione dell'intervallo di tempo</entry>
      </row>

      <row>
       <entry><token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <entry>corrispondenza di modelli di stringa</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token></entry>
       <entry></entry>
       <entry>minore di, maggiori di</entry>
      </row>

      <row>
       <entry><token>=</token></entry>
       <entry>destra</entry>
       <entry>uguaglianza, assegniazione</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
       <entry>destra</entry>
       <entry>negazione logica</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
       <entry>sinistra</entry>
       <entry>congiunzione logica</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
       <entry>sinistra</entry>
       <entry>disgiunzione logica</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
Natare che le regole di precedenza degli operatori si applicano anche a operatori 
definiti dall'utente che hanno gli stessi nomi degli operatori inclusi 
menzionati sopra. Per esempio, se si definisce un operatore
<quote>+</quote> per qualche tipo di dato personalizzato, esso avrà la stessa precedenza
dell'operatore incluso <quote>+</quote>,
non importa cosa faccia.
   </para>

   <para>
Quando un operatore qualificato da schema viene usato nella 
sintassi <literal>OPERATOR</literal>, come per esempio in:
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
il costrutto <literal>OPERATOR</literal> è assunto avere la precedenza predefinita
mostrata nella <xref linkend="sql-precedence-table"/> per l'operatore <quote>qualsiasi altro</quote>. Questo è vero
qualunque sia l'operatore specificato all'interno di <literal>OPERATOR()</literal>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
  <title>Espressioni di valore</title>

  <indexterm zone="sql-expressions">
   <primary>espressione</primary>
   <secondary>sintassi</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
   <primary>espressione di valore</primary>
  </indexterm>

  <indexterm>
   <primary>scalare</primary>
   <see>espressione</see>
  </indexterm>

  <para>
Le espressioni di valore sono usate in contesti vari, come 
nell'elenco di destinazioni del comando <command>SELECT</command>,
nuovi valori per colonne nell'<command>INSERT</command> o 
<command>UPDATE</command>, o in condizioni di ricerca di diversi comandi.
Il risultato di un'espressione di valore a volte è chiamato
<firstterm>scalare</firstterm>, per distinguerlo dal risultato di
un'espressione di tabella (che è una tabella). Le espressioni di valore sono 
anche chiamate <firstterm>espressioni scalari</firstterm> (o 
anche semplicemente <firstterm>espressioni</firstterm>). La sintassi 
delle espressioni permette il calcolo di valori da parti primitive usando 
operazioni aritmetiche, logiche, su insiemi, ed altre.
  </para>

  <para>
Un valore di espressione è uno dei seguenti:

   <itemizedlist>
    <listitem>
     <para>
Un valore costante o letterale
     </para>
    </listitem>

    <listitem>
     <para>
Un riferimento di colonna
     </para>
    </listitem>

    <listitem>
     <para>
Un riferimento posizionale a un parametro, nel corpo di una definizione di funzione
o istruzione preparata
     </para>
    </listitem>

    <listitem>
     <para>
Un'espressione sottoscritta
     </para>
    </listitem>

    <listitem>
     <para>
Un'espressione di selezione di campo
     </para>
    </listitem>

    <listitem>
     <para>
Un'invocazione di operatore
     </para>
    </listitem>

    <listitem>
     <para>
Una chiamata a funzione
     </para>
    </listitem>

    <listitem>
     <para>
Un'espressione aggregata
     </para>
    </listitem>

    <listitem>
     <para>
Una chiamata a una funzione finestra
     </para>
    </listitem>

    <listitem>
     <para>
Una conversione di tipo
     </para>
    </listitem>

    <listitem>
     <para>
Una sottoquery scalare
     </para>
    </listitem>

    <listitem>
     <para>
Un costruttore di array
     </para>
    </listitem>

    <listitem>
     <para>
Un costruttore di riga
     </para>
    </listitem>

    <listitem>
     <para>
Un'altra espressione di valore in parentesi (usata per raggrupare
sottoespressioni e sovrascrivere
la precedenza delle <indexterm><primary>parentesi</primary></indexterm>)
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
In aggiunta  a questo elenco, ci sono altri construttori che possono 
essere classificati come un'espressione ma non seguono nessuna regola generale di sintassi.
Queste generalmente hanno la semantica fi una funzione o 
operatore e sono spiegate nella sezione apposita in <xref
linkend="functions"/>. Un esempio è la clausola <literal>IS NULL</literal>.
  </para>

  <para>
Le costanti sono già state discusse in <xref
linkend="sql-syntax-constants"/>. Nelle sezioni seguenti vengono discusse
le opzioni rimanenti.
  </para>

  <sect2>
   <title>Riferimenti di colonna</title>

   <indexterm>
    <primary>riferimento di colonna</primary>
   </indexterm>

   <para>
Ci si può riferire a una colonna nella forma:
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>

   <para>
<replaceable>correlation</replaceable> è il nome di una tabella 
(possibilimente qualificata con il nome di uno schema), o un alias per una tabella
definita dai significati di una clausola <literal>FROM</literal>.
Il nome della correlazione e il punto di separazione possono essere omessi se il nome della colonna
è unico fra tutte le tabelle usate nella query corrente. (Si veda anche <xref linkend="queries"/>).
   </para>
  </sect2>

  <sect2>
   <title>Parametri posizionali</title>

   <indexterm>
    <primary>parametro</primary>
    <secondary>syntassi</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
Un riferimento a parametro posizionale viene usato per indicare un valore
che è fornito esternamente a un'istruzione SQL. I parametri sono
usati in definizioni di funzioni SQL e in query preparate. Alcune librerie  
client supportano anche la specificazione di valori separatamente 
dalla stringa di comando SQL, nel qual caso i parametri sono usati per 
riferirsi a valori di dati fuori-della-linea.
La forma di un riferimento a parametro è:
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>

   <para>
Per esempio, considerare la definizione di una funzione, 
<function>dept</function>, come:


<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

Qui, <literal>$1</literal> si riferisce al valore del primo argomento di 
funzione nel momento che la funzione viene invocata.
   </para>
  </sect2>

  <sect2>
   <title>Sottoscript</title>

   <indexterm>
    <primary>sottoscript</primary>
   </indexterm>

   <para>
Se un'espressione restituisce un valore di tipo array, allora è possibile estrarre
un elemento specifico dell'array scrivendo 
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
o possono essere estratti molteplici elementi adiacenti (una <quote>fetta di array</quote>) 
scrivendo
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
(Qui, le parentesi quadre <literal>[ ]</literal> sono intese per apparire letteralmente).
Ogni <replaceable>subscript</replaceable> è di per sè un'espressione, 
che deve restituire un valore intero.
   </para>

   <para>
<note>
    <para>
        Nota per il revisore: TODO
    </para>
</note>
    In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

Le parentesi nell'ultimo esempio sono richieste.
Si veda <xref linkend="arrays"/> per maggiori informazioni sugli array.
   </para>
  </sect2>

  <sect2>
   <title>Selezione di campi</title>

   <indexterm>
    <primary>selezione di campo</primary>
   </indexterm>

   <para>
Se un'espressione restituisce un valore di un tipo composto (tipo riga), allora un 
campo specifico della riga può essere estratto scrivendo
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>

   <para>
In generale la riga <replaceable>expression</replaceable> deve essere
messa tra parentesi, ma le parentesi possono essere omesse quando l'espressione
da essere selezionata  è semplicemente un riferimento a una tabella o un parametro posizionale.
Per esempio:

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

(Per questo, un riferimento qualificato a una colonna attualmente è solo un caso speciale
della sintassi di selezione campo). Un caso speciale importante è 
l'estrazione di un campo da una colonna di tabella che è di tipo composto:

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

Qui le parentesi sono necessarie per mostrare che 
<structfield>compositecol</structfield> è un nome di colonna è non il nome di una tabella, 
o che <structname>mytable</structname> è il nome di una tabella e non il nome di uno schema
nel secondo caso.
   </para>
  </sect2>

  <sect2>
   <title>Invocazioni di operatore</title>

   <indexterm>
    <primary>operatore</primary>
    <secondary>invocazione</secondary>
   </indexterm>

   <para>
Ci sono tre possibili sintassi per l'invocazione di un operatore:
    <simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (binary infix operator)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (unary prefix operator)</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> (unary postfix operator)</member>
    </simplelist>
dove il token <replaceable>operator</replaceable> segue le regole sintattiche 
di <xref linkend="sql-syntax-operators"/>, o è una delle parole chiave 
<token>AND</token>, <token>OR</token> o <token>NOT</token>, 
o è il nome di un operatore qualificato nella forma:
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operatorname</replaceable><literal>)</literal>
</synopsis>
Quali particolari operatori esistono e se
sono unari o binari dipernde da quali operatori sono stati definiti 
dal sistema o dall'utente. <xref linkend="functions"/>
descrive gli operatori inclusi.
   </para>
  </sect2>

  <sect2>
   <title>Chiamate di funzione</title>

   <indexterm>
    <primary>funzione</primary>
    <secondary>invocazione</secondary>
   </indexterm>

   <para>
La sintassi per una chiamata di funzione è il nome di una funzione
(possibilmente qualificato con il nome di uno schema) seguito dal suo elenco di argomenti
racchiuso tra parentesi:

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>

   <para>
Per esempio, la seguenta calcola la radice quadrata di 2:
<programlisting>
sqrt(2)
</programlisting>
   </para>

   <para>
L'elenco delle funzioni incluse si trova in <xref linkend="functions"/>.
Altre funzioni possono essere aggiunte dall'utente.
   </para>

   <para>
Gli argomenti possono opzionalmente avere nomi attaccati.
Si veda <xref linkend="sql-syntax-calling-funcs"/> per dettagli.
   </para>
  </sect2>

  <sect2 id="syntax-aggregates">
   <title>Espressioni aggregate</title>

   <indexterm zone="syntax-aggregates">
    <primary>funzione aggregata</primary>
    <secondary>invocazione</secondary>
   </indexterm>

   <para>
Una <firstterm>espressione aggregata</firstterm> rappresenta l'applicazione
di una funzione aggregata attraverso le righe selezionate da una query. 
Una funzione aggregata riduce input multipli a un singolo 
valore di output, come la somma o la media degli input. La 
sintassi di un'espressione aggregata è una delle seguenti:

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )
<replaceable>aggregate_name</replaceable> ( * )
</synopsis>

dove <replaceable>aggregate_name</replaceable> è un'aggregata definita
precedentemente (possibilmente qualificata con il nome di uno schema),
<replaceable>expression</replaceable> è qualsiasi espressione di valore
che di per sè non contiene un'espressione aggregata o una chiamata a funzione 
finestra, e <replaceable>order_by_clause</replaceable> è una clausola 
<literal>ORDER BY</literal> come descritto sotto.
   </para>

   <para>
La prima forma di espressione aggregata invoca l'aggregata 
una volta per ogni riga di input.
La seconda forma è uguale alla prima, dato che 
<literal>ALL</literal> è il predefinito.
La terza forma invoca l'aggregata una volta per ogni valore distinto
dell'espressione (o insieme distinto di valori, per molteplici espressioni)
trovato nelle righe di input.
L'ultima forma invoca l'aggregata una volta per ogni riga di input; dato che
non è specificato nessun particolare valore di input, generalmente è utile
solo per la funzione aggregata <function>count(*)</function>.
   </para>

   <para>
La maggior parte delle funzioni aggregate ignorano input null, così quelle righe
nelle quali una o più espressione/i restituisce null sono scartate. Possiamo assumere questo come vero,
a meno che non sia diversamente specificato, per 
tutte le aggregate incluse.
   </para>

   <para>
Per esempio, <literal>count(*)</literal> restituisce il numero totale
di righe di input; <literal>count(f1)</literal> restituisce il numero di 
righe di input nelle quali <literal>f1</literal> non è null, dato che 
<function>count</function> ignora i valori null; e 
<literal>count(distinct f1)</literal> restituisce il numero di
valori non null distinti di  <literal>f1</literal>.
   </para>

   <para>
Di solito, le righe di input sono date in pasto alla funzione aggregata in ordine sparso.
In molti casi questo non ha importanza; per esempio,
<function>min</function> produce lo stesso risultato a prescindere dall'ordine
in cui riceve gli input. Comunque, alcune funzioni aggregate
(tipo <function>array_agg</function> e <function>string_agg</function>) producono
risultati che dipendono dall'ordinamento delle righe di input. Quando si usa un'aggregata
del genere, è possibile usare <replaceable>order_by_clause</replaceable> per specificare 
l'ordinamento desiderato. <replaceable>order_by_clause</replaceable> ha 
la stessa sintassi di una clausola <literal>ORDER BY</literal> a livello di query, come 
descritto in  <xref linkend="queries-order"/>, ad eccezione che le sue espressioni 
sono sempre soltanto espressioni e non possono essere nomi di colonne di output o numeri.
Per esempio:
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>

   <para>
Quando si ha a che fare con funzioni aggregate che hanno molteplici argomenti, notare che
la clausola <literal>ORDER BY</literal> va dopo tutti gli argomenti dell'aggregata.
Per esempio, scrivere:
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
    non:
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- non corretto
</programlisting>
L'ultimo è sintatticamente valido, ma rappresenta una chiamata di una funzione
aggregata con singolo argomento con due chiavi <literal>ORDER BY</literal>
(la seconda è abbastanza inutile dato che è una costante).
   </para>

   <para>
Se viene specificato <literal>DISTINCT</literal> in aggiunta a una 
<replaceable>order_by_clause</replaceable>, allora tutte le espressioni <literal>ORDER BY</literal>
devono corrispondere a argomenti dell'aggregata; cioè,
non è possibile ordinare in base a un'espressione che non  è inclusa nell'elenco 
<literal>DISTINCT</literal>.
   </para>

   <note>
    <para>
L'abilità di specificare sia <literal>DISTINCT</literal> che <literal>ORDER BY</literal>
in una funzione aggregata è un'estensione di <productname>PostgreSQL</productname>
    </para>
   </note>

   <para>
Le funzioni aggregate predefinite sono descritte in <xref
linkend="functions-aggregate"/>. Altre funzioni aggregate possono essere aggiunte 
dall'utente.
   </para>

   <para>
Un'espressione aggregata può apparire solo nell'elenco  risultatante o nella clausola  
<literal>HAVING</literal> di un comando <command>SELECT</command>.
È proibito in altre clausole, tipo la <literal>WHERE</literal>,
dato che queste clausole sono valutate logicamente prima che siano formati i risultati
delle aggregate.
   </para>

   <para>
Quando un'espressione aggregata appare in una sottoquery (si veda
<xref linkend="sql-syntax-scalar-subqueries"/> e
<xref linkend="functions-subquery"/>), l'aggregata è valutata normalmente
sulle righe della sottoquery. Viene generata un'eccezione 
se gli argomenti dell'aggregata contengono solo variabili di livello esterno:
l'aggregata quindi appartiene al livello esterno più vicino, ed è 
valutata sulle righe della query. L'espressione aggregata 
in totale è quindi un riferimento esterno per la sottoquery nella quale appare,
e agisce come una costante su ogni valutazione di quella sottoquery. 
La restrizione di 
apparire solo nell'elenco risultante o nella clausola <literal>HAVING</literal>
viene applicata a livello della query alla aquale l'aggregata appartiene. 
   </para>
  </sect2>

  <sect2 id="syntax-window-functions">
   <title>Chiamate a funzioni finestra</title>

   <indexterm zone="syntax-window-functions">
    <primary>funzione finestra</primary>
    <secondary>invocazione</secondary>
   </indexterm>

   <indexterm zone="syntax-window-functions">
    <primary>clausola OVER</primary>
   </indexterm>

   <para>
Una <firstterm>chiamata di funzione finestra</firstterm> rappresenta l'applicazione
di una funzione simil-aggregata su qualche porzione delle righe selezionate dalla query.
A differenza delle chiamate alle normali funzioni aggregate, questo non è legato   
al raggruppamento delle righe selezionate in una singola riga di output - ogni riga 
rimane separata nell'output della query. Comunque la funzione finestra
è capace di eseguire lo scan di tutte le righe che sarebbero parte  del gruppo della 
riga corrente in accordo con la specifica di raggrupamento (elenco <literal>PARTITION BY</literal>)
della chiamata a funzione finestra.
La sintassi di una chiamata a funzione finestra è una delle seguenti:

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) OVER <replaceable>window_name</replaceable>
</synopsis>
dove <replaceable class="parameter">window_definition</replaceable>
ha la sintassi
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
e l'opzionale <replaceable class="parameter">frame_clause</replaceable>
può essere una tra
<synopsis>
[ RANGE | ROWS ] <replaceable>frame_start</replaceable>
[ RANGE | ROWS ] BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable>
</synopsis>
dove <replaceable>frame_start</replaceable> e <replaceable>frame_end</replaceable> possono essere
una tra
<synopsis>
UNBOUNDED PRECEDING
<replaceable>value</replaceable> PRECEDING
CURRENT ROW
<replaceable>value</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
   </para>

   <para>
Qui, <replaceable>expression</replaceable> rappresenta qualsiasi espressione di valore
che di per sè non contiene chiamate a funzioni finestra. 
Gli elenchi <literal>PARTITION BY</literal> e <literal>ORDER BY</literal> hanno
essenzialmente la stessa sintassi e semantica delle clausole <literal>GROUP BY</literal>
e <literal>ORDER BY</literal> dell'intera query, ad eccezione che le loro 
espressioni sono sempre soltanto espressioni e non possono essere nomi di colonne di output 
o numeri.    
<replaceable>window_name</replaceable> è un riferimento a una specificazione di finestra 
definita nella clausola <literal>WINDOW</literal> della query.
Specificazioni di finestra nominate sono di solito riferite con 
<literal>OVER</literal> <replaceable>window_name</replaceable>, ma è possibile anche
scrivere il nome di una finestra tra parentesi e quindi opzionalmente fornire 
una clausola di ordinamento e/o clausa di cornice (la finestra referenziata 
non deve avere queste clausole, se esse sono fornite qui).
Quest'ultima sintassi segue le stesse regole per la modifica di un nome di finestra esistente  
all'interno della clausola <literal>WINDOW</literal>; si veda la pagina di riferimento 
<xref linkend="sql-select"/> per dettagli.
   </para>

   <para>
La <replaceable class="parameter">frame_clause</replaceable> specifica 
l'insieme di righe che costituiscono la <firstterm>cornice di finestra</firstterm>, per quelle
funzioni finestra che agiscono sulla cornice invece che sull'intera finestra. 
Se <replaceable>frame_end</replaceable> viene omesso viene preso come predefinito <literal>CURRENT
ROW</literal>.  Restrizioni sono che
<replaceable>frame_start</replaceable> non può essere <literal>UNBOUNDED FOLLOWING</literal>,
<replaceable>frame_end</replaceable> non può essere <literal>UNBOUNDED PRECEDING</literal>,
e la scelta <replaceable>frame_end</replaceable> non può apparire prima della scelta 
<replaceable>frame_start</replaceable> nell'elenco sopra - per esempio
<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</replaceable>
PRECEDING</literal> non è consentito.
L'opzione predefinita per la definizione della cornice è <literal>RANGE UNBOUNDED PRECEDING</literal>,
che è lo stesso di <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
CURRENT ROW</literal>; essa imposta la cornice per essere composta da tutte le righe dall'inizio
della partizione in su fino alla riga corrente nell'ordinamento <literal>ORDER BY</literal>
(che significa tutte le righe se non c'è <literal>ORDER BY</literal>).
In generale, <literal>UNBOUNDED PRECEDING</literal> significa che la cornice 
comincia con la prima riga della partizione, e similmente 
<literal>UNBOUNDED FOLLOWING</literal> significa che la cornice termina con l'ultima riga della partizione
(a prescindere dalla modalità <literal>RANGE</literal> o <literal>ROWS</literal>).
In modalità <literal>ROWS</literal>, <literal>CURRENT ROW</literal>
significa che la cornice comincia o finisce con la riga corrente; ma in modalità
<literal>RANGE</literal> significa che la cornice somincia o finisce con 
il primo o ultimo pari della riga corrente nell'ordinamento <literal>ORDER BY</literal>.
I casi <replaceable>value</replaceable> <literal>PRECEDING</literal> e
<replaceable>value</replaceable> <literal>FOLLOWING</literal> sono attualmente permessi solo 
in modalità <literal>ROWS</literal>. Essi indicano che la cornice comincia
o finisce con la riga quelle tante righe prima o dopo la corrente.
<replaceable>value</replaceable> dev'essere un'espressione intera non contenente
variabili,  funzioni aggregate, o funzioni finestra.
Il valore non deve essere null o negativo; ma può essere zero, che seleziona 
la riga corrente.
   </para>

   <para>
Le funzioni finestra incluse sono descritte nella <xref
linkend="functions-window-table"/>. Altre funzioni finestra possono essere aggiunte dall'utente.
In più, qualsiasi funzione aggregata inclusa o definita dall'utente può essere
usata come funzione finestra.
   </para>

   <para>
Le sintassi che usano <literal>*</literal> sono usate per chiamare funzioni 
aggregate senza parametri tipo funzioni finestra, per esempio
<literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>.
Di norma <literal>*</literal> non è usato per funzioni finestra non aggregate.
Funzioni fiestra aggregate, a differenza di funzioni aggregate normali, non permettono
l'utilizzo di <literal>DISTINCT</literal> o <literal>ORDER BY</literal> all'interno
dell'elenco degli argomenti di funzione.
   </para>

   <para>
Chiamate a funzioni finestra sono permesse sono nell'elenco <literal>SELECT</literal>
e nella clausola <literal>ORDER BY</literal> della query.
   </para>

   <para>
Maggiori informazioni sulle funzioni finestra possono essere trovate in
<xref linkend="tutorial-window"/>,
<xref linkend="functions-window"/>,
<xref linkend="queries-window"/>.
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
   <title>Conversioni di tipo</title>

   <indexterm>
    <primary>tipo di dato</primary>
    <secondary>conversione di tipo</secondary>
   </indexterm>

   <indexterm>
    <primary>conversioni di tipo</primary>
   </indexterm>

   <indexterm>
    <primary>::</primary>
   </indexterm>

   <para>
Una conversione di tipo specifica una conversione da un tipo di dato ad un altro.
<productname>PostgreSQL</productname> accetta due sintassi equivalenti 
per conversioni di tipo:
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
La sintassi <literal>CAST</literal> è conforma a SQL; la sintassi con
<literal>::</literal> è storica di <productname>PostgreSQL</productname>.
   </para>

   <para>
Quando viene applicata una conversione a una espressione di valore di un tipo conosciuto,
essa rappresenta una conversione di tipo dirante l'esecuzione. La conversione avrà successo solo
se è stata definita un'operazione di conversione di tipo adatta. Considerare che 
questo è leggermente diverso dall'uso di conversioni con costanti, come visto 
in <xref linkend="sql-syntax-constants-generic"/>.  Una conversione applicata 
a stringhe letterali spoglie rappresenta l'assegnamento iniziale di un tipo
a un valore costante letterale, e così succederà per ogni tipo
(se il contenuto della stringa letterale è sintassi di input accettabile per il tipo di dato).
   </para>

   <para>
Un'esplicita conversione di tipo può, di solito, essere omessa se non c'è ambiguità 
sul tipo che un'espressione di valore deve produrre (per esempio, quando è 
assegnata a una colonna di tabella); il sistema applicherà automaticamente una
conversione di tipo in questi casi. Comunque, una conversione automatica viene fatta solo
per conversioni che sono indicate come <quote>OK to apply implicitly</quote>
nei cataloghi di sistema. Altre conversioni devono essere invocate con 
sintassi di conversione esplicita. Questa restrizione è intesa per prevenire
conversioni sorprendenti dall'essere applicate silenziosamente.
   </para>

   <para>
È anche possibile specificare una conversione di tipo usando una sintassi simile 
a una funzione:
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
In ogni caso, questo funziona solo per tipi i chui nomi sono validi anche come 
nomi di funzione. Per esempio, <literal>double precision</literal>
non può essere usato in questo modo, ma l'equivalente <literal>float8</literal>
può. Inoltre, i nomi <literal>interval</literal>, <literal>time</literal>, e
<literal>timestamp</literal> possono essere usati solo in questo modo se sono
espresse tra doppi apici, causa conflitti sintattici. Inoltre, l'uso di  
sintassi di conversione stile-funzione porta inconsistenza e dovrebbe essere 
evitato.
   </para>

   <note>
    <para>
La sintassi stile-funzione è di fatto semplicemente una chiamata di funzione. Quando
una delle due sintassi di conversione standard viene usata per compiere una conversione durante l'esecuzione,
sarà internamente invocata una funzione registrata per eseguire la 
conversione. Per convenzione, queste funzioni di  conversione 
hanno lo stesso nome del loro tipo di output, e così la <quote>sintassi stile-funzione</quote>
non è altro che un'invocazione diretta della funzione di conversione sottostante.
Ovviamente, un'applicazione portabile non dovrebbe usare questo comportamento.
Per ulteriori dettagli si veda 
<xref linkend="sql-createcast"/>.
    </para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
   <title>Scalar Subqueries</title>

   <indexterm>
    <primary>subquery</primary>
   </indexterm>

   <para>
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"/> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"/> for other expressions involving subqueries.
   </para>

   <para>
    For example, the following finds the largest city population in each
    state:
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
   <title>Array Constructors</title>

   <indexterm>
    <primary>array</primary>
    <secondary>constructor</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</literal>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</literal>.
    For example:
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</literal> or
    <literal>CASE</literal> constructs (see <xref linkend="typeconv-union-case"/>).
    You can override this by explicitly casting the array constructor to the
    desired type, for example:
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts"/>.
   </para>

   <para>
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result:

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</literal> constructor propagates
    automatically to all the inner constructors.
  </para>

  <para>
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</literal> construct.
    For example:
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

  <para>
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example:
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</programlisting>
  </para>

  <para>
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example:
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                          ?column?
-------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}
(1 row)
</programlisting>
   The subquery must return a single column. The resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column.
  </para>

  <para>
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays"/>.
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
   <title>Row Constructors</title>

   <indexterm>
    <primary>composite type</primary>
    <secondary>constructor</secondary>
   </indexterm>

   <indexterm>
    <primary>row type</primary>
    <secondary>constructor</secondary>
   </indexterm>

   <indexterm>
    <primary>ROW</primary>
   </indexterm>

   <para>
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example:
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
    The key word <literal>ROW</literal> is optional when there is more than one
    expression in the list.
   </para>

   <para>
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</literal> syntax is used at the top level
    of a <command>SELECT</command> list.  For example, if table <literal>t</literal> has
    columns <literal>f1</literal> and <literal>f2</literal>, these are the same:
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>

   <note>
    <para>
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded, so that writing
     <literal>ROW(t.*, 42)</literal> created a two-field row whose first field
     was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</literal>.
    </para>
   </note>

   <para>
    By default, the value created by a <literal>ROW</literal> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</command>.  An explicit cast might be needed
    to avoid ambiguity.  For example:
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- No cast needed since only one getf1() exists
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Now we need a cast to indicate which function to call:
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</programlisting>
  </para>

  <para>
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</literal> or <literal>IS NOT NULL</literal>, for example:
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows
</programlisting>
   For more detail see <xref linkend="functions-comparisons"/>.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery"/>.
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
   <title>Expression Evaluation Rules</title>

   <indexterm>
    <primary>expression</primary>
    <secondary>order of evaluation</secondary>
   </indexterm>

   <para>
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
   </para>

   <para>
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote:
<programlisting>
SELECT true OR somefunc();
</programlisting>
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote:
<programlisting>
SELECT somefunc() OR true;
</programlisting>
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages.
   </para>

   <para>
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</literal> and <literal>HAVING</literal> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
   </para>

   <para>
    When it is essential to force evaluation order, a <literal>CASE</literal>
    construct (see <xref linkend="functions-conditional"/>) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</literal> clause:
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
    But this is safe:
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
    A <literal>CASE</literal> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</literal> instead.)
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
  <title>Calling Functions</title>

   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> allows functions that have named
    parameters to be called using either <firstterm>positional</firstterm> or
    <firstterm>named</firstterm> notation.  Named notation is especially
    useful for functions that have a large number of parameters, since it
    makes the associations between parameters and actual arguments more
    explicit and reliable.
    In positional notation, a function call is written with
    its argument values in the same order as they are defined in the function
    declaration.  In named notation, the arguments are matched to the
    function parameters by name and can be written in any order.
   </para>

   <para>
    In either notation, parameters that have default values given in the
    function declaration need not be written in the call at all.  But this
    is particularly useful in named notation, since any combination of
    parameters can be omitted; while in positional notation parameters can
    only be omitted from right to left.
   </para>

   <para>
    <productname>PostgreSQL</productname> also supports
    <firstterm>mixed</firstterm> notation, which combines positional and
    named notation.  In this case, positional parameters are written first
    and named parameters appear after them.
   </para>

   <para>
    The following examples will illustrate the usage of all three
    notations, using the following function definition:
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
    Function <function>concat_lower_or_upper</function> has two mandatory
    parameters, <literal>a</literal> and <literal>b</literal>.  Additionally
    there is one optional parameter <literal>uppercase</literal> which defaults
    to <literal>false</literal>.  The <literal>a</literal> and
    <literal>b</literal> inputs will be concatenated, and forced to either
    upper or lower case depending on the <literal>uppercase</literal>
    parameter.  The remaining details of this function
    definition are not important here (see <xref linkend="extend"/> for
    more information).
   </para>

   <sect2 id="sql-syntax-calling-funcs-positional">
    <title>Using positional notation</title>

    <indexterm>
     <primary>function</primary>
     <secondary>positional notation</secondary>
    </indexterm>

    <para>
     Positional notation is the traditional mechanism for passing arguments
     to functions in <productname>PostgreSQL</productname>.  An example is:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
     All arguments are specified in order.  The result is upper case since
     <literal>uppercase</literal> is specified as <literal>true</literal>.
     Another example is:
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
     Here, the <literal>uppercase</literal> parameter is omitted, so it
     receives its default value of <literal>false</literal>, resulting in
     lower case output.  In positional notation, arguments can be omitted
     from right to left so long as they have defaults.
    </para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
    <title>Using named notation</title>

    <indexterm>
     <primary>function</primary>
     <secondary>named notation</secondary>
    </indexterm>

    <para>
     In named notation, each argument's name is specified using
     <literal>:=</literal> to separate it from the argument expression.
     For example:
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
     Again, the argument <literal>uppercase</literal> was omitted
     so it is set to <literal>false</literal> implicitly.  One advantage of
     using named notation is that the arguments may be specified in any
     order, for example:
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
   <title>Using mixed notation</title>

   <indexterm>
    <primary>function</primary>
    <secondary>mixed notation</secondary>
   </indexterm>

   <para>
    The mixed notation combines positional and named notation. However, as
    already mentioned, named arguments cannot precede positional arguments.
    For example:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    In the above query, the arguments <literal>a</literal> and
    <literal>b</literal> are specified positionally, while
    <literal>uppercase</literal> is specified by name.  In this example,
    that adds little except documentation.  With a more complex function
    having numerous parameters that have default values, named or mixed
    notation can save a great deal of writing and reduce chances for error.
   </para>
  </sect2>
 </sect1>

</chapter>

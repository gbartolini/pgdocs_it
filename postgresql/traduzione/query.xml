<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

 <chapter id="tutorial-sql">
  <title>Il linguaggio <acronym>SQL</acronym></title>

  <sect1 id="tutorial-sql-intro">
   <title>Introduzione</title>

   <para>
Questo capitolo fornisce una panoramica su come usare
<acronym>SQL</acronym> per realizzare semplici operazioni. Questo 
tutorial intende fornire solo un'introduzione e in nessun modo è da considerarsi 
un tutorial completo su <acronym>SQL</acronym>. Numerosi libri
sono stati scritti su <acronym>SQL</acronym>, tra questi <xref
linkend="MELT93"/> e <xref linkend="DATE97"/>.
Si dede essere consapevoli che alcune caratteristiche di <productname>PostgreSQL</productname>
sono estensioni dello standard.
   </para>

   <para>
Negli esempi che seguono, si presuppone che si sia creato un database 
chiamato <literal>mydb</literal>, come descritto nel precedente capitolo,
e si sia capaci di avviare <application>psql</application>.
   </para>

   <para>
Esempi possono essere trovati anche nella distribuzione del sorgente di 
<productname>PostgreSQL</productname> nella directory <filename>src/tutorial/</filename>.
(Le distribuzioni binare di <productname>PostgreSQL</productname> potrebbero non compilare
questi file). Per usare quei file, 
entrare in quella directory e lanciare <application>make</application>:

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/tutorial</userinput>
<prompt>$</prompt> <userinput>make</userinput>
</screen>

Questo crea gli script e compila i file C contenenti funzioni e tipo definiti dall'utente.
Quindi, per avviare il tutorial, fare:

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</userinput>
<prompt>$</prompt> <userinput>psql -s mydb</userinput>
<computeroutput>
...
</computeroutput>

<prompt>mydb=&gt;</prompt> <userinput>\i basics.sql</userinput>
</screen>

Il comando <literal>\i</literal> legge i comandi dal file specificato.
L'opzione di <command>psql</command> <literal>-s</literal> attiva la modalità "single step" 
che metterà in pausa prima di lanciare ogni istruzione. I comandi usati in questa sezione  
si trovano nel file 
<filename>basics.sql</filename>.
   </para>
  </sect1>


  <sect1 id="tutorial-concepts">
   <title>Concetti</title>

   <para>
    <indexterm><primary>database relazionale</primary></indexterm>
    <indexterm><primary>database gerarchico</primary></indexterm>
    <indexterm><primary>database orientato agli oggetti</primary></indexterm>
    <indexterm><primary>relazione</primary></indexterm>
    <indexterm><primary>tabella</primary></indexterm>

<productname>PostgreSQL</productname> è un <firstterm>sistema di gestione di database
relazionali</firstterm> (<acronym>RDBMS</acronym>).
Questo significa che è un sistema per la gestione di dati immagazzinati in
<firstterm>relazioni</firstterm>. La relazione essenzialmente è un termine 
matematico per definire una <firstterm>tabella</firstterm>. La nozione di
immagazzinare dati in tabelle è talmente comune oggi che potrebbe
sembrare ovvia, ma ci sono numerosi altri modi di organizzare un database.
File e directory su sistemi operativi della famiglia Unix sono un esempio di database gerarchico.
Uno sviluppo più moderno è il database orientato agli oggetti. 
   </para>

   <para>
    <indexterm><primary>riga</primary></indexterm>
    <indexterm><primary>colonna</primary></indexterm>

Ogni tabella è una collezione nominata di <firstterm>righe</firstterm>.
Ogni riga di una data tabella ha lo stesso insieme di <firstterm>colonne</firstterm> nominate
ed ogni colonna ha uno specifico tipo di dato. Mentre le colonne hanno
un ordine fissato in ogni riga, è importante ricordare che SQL non garantisce 
in nessun modo un ordine per le righe all'interno di una tabella 
(anche se possono essere ordinate esplicitamente per la visualizzazione).
   </para>

   <para>
    <indexterm><primary>cluster database</primary></indexterm>
    <indexterm><primary>cluster</primary><secondary>di database</secondary>
    <see>cluster database</see></indexterm>

Le tabelle sono raggruppate in database, e una raccolta di database
gestiti da una singola istanza server di <productname>PostgreSQL</productname>
costituisce un <firstterm>cluster</firstterm> di database.
   </para>
  </sect1>


  <sect1 id="tutorial-table">
   <title>Creare una nuova tabella</title>

   <indexterm zone="tutorial-table">
    <primary>CREATE TABLE</primary>
   </indexterm>

   <para>
È possibile creare una nuova tabella specificandone il nome, 
insieme a tutti i nomi di colonna e i loro tipi:

<programlisting>
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- low temperature
    temp_hi         int,           -- high temperature
    prcp            real,          -- precipitation
    date            date
);
</programlisting>

È possibile inserire questo all'interno di <command>psql</command> con le
interruzioni di linea. <command>psql</command> considererà il comando non terminato
fino a che non incontra un punto e virgola.
   </para>

   <para>
Gli spazi bianchi (per es., spazi, tabulature e accapo) possono essere usati liberamente
nei comandi SQL. Questo significa che si può digitare il comando allineato 
diversamente rispetto a sopra, oppure anche in un'unica linea. I due trattini
(<quote><literal>--</literal></quote>) introducono commenti.
Ogni cosa che li segue viene ignorata fino alla fine della linea. L'SQL
è insensibile alle maiuscole per quanto riguarda parole chiave e identificatori, eccetto
quando gli identificatori sono racchiusi tra doppi apici per preservare il "case" (sopra non
è stato fatto).
   </para>

   <para>
<type>varchar(80)</type> specifica un tipo di dato che può contenere
stringhe arbitrarie fino a 80 caratteri in lunghezza.
<type>int</type> è il normale tipo intero. <type>real</type> è 
un tipo per rappresentare numeri a virgola mobile a singola precisione.
<type>date</type> dovrebbe essere auto esplicativo. (Si, la colonna di tipo
<type>date</type> è chiamata <structfield>date</structfield>.
Questo potrebbe essere utile o potrebbe confondere - a voi la scelta).
   </para>

   <para>
<productname>PostgreSQL</productname> supporta i tipi standard
<acronym>SQL</acronym> <type>int</type>, <type>smallint</type>, <type>real</type>, <type>double
precision</type>, <type>char(<replaceable>N</replaceable>)</type>,
<type>varchar(<replaceable>N</replaceable>)</type>, <type>date</type>,
<type>time</type>, <type>timestamp</type> e <type>interval</type>,
così come altri tipi di utilità generale e un insieme completo di tipi geometrici.
<productname>PostgreSQL</productname> può essere personalizzato con un numero arbitrario
di tipi di dato definiti dall'utente. Di conseguenza, i nomi dei tipi
non sono parole chiave nella sintassi, eccetto dove richiesto di sostenere
casi speciali nello standard <acronym>SQL</acronym>.
   </para>

   <para>
Il secondo esempio memorizza città e la loro posizione geografica 
associata:
<programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
Il tipo <type>point</type> è un esempio di un tipo di dato specifico di 
<productname>PostgreSQL</productname>.
   </para>

   <para>
    <indexterm>
     <primary>DROP TABLE</primary>
    </indexterm>

Infine, dobbiamo ricordare che se non si ha più bisogno di una tabella 
o si vuole crearla di nuovo in maniera diversa è possibile rimuoverla 
usando il seguente comando:
<synopsis>
DROP TABLE <replaceable>tablename</replaceable>;
</synopsis>
   </para>
  </sect1>


  <sect1 id="tutorial-populate">
   <title>Popolare una tabella con righe</title>

   <indexterm zone="tutorial-populate">
    <primary>INSERT</primary>
   </indexterm>

   <para>
L'istruzione <command>INSERT</command> viene usata per popolare una tabella con
righe:

<programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>

Notare che tutti i tipi di dato usano formati di input abbastanza ovvi.
Costanti che non sono semplici valori numerici di solito devono essere circondate 
da apici singoli (<literal>'</literal>), come nell'esempio.
Il tipo <type>date</type> attualmente è abbastanza flessibile in ciò che accetta, 
ma per questo tutorial useremo un formato non ambiguo come mostrato qui.
   </para>

   <para>
Il tipo <type>point</type> richiede una coppia di coordinate come input,
come mostrato qui:
<programlisting>
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>

   <para>
La sintassi usata richiede di ricordare l'ordine delle colonne. 
Una sintassi alternativa permette di elencare le colonne
esplicitamente:
<programlisting>
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
È possibile elencare le colonne in un ordine diverso se si desidera o
si omettono alcune colonne, per es., se la precipitazione è sconosciuta:
<programlisting>
INSERT INTO weather (date, city, temp_hi, temp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
Molti sviluppatori considerano uno stile migliore elencare esplicitamente 
le colonne rispetto a fidarsi dell'ordine implicitamente.
   </para>

   <para>
Preghiamo di inserire tutti i comandi visti sopra così da avere alcuni dati con cui 
lavorare nelle sezioni seguenti.
   </para>

   <para>
    <indexterm>
     <primary>COPY</primary>
    </indexterm>

Si potrebbe anche usare <command>COPY</command> per caricare grandi quantità di 
dati dafile di testo semplici. Questo di solito è più veloce
dato che il comando <command>COPY</command> è ottimizzato per questa applicazione
ma allo stesso tempo permette meno flessibilità di 
<command>INSERT</command>.  Un esempio potrebbe essere:

<programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>

dove il nome del file del file sorgente deve essere disponibile per la
macchina backend, non per il client, dato che il server backend legge il 
file direttamente. Si può leggere di più sul comando 
<command>COPY</command> in <xref linkend="sql-copy"/>.
   </para>
  </sect1>


  <sect1 id="tutorial-select">
   <title>Interrogare una tabella</title>

   <para>
    <indexterm><primary>query</primary></indexterm>
    <indexterm><primary>SELECT</primary></indexterm>

Per ricavare dati da una tabella, la tabella
viene <firstterm>interrogata</firstterm>. Un'istruzione <command>SELECT</command> 
di <acronym>SQL</acronym> serve allo scopo. L'istruzione è divisa in un elenco select 
(la parte che elenca le colonne che devono essere restituite), un elenco di tabelle 
(la parte che elenca le tabelle da cui ricavare i dati), e un qualificatore
opzionale  (la parte che specifica eventuali restrizioni). Per esempio,
per ottenere tutte le righe della tabella 
<structname>weather</structname>, digitare:
<programlisting>
SELECT * FROM weather;
</programlisting>
Qui <literal>*</literal> è una scorciatoia per <quote>tutte le colonne</quote>.

     <footnote>
      <para>
Mentre  <literal>SELECT *</literal> è utile per query "a braccio",
è considerato cattivo stile in codice per la produzione,  
dato che l'aggiunta di una colonnna alla tabella cambierebbe i risultati.
      </para>
     </footnote>
Così lo stesso risultato si avrà con:
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
</programlisting>

L'output sarà:

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</screen>
   </para>

   <para>
Si possono scrivere espressioni, non solo semplici riferimenti a colonne, 
nell'elenco select. Per esempio, è possibile fare:
<programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</programlisting>
Questo darà:
<screen>
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</screen>
Notare come la clausola <literal>AS</literal> è usata per rinominare la colonna di 
output. (La clausola <literal>AS</literal> è opzionale).
   </para>

   <para>
Una query può essere <quote>qualificata</quote> aggiungendo una clausola <literal>WHERE</literal>
che specifica quali righe si vogliono. La clausola <literal>WHERE</literal>
contiene un'espressione booleana (valore di verità), e solo le righe che soddisfano l'espressione
sono restituite. Gli operatori booleani comuni (<literal>AND</literal>,
<literal>OR</literal>, e <literal>NOT</literal>) sono permessi nella qualificazione.
Per esempio, l'istruzione seguente ricava il tempo metereologico 
di San Francisco nei giorni di pioggia:

<programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
    Result:
<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>ORDER BY</primary></indexterm>

È possibile richiedere che il risultato di una query 
sia restituito in maniera ordinata:

<programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</screen>

In questo esempio, l'ordinamento non è specificato completamente, e così 
si potrebbe ottenere le righe riguardanti San Francisco in qualsiasi ordine. 
Si otterrano i risultati come mostrato sopra se si esegue:

<programlisting>
SELECT * FROM weather
    ORDER BY city, temp_lo;
</programlisting>
   </para>

   <para>
    <indexterm><primary>DISTINCT</primary></indexterm>
    <indexterm><primary>duplicate</primary></indexterm>

È possibile richiedere che righe duplicate siano rimosse dal risultato 
di una query:

<programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>

<screen>
     city
---------------
 Hayward
 San Francisco
(2 rows)
</screen>

Qui, ancora una volta, l'ordinamento delle righe del risultato potrebbe variare.
È possibile assicurare risultati consistenti usando  <literal>DISTINCT</literal> e
<literal>ORDER BY</literal> insieme:
     <footnote>
      <para>
In alcuni sistemi di database, compreso vecchie versioni di 
<productname>PostgreSQL</productname>, l'implementazione di 
<literal>DISTINCT</literal> automaticamente ordina le righe e quindi 
<literal>ORDER BY</literal> non è necessario. Ma questo non è richiesto dallo 
standard SQL, e <productname>PostgreSQL</productname> correntemente non garantisce 
che <literal>DISTINCT</literal> comporti l'ordinamento delle righe. 
      </para>
     </footnote>

<programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
   </para>
  </sect1>


  <sect1 id="tutorial-join">
   <title>Join tra tabelle</title>

   <indexterm zone="tutorial-join">
    <primary>join</primary>
   </indexterm>

   <para>
Fino ad ora, le query presentate accedono ad una tabella per volta.
Le query possono accedere a molteplici tabelle in una volta, o accedere alla stessa
tabella in modo che molteplici righe siano processate
nello stesso momento. Una query che accede a molteplici righe della stessa tabella 
o di tabelle diverse nello stesso momento viene chiamata una query <firstterm>join</firstterm>.
Come esempio, mettiamo che si desideri elencare tutti i record di tempo metereologico 
insieme alla posizione della città associata. Per farlo, è possibile confrontare 
la colonna <structfield>city</structfield> di ogni riga della 
tabella <structname>weather</structname> con la colonna <structfield>name</structfield>
di tutte le righe della tabella <structname>cities</structname>,
e selezionare le coppie di righe in cui questi valori corrispondono.
    <note>
     <para>
Questo è solo un modello concettuale. La join viene di solito eseguita
in maniera più efficiente che confrontando ogni possibile coppia di righe,
ma questo è invisibile all'utente.
     </para>
    </note>
Questo sarebbe portato a termine con la query seguente:

<programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>

   </para>

   <para>
Osservare due cose riguardanti il risultato:
    <itemizedlist>
     <listitem>
      <para>
Non c'è nessuna riga risultante per la cittò di Hayward. Questo perchè
non c'è una voce corrispondente nella tabella <structname>cities</structname>
per Hayward, così la join ignora le righe non corrispondenti nella tabella 
<structname>weather</structname>. A breve mostreremo come risolvere questo.
      </para>
     </listitem>

     <listitem>
      <para>
Ci sono due colonne contenenti il nome della città. Questo è giusto 
dato che gli elenchi delle colonne delle tabelle <structname>weather</structname>
e <structname>cities</structname> sono concatenati. In pratica
questo è indesiderabile, così probabilmente si vorranno elencare 
esplicitamente le colonne di output piuttosto che usare <literal>*</literal>:
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <formalpara>
    <title>Esercizio:</title>

    <para>
Tentare di determinare la semantica di questa query quando la clausola 
<literal>WHERE</literal> è omessa.
    </para>
   </formalpara>

   <para>
Dato che le colonne hanno tutte nomi diversi, il parser 
trova automaticamente la tabella a cui si riferiscono. Se ci fossero stati
nomi di colonna duplicati nelle due tabelle di sarebbero dovuti
<firstterm>qualificare</firstterm> i nomi di colonna per mostrare quale si intendeva,
quindi:

<programlisting>
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
</programlisting>

È considerato buona pratica qualificare tutti i nomi di colonna 
in una qyery join, così la query non fallirà se successivamente saranno aggiunti
a una tabella nomi di colonna duplicati. 
   </para>

   <para>
Le query join del tipo viste fino ad ora possono essere scritte anche 
nella forma alternativa:

<programlisting>
SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);
</programlisting>

Questa sintassi non è usati così frequentemente come quella sopra, ma viene presentata qui
per aiutare a capire i concetti seguenti.
   </para>

   <para>
    <indexterm><primary>join</primary><secondary>outer</secondary></indexterm>

Now we will figure out how we can get the Hayward records back in. 
Quello che vogliamo far fare alla query è di scanzionare la tabella 
<structname>weather</structname> e trovare per ogni riga la corrispondente 
riga/e della tabella <structname>cities</structname>. Se nessuna riga corrispondente 
viene trovata, si vuole che qualche tipo di <quote>valore vuoto</quote> venga sostituito
per la colonna della tabella <structname>cities</structname>. Questo tipo
di query viene chiamato <firstterm>outer join</firstterm>. (Le join che abbiamo considerato
fino ad ora sono inner join). Il comando sarà:

<programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</programlisting>

Questa query è chiamata <firstterm>left outer join</firstterm>
dato che la tabella indicata sulla sinistra dell'operatore join
avrà  ognuna delle sue righe in output almeno una volta,
mentre la tabella sulla destra avrà solo quelle righe
di output che corrispondono alla tabella di sinistra. Quando si manda in output 
la riga di una tabella a sinistra per la quale non c'è una corrispondenza nella tabella a destra,
i valori vuoti (null) sono sostituiti per le colonne della tabella di destra.
   </para>

   <formalpara>
    <title>Exercise:</title>

    <para>
     There are also right outer joins and full outer joins.  Try to
     find out what those do.
    </para>
   </formalpara>

   <para>
    <indexterm><primary>join</primary><secondary>self</secondary></indexterm>
    <indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm>

    We can also join a table against itself.  This is called a
    <firstterm>self join</firstterm>.  As an example, suppose we wish
    to find all the weather records that are in the temperature range
    of other weather records.  So we need to compare the
    <structfield>temp_lo</structfield> and <structfield>temp_hi</structfield> columns of
    each <structname>weather</structname> row to the
    <structfield>temp_lo</structfield> and
    <structfield>temp_hi</structfield> columns of all other
    <structname>weather</structname> rows.  We can do this with the
    following query:

<programlisting>
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo &lt; W2.temp_lo
    AND W1.temp_hi &gt; W2.temp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</programlisting>

    Here we have relabeled the weather table as <literal>W1</literal> and
    <literal>W2</literal> to be able to distinguish the left and right side
    of the join.  You can also use these kinds of aliases in other
    queries to save some typing, e.g.:
<programlisting>
SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;
</programlisting>
    You will encounter this style of abbreviating quite frequently.
   </para>
  </sect1>


  <sect1 id="tutorial-agg">
   <title>Aggregate Functions</title>

   <indexterm zone="tutorial-agg">
    <primary>aggregate function</primary>
   </indexterm>

   <para>
    <indexterm><primary>average</primary></indexterm>
    <indexterm><primary>count</primary></indexterm>
    <indexterm><primary>max</primary></indexterm>
    <indexterm><primary>min</primary></indexterm>
    <indexterm><primary>sum</primary></indexterm>

    Like  most  other relational database products,
    <productname>PostgreSQL</productname> supports
    <firstterm>aggregate functions</firstterm>.
    An aggregate function computes a single result from multiple input rows.
    For example, there are aggregates to compute the
    <function>count</function>, <function>sum</function>,
    <function>avg</function> (average), <function>max</function> (maximum) and
    <function>min</function> (minimum) over a set of rows.
   </para>

   <para>
    As an example, we can find the highest low-temperature reading anywhere
    with:

<programlisting>
SELECT max(temp_lo) FROM weather;
</programlisting>

<screen>
 max
-----
  46
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>subquery</primary></indexterm>

    If we wanted to know what city (or cities) that reading occurred in,
    we might try:

<programlisting>
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>WRONG</lineannotation>
</programlisting>

    but this will not work since the aggregate
    <function>max</function> cannot be used in the
    <literal>WHERE</literal> clause.  (This restriction exists because
    the <literal>WHERE</literal> clause determines which rows will be
    included in the aggregate calculation; so obviously it has to be evaluated
    before aggregate functions are computed.)
    However, as is often the case
    the query can be restated to accomplish the desired result, here
    by using a <firstterm>subquery</firstterm>:

<programlisting>
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
</programlisting>

<screen>
     city
---------------
 San Francisco
(1 row)
</screen>

    This is OK because the subquery is an independent computation
    that computes its own aggregate separately from what is happening
    in the outer query.
   </para>

   <para>
    <indexterm><primary>GROUP BY</primary></indexterm>
    <indexterm><primary>HAVING</primary></indexterm>

    Aggregates are also very useful in combination with <literal>GROUP
    BY</literal> clauses.  For example, we can get the maximum low
    temperature observed in each city with:

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)
</screen>

    which gives us one output row per city.  Each aggregate result is
    computed over the table rows matching that city.
    We can filter these grouped
    rows using <literal>HAVING</literal>:

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>

<screen>
  city   | max
---------+-----
 Hayward |  37
(1 row)
</screen>

    which gives us the same results for only the cities that have all
    <structfield>temp_lo</structfield> values below 40.  Finally, if we only care about
    cities whose
    names begin with <quote><literal>S</literal></quote>, we might do:

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'<co id="co.tutorial-agg-like"/>
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>
   <calloutlist>
    <callout arearefs="co.tutorial-agg-like">
     <para>
      The <literal>LIKE</literal> operator does pattern matching and
      is explained in <xref linkend="functions-matching"/>.
     </para>
    </callout>
   </calloutlist>
   </para>

   <para>
    It is important to understand the interaction between aggregates and
    <acronym>SQL</acronym>'s <literal>WHERE</literal> and <literal>HAVING</literal> clauses.
    The fundamental difference between <literal>WHERE</literal> and
    <literal>HAVING</literal> is this: <literal>WHERE</literal> selects
    input rows before groups and aggregates are computed (thus, it controls
    which rows go into the aggregate computation), whereas
    <literal>HAVING</literal> selects group rows after groups and
    aggregates are computed.  Thus, the
    <literal>WHERE</literal> clause must not contain aggregate functions;
    it makes no sense to try to use an aggregate to determine which rows
    will be inputs to the aggregates.  On the other hand, the
    <literal>HAVING</literal> clause always contains aggregate functions.
    (Strictly speaking, you are allowed to write a <literal>HAVING</literal>
    clause that doesn't use aggregates, but it's seldom useful. The same
    condition could be used more efficiently at the <literal>WHERE</literal>
    stage.)
   </para>

   <para>
    In the previous example, we can apply the city name restriction in
    <literal>WHERE</literal>, since it needs no aggregate.  This is
    more efficient than adding the restriction to <literal>HAVING</literal>,
    because we avoid doing the grouping and aggregate calculations
    for all rows that fail the <literal>WHERE</literal> check.
   </para>
  </sect1>


  <sect1 id="tutorial-update">
   <title>Updates</title>

   <indexterm zone="tutorial-update">
    <primary>UPDATE</primary>
   </indexterm>

   <para>
    You can update existing rows using the
    <command>UPDATE</command> command.
    Suppose you discover the temperature readings are
    all off by 2 degrees after November 28.  You can correct the
    data as follows:

<programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>

   <para>
    Look at the new state of the data:
<programlisting>
SELECT * FROM weather;

     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
 Hayward       |      35 |      52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
  </sect1>

  <sect1 id="tutorial-delete">
   <title>Deletions</title>

   <indexterm zone="tutorial-delete">
    <primary>DELETE</primary>
   </indexterm>

   <para>
    Rows can be removed from a table using the <command>DELETE</command>
    command.
    Suppose you are no longer interested in the weather of Hayward.
    Then you can do the following to delete those rows from the table:
<programlisting>
DELETE FROM weather WHERE city = 'Hayward';
</programlisting>

    All weather records belonging to Hayward are removed.

<programlisting>
SELECT * FROM weather;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>

   <para>
    One should be wary of statements of the form
<synopsis>
DELETE FROM <replaceable>tablename</replaceable>;
</synopsis>

    Without a qualification, <command>DELETE</command> will
    remove  <emphasis>all</emphasis>  rows from the given table, leaving it
    empty.  The system will not request confirmation before
    doing this!
   </para>
  </sect1>

 </chapter>

<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="plpgsql">
  <title><application>PL/pgSQL</application> - Linguaggio procedurale <acronym>SQL</acronym></title>

 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
  <title>Panoramica</title>

 <para>
<application>PL/pgSQL</application> è un linguaggio procedurale 
caricabile nel sistema di database  <productname>PostgreSQL</productname>.
Gli obiettivi del design di <application>PL/pgSQL</application> erano di creare 
un linguaggio caricabile che

    <itemizedlist>
     <listitem>
      <para>
potesse essere usato per creare funzioni e procedure trigger,
      </para>
     </listitem>
     <listitem>
      <para>
aggiungesse strutture di controllo al linguaggio <acronym>SQL</acronym>,
      </para>
     </listitem>
     <listitem>
      <para>
potesse svolgere calcoli complessi,

      </para>
     </listitem>
     <listitem>
      <para>
ereditasse tutti i tipi, le funzioni e gli operatori definiti dall'utente,
      </para>
     </listitem>
     <listitem>
      <para>
potesse essere definito per essere trusted dal server,
      </para>
     </listitem>
     <listitem>
      <para>
fosse facile da usare.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
Funzioni create con  <application>PL/pgSQL</application> possono essere 
usate ovunque possano essere usate funzioni incorporate.
Per esempio, è possibile creare 
funzioni di calcolo condizionale complesse e successivamente 
usarle per definire operatori o usarle in espressioni di indice.
   </para>

   <para>
In <productname>PostgreSQL</productname> 9.0 e successivi,
<application>PL/pgSQL</application> è installato in maniera predefinita.
Comunque è ancora un modulo caricabile, per questo amministratori particolarmente attenti alla sicurezza
potrebbero decidere di rimuoverlo.
   </para>

  <sect2 id="plpgsql-advantages">
   <title>Vantaggi dell'utilizzo di <application>PL/pgSQL</application></title>

    <para>
<acronym>SQL</acronym> è il linguaggio che <productname>PostgreSQL</productname>
e la maggior parte degli altri database relazioni usano come linguaggio di interrogazione. È
portabile e facile da imparare. Ma ogni istruzione <acronym>SQL</acronym>
dev'essere eseguita individualmente dal server database.
    </para>

    <para>
Questo significa che l'applicazione client deve mandare ogni query al server database,
aspettare che sia elaborata, ricevere ed elaborare il risultato,
eseguire alcuni calcoli, quindi mandare ulteriori 
query al server. Tutto questo genera comunicazione tra processi 
e genererà anche overhead di rete se il client
è su una macchina differente rispetto al server database.
    </para>

    <para>
Con <application>PL/pgSQL</application> si può raggruppare un blocco di
calcolo e una serie di query <emphasis>all'interno</emphasis>
del server database, avendo quindi la potenza di un linguaggio procedurale
e la facilità d'uso dell'SQL, ma con considerevole risparmio
di overhead di comunicazione client/server.
    </para>
    <itemizedlist>

     <listitem><para>
Sono eliminati i giri aggiuntivi tra il client e il server
     </para></listitem>

     <listitem><para> 
I risultati intermedi non necessari al client non devono essere 
smistati o trasferiti tra il server e il client
     </para></listitem>

     <listitem><para> 
Possono essere evitati molteplici stadi di parsing delle query
     </para></listitem>

    </itemizedlist>
<para> Questo risulta in un incremento di prestazioni considerevole 
se confrontato con un'applicazione che non usa funzioni immagazzinate.
    </para>

    <para>
Inoltre, con <application>PL/pgSQL</application> si possono usare
tutti i tipi di dato, gli operatori e le funzioni di SQL.
    </para>
  </sect2>

  <sect2 id="plpgsql-args-results">
   <title>Argomenti supportati e tipi di dato risultanti</title>

    <para>
Le funzioni scritte in <application>PL/pgSQL</application> possono accettare 
come argomenti qualsiasi tipo scalare o array supportato dal server,
e possono restituire un risultato di qualsiasi di quei tipi. Possono anche 
accettare o restituire qualsiasi tipo composto (tipo riga) specificato dal nome.
È inoltre possibile dichiarare una funzione <application>PL/pgSQL</application>
che restituisce un <type>record</type>, che significa che il risultato
è un tipo riga le cui colonne sono determinate dalle specifiche nella 
query chiamante, come discusso in <xref linkend="queries-tablefunctions"/>.
    </para>

    <para>
Le funzioni <application>PL/pgSQL</application> possono essere dichiarate per accettare un numero variabile di argomenti
usando <literal>VARIADIC</literal>. Questo funziona esattamente
allo stesso modo delle funzioni SQL, come discusso in 
<xref linkend="xfunc-sql-variadic-functions"/>.
    </para>

    <para>
Le funzioni <application>PL/pgSQL</application> possono inoltre essere dichiarate per accettare 
e restituire tipo polimorfi
<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>
e <type>anyenum</type>.  Gli effettivi tipi di dato gestiti da una funzione polimorfa
possono variare da chiamata a chiamata, come discusso in  <xref linkend="extend-types-polymorphic"/>.
Un esempio è mostrato in <xref linkend="plpgsql-declaration-parameters"/>.
    </para>

    <para>
Funzioni  <application>PL/pgSQL</application> possono anche essere dichiarate per restituire
un <quote>insieme</quote> (o tabella) di qualsiasi tipo di dato che può essere restituito
come singola istanza. Tale funzione genera il suo output eseguendo 
<command>RETURN NEXT</command> per ogni elemento desiderato dell'insieme risultato,
o usando <command>RETURN QUERY</command> per mostrare in output il risultato della valutazione
della query.
    </para>

    <para>
Infine, una funzione <application>PL/pgSQL</application> può essere dichiarata per restituire
<type>void</type> se non ha valori di ritorno utili.
    </para>

    <para>
Funzioni <application>PL/pgSQL</application> possono anche essere dichiarate con
parametri di output al posto di una dichiarazione esplicita del tipo di ritorno.
Questo non aggiunge nessuna capacità fondamentale al linguaggio, ma 
spesso è conveniente, specialmente per restituire molteplici valori.
La notazione <literal>RETURNS TABLE</literal> può essere usata al posto di 
<literal>RETURNS SETOF</literal>.
    </para>

    <para>
Esempi specifici appaiono in 
<xref linkend="plpgsql-declaration-parameters"/> e
<xref linkend="plpgsql-statements-returning"/>.
    </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
  <title>Struttura di <application>PL/pgSQL</application></title>

  <para>
<application>PL/pgSQL</application> è un linguaggio strutturato a blocchi.
Il testo completo della definizione di una funzione deve essere un
<firstterm>blocco</firstterm>. Un blocco è definito come:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
Ogni dichiarazione e ogni istruzione all'interno di un blocco è terminata da 
un punto e virgola. Un blocco che appare all'interno di un altro blocco deve
avere un punto e virgola dopo <literal>END</literal>, come mostrato sopra;
comunque l'<literal>END</literal> finale che conclude il corpo di una
funzione non richiede un punto e virgola.
    </para>

    <tip>
     <para>
Un errore comunque è di scrivere un punto e virgola immediatamente dopo 
<literal>BEGIN</literal>. Questo non è corretto e causerà un errore di sintassi.
     </para>
    </tip>

    <para>
Una  <replaceable>label</replaceable> è necessaria solo se si vuole 
identificare il blocco per usarlo 
in un'istruzione <literal>EXIT</literal>, o per qualificare i nomi delle variabili
dichiarate nel blocco. Se un'etichetta viene fornita dopo 
<literal>END</literal>, deve corrispondere all'ettichetta all'inizio del blocco.
    </para>

    <para>
Tutte le parole chiave sono insensibili al case.
Gli identificatori sono implicitamente convertiti in minuscolo
a meno che non siano tra doppi apici, esattamente come nei comandi SQL comuni.
    </para>

    <para>
I commenti in <application>PL/pgSQL</application>  funzionano allo stesso modo del comune
SQL. Un trattino doppio (<literal>--</literal>) comincia un commento 
che si estende fino alla fine della linea. Un <literal>/*</literal>  comincia un blocco di commento 
che si estende fino all'occorrenza corispondente di
<literal>*/</literal>. I blocchi commenti possono essere nidificati.
    </para>

    <para>
Qualsiasi istruzione nella sezione istruzioni di un blocco
può essere un <firstterm>sottoblocco</firstterm>.
I sottoblocchi possono essere usati per 
raggruppare logicamente o localizzare variabili in un piccolo gruppo di 
istruzioni.
Le variabili dichiarate in un sottoblocco mascherano qualsiasi 
variabile chiamata similarmente di blocchi esterni per la durata 
del sottoblocco; ma si può accedere comunque le variabili esterne 
se si qualificano i loro nomi con etichette di blocco. 
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
    quantity := 50;
    --
    -- Crea un sottoblocco
    --
    DECLARE
        quantity integer := 80;
    BEgin
        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <note>
     <para>
Attualmente c'è un <quote>blocco esterno</quote> nascosto che racchiude il corpo 
di qualsiasi funzione <application>PL/pgSQL</application>. Questo blocco fornisce le dichiarazioni
dei parametri di funzione (se presenti), così come alcune variabili speciali 
tipo <literal>FOUND</literal> (si veda 
<xref linkend="plpgsql-statements-diagnostics"/>). Il blocco esterno è 
etichettato con il nome della funzione, quindi i parametri e le variabili speciali 
possono essere qualificate con il nome della funzione.
     </para>
    </note>

    <para>
È importante non confondere l'uso di 
<command>BEGIN</command>/<command>END</command> per raggruppare istruzioni in 
<application>PL/pgSQL</application> con i comandi SQL chiamati similmente
per il controllo 
delle transazioni. <command>BEgin</command>/<command>END</command> di <application>PL/pgSQL</application>
sono solo per raggruppamento; essi non cominciano o finiscono una transazione.
Funzioni e procedure trigger sono eseguite sempre all'interno di una transazione
definita da una query esterna - non possono cominciare o fare il commit di quella
transzione, dato che non ci sarebbe contesto per loro in cui essere eseguite.
Comunque, un blocco che contiene una clausola <literal>EXCEPTION</literal> effettivamente
forma una sottotransazione di cui si può fare il rollback senza coinvolgere
la transazione esterna. Per maggiori informazioni su questo si veda <xref
linkend="plpgsql-error-trapping"/>.
    </para>
  </sect1>

  <sect1 id="plpgsql-declarations">
    <title>Dichiarazioni</title>

    <para>
Tutte le variabili usate in un blocco devono essere dichiarate nella sezione 
delle dichiarazioni del blocco.
(Le uniche eccezioni sono che la variabile loop di un ciclo <literal>FOR</literal>
che itera su un intervallo di valori interi è automaticamente dichiarata come una variabile intera,
come anche la variabile loop di un ciclo <literal>FOR</literal>
che itera sul risultato di un cursore viene automaticamente dichiarata come una 
variabile record).
    </para>

    <para>
Le variabili <application>PL/pgSQL</application> possono avere qualsiasi tipo di dato SQL, tipo 
<type>integer</type>, <type>varchar</type> e 
<type>char</type>.
    </para>

    <para>
Ecco alcuni esempi di dichiarazione di variabili:
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    <para>
La sintassi generale di una dichiarazione di variabile è:
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> NOT NULL </optional> <optional> { DEFAULT | := } <replaceable>expression</replaceable> </optional>;
</synopsis>
La clausola <literal>DEFAULT</literal>, se fornita, specifica il valore iniziale assegnato 
alla variabile quando viene specificato il blocco. Se la clausola  <literal>DEFAULT</literal> 
non è fornita allora la variabile è inizializzata al valore 
<acronym>SQL</acronym> null.
L'opzione <literal>CONSTANT</literal> evita che la variabile possa essere assegnata,
così quel valore rimarrà costante per tutta la durata del blocco.
Se è specificato <literal>NOT NULL</literal>, un'assegnazione di un valore null
risulterà in un errore durante l'esecuzione. 
Tutte le variabili dichiarate come <literal>NOT NULL</literal>
devono avere un valore non null di default specificato.
     </para>

     <para>
Il valore di default di una variabile è valutato e assegnato alla variabile 
ogni volta che il blocco è iniziato (non solo una volta per chiamata di funzione).
Quindi, per esempio, assegnare <literal>now()</literal> a una variabile di tipo 
<type>timestamp</type> fa sì che la variabile avrà l'orario della chiamata di fuzione corrente,
non l'orario in cui la funzione è stata precompilata.
     </para>

     <para>
      Examples:
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plpgsql-declaration-parameters">
     <title>Dichiarazione di parametri di funzione</title>

     <para>
I parametri passati alle funzioni sono chiamati con gli identificatori 
<literal>$1</literal>, <literal>$2</literal>,
ecc. Opzionalmente, possono essere dichiarati degli alias per 
<literal>$<replaceable>n</replaceable></literal>
nomi di parametri per aumentare la leggibilità. Sia l'alias che l'identificatore 
numerico possono quindi essere usati per riferirsi al valore del parametro.
     </para>

     <para>
Ci sono due modi di creare un alias. Il modo preferito è di dare un nome
al parametro nel comando <command>CREATE FUNCTION</command>,
per esempio:
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
L'altro modo, che era l'unico disponibile prima di 
<productname>PostgreSQL</productname> 8.0, è di dichiarare esplicitamente 
un alias, usando la sintassi di dichiarazione

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

Lo stesso esempio in questo stile somiglia a:
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEgin
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
     <para>
Questi due esempi non sono perfettamente equivalenti. Nel primo caso,
<literal>subtotal</literal> potrebbe essere riferito come 
<literal>sales_tax.subtotal</literal>, ma nel secondo caso non potrebbe.
(Dato che abbiamo attaccato un'etichetta al blocco interno, <literal>subtotal</literal> potrebbe
essere qualificato con quell'etichetta, invece).
     </para>
    </note>

     <para>
Altri esempi:
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEgin
    -- alcuni calcoli usando v_string e index
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEgin
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
Quando una funzione <application>PL/pgSQL</application> è dichiarata 
con parametri di output, ai parametri di output sono dati 
<literal>$<replaceable>n</replaceable></literal> nomi e opzionalmente alias
nello stesso modo dei normali parametri di input. Un parametro di output 
è effettivamente una variabile che parte NULL;
dovrebbe essere assegnata durante l'esecuzione della funzione.
Il valore finale del parametro è cosa viene restituito. Per esempio, 
l'esempio delle sales_tax potrebbe anche essere fatto in questo modo:

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEgin
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Notare che si è omesso <literal>RETURNS real</literal> - potevamo includerlo, 
ma sarebbe stato ridondante.
     </para>

     <para>
I parametri di output sono utili quando si restituiscono molteplivi valori.
Un esempio banale è:

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEgin
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Come discusso in  <xref linkend="xfunc-output-parameters"/>, questo crea 
effettivamente un tipo record anonimo per i risultati della funzione.
Se viene specificata una clausola  <literal>RETURNS</literal>, deve essere specificato 
<literal>RETURNS record</literal>.
     </para>

     <para>
Un altro modo di dichiarare una funzione <application>PL/pgSQL</application>
è con <literal>RETURNS TABLE</literal>, per esempio:

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEgin
    RETURN QUERY SELECT quantity, quantity * price FROM sales
                 WHERE itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Questo è esattamente equivalente a dichiarare uno o più parametri <literal>OUT</literal>
e specificare <literal>RETURNS SETOF
<replaceable>sometype</replaceable></literal>.
     </para>

     <para>
Quando il tipo di ritorno di una funzione <application>PL/pgSQL</application>
viene dichiarata come un tipo polimorfico  (<type>anyelement</type>,
<type>anyarray</type>, <type>anynonarray</type>, or <type>anyenum</type>),
viene creato un parametro speciale <literal>$0</literal>
Il suo tipo di dato è effettivamente il tipo di ritorno della funzione,
come dedotto fagli effettivi tipi di input (si veda <xref
linkend="extend-types-polymorphic"/>).
Questo permette alla funzione di accedere il suo effettivo tipo di ritorno
come mostrato in <xref linkend="plpgsql-declaration-type"/>. 
<literal>$0</literal> viene inizializzato a null e può essere modificato dalla
funzione, così può essere usato per tenere il valore di ritorno se lo si desidera,
anche se non è richiesto. È possibile dare un alias a <literal>$0</literal>.
Per esempio, questa funzione funziona su qualsiasi tipo di dato 
che ha un operatore <literal>+</literal>:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEgin
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
Lo stesso effetto può essere ottenuto dichiarando uno o più parametri come 
tipi polimorfici. In questo caso il parametro speciale
<literal>$0</literal> non viene usato; i parametri di output
stessi servono allo stesso scopo. PEr esempio:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEgin
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</literal></title>

<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>

   <para>
La sintassi di <literal>ALIAS</literal> è più generale rispetto a come suggerito nella
sezione precedente: è possibile dichiarare un alias per qualsiasi variabile, non solo
parametri di funzione. L'uso pratico principale per questo è di assegnare
un nome diverso per variabili con nomi predeterminati, tipo 
<varname>NEW</varname> o <varname>OLD</varname> all'interno
di una procedura trigger.
   </para>

   <para>
Esempi:
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>

   <para>
Dato che <literal>ALIAS</literal> crea due modi differenti per nominare lo stesso oggetto,
l'uso incontrollato può confondere. È meglio usarlo solo
per lo scopo di sovrascrivere nomi predeterminati.
   </para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
   <title>Copiare tipi</title>

<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   <para>
<literal>%TYPE</literal> fornisce il tipo di dato di una variabile o
una colonna di tabella. È possibile usarlo per dichiarare variabili che conterranno
valori di database. Per esempio, diciamo che si ha una colonna chiamata 
<literal>user_id</literal> nella tabella <literal>users</literal>.
Per dichiarare una variabile con lo stesso tipo di dato di 
<literal>users.user_id</literal> scrivere:

<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <para>
Usando <literal>%TYPE</literal> non si ha bisogno di conoscere il tipo di dato 
della struttura a cui ci si riferisce, e più importante, 
se il tipo di dato dell'elemento riferito in futuro cambia (per esempio:
si cambia il tipo di <literal>user_id</literal>
da <type>integer</type> a <type>real</type>), non ci sarà bisogno di 
cambiare la definizione di funzione.
   </para>

   <para>
<literal>%TYPE</literal> è particolarmente utile in funzioni polimorfiche,
dato che i tipi di dato necessari per le variabili interne possono 
cambiare da una chiamata alla successiva. Variabili appropriate possono essere
create applicando <literal>%TYPE</literal> agli argomenti della funzione 
o agli argomenti del risultato.
   </para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
     <title>Tipi riga</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

   <para>
Una variabile di un tipo composto viene chiamata variabile <firstterm>row</firstterm>
(o variabile <firstterm>tipo riga</firstterm>). Tale variabile 
può contenere una riga intera del risultato di una query <command>SELECT</command> o <command>FOR</command>,
a patto che l'insieme delle colonne della query corrisponda al tipo dichiarato della
variabile.
Si accede ai campi individuali del valore della riga 
usando la solita notazione con il punto, per esempio
<literal>rowvar.field</literal>.
   </para>

   <para>
Una variabile riga può essere dichiarata per avere lo stesso tipo delle righe 
di una tabella o vista esistente, usando la notazione
<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
o può essere dichiarata fornendo un nome di tipo composto.
(Dato che ogni tabella ha un tipo composto associato dello stesso nome,
attualmente in <productname>PostgreSQL</productname> non importa se si scrive 
<literal>%ROWTYPE</literal> o no. Ma la forma con 
<literal>%ROWTYPE</literal> è più portabile).
   </para>

   <para>
I parametri di una funzione possono essere
tipi composti (righe di tabella complete). In tal caso, l'identificatore
corrispondente <literal>$<replaceable>n</replaceable></literal> sarà una variabile riga, e i campi possono 
essere selezionati da essa, per esempio <literal>$1.user_id</literal>.
   </para>

   <para>
Solo le colonne definite dall'utente di una riga di tabella sono accessibili in 
una variabile di tipo riga, non l'OID o altre colonne di sistema (dato che
la riga poteva provenire da una vista). I campi del tipo riga ereditano 
la dimensione e la precisione dei campi della tabella per i tipi di dato come
<type>char(<replaceable>n</replaceable>)</type>.
   </para>

   <para>
Ecco un esempio dell'utilizzo di tipi composti. <structname>table1</structname>
e <structname>table2</structname> sono tabelle esistenti aventi almeno i campi 
menzionati:

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEgin
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
   <title>Tipi record</title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <para>
Le variabili record sono simili alle variabili di tipo riga, ma non hanno 
strutture predefinite. Esse si preoccupano dell'effettiva struttura della 
riga a cui sono assegnate durante un comando  <command>SELECT</command> o <command>FOR</command>. La sottostruttura 
di una variabile record può cambiare ogni volta che viene assegnata.
Una conseguenza di questo è che finchè una variabile record non è assegnata, 
non ha sottostrutture, e qualsiasi tentativo di accedere ad un campo
in essa genera un errore in fase di esecuzione.
   </para>

   <para>
Notare che <literal>RECORD</literal> non è un vero tipo di dato, solo un segnaposto.
Ci si dovrebbe rendere conto che quando una funzione <application>PL/pgSQL</application>
viene dichiarata per ritornare un tipo <type>record</type>, non è esattamente lo stesso concetto di
una variabile record, anche se tale funzuione potrebbe 
usare una variabile recordo per contenere il suo risultato. In emtrambi i casi la struttura effettiva della riga
è sconosciuta quando viene scritta la funzione, ma per una funzione 
che ritorna <type>record</type> l'effettiva struttura viene determinata quando viene fatto il parsing della
query chiamante, mentre una variabile record può cambiare la sua struttura di riga al volo. 
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
  <title>Espressioni</title>

    <para>
Tutte le espressioni usate in istruzioni <application>PL/pgSQL</application>
sono elaborate usando l'esecutore <acronym>SQL</acronym> principale 
del server. Per esempio, quando si scrive 
un'istruzione <application>PL/pgSQL</application> tipo
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
<application>PL/pgSQL</application> valuterà l'espressione fornendo una query 
tipo
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
al motore SQL principale. Mentre forma il comando <command>SELECT</command>,
qualsiasi occorrenza di nomi di bariabile <application>PL/pgSQL</application>
viene sostituita da parametri, come discusso in dettaglio in 
<xref linkend="plpgsql-var-subst"/>.
Questo permette al pianificatore di query per la <command>SELECT</command> di
essere preparata sono una volta e quindi riusata per 
successive valutazioni con valori diversi delle variabili. Così, quello 
che realmente accade al primo utilizzo di una espressione è essenzialmente un comando 
<command>PREPARE</command>. Per esempio, se si sono dichiarate
due variabili intere <literal>x</literal> e <literal>y</literal>, e si scrive
<programlisting>
IF x &lt; y THEN ...
</programlisting>
Quello che succede dietro le quinte è equivalente a 
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
quindi questa istruzione preparata viene eseguita (<command>EXECUTE</command>) per ogni
esecuzione dell'istruzione <command>IF</command>, con i valori correnti
delle variabili <application>PL/pgSQL</application> forniti come 
valori dei parametri.
Il piano di query preparato in questo modo viene salvato per la durata della connessione al database,
come descritto in 
<xref linkend="plpgsql-plan-caching"/>. Normalmente, questi dettagli non sono 
importanti per un utente <application>PL/pgSQL</application>, ma 
sono utili da sapere quando si tenta di diagnosticare un problema.
    </para>
  </sect1>

  <sect1 id="plpgsql-statements">
  <title>Istruzioni di base</title>

   <para>
In questa sezione e nelle seguenti, descriveremo tutti i tipi di istruzione
che sono implicitamente compresi da 
<application>PL/pgSQL</application>.
Qualsiasi cosa non riconosciuta come uno si questi tipi di istruzione è supposta 
essere un comando SQL ed è spedita al motore principale del database per essere eseguita,
come descritto in <xref linkend="plpgsql-statements-sql-noresult"/>
e <xref linkend="plpgsql-statements-sql-onerow"/>.
   </para>

   <sect2 id="plpgsql-statements-assignment">
    <title>Assegnazione</title>

    <para>
Un'assegnazione di un valore a una variabile <application>PL/pgSQL</application>
è scritta come:
<synopsis>
<replaceable>variable</replaceable> := <replaceable>expression</replaceable>;
</synopsis>
Come spiegato precedentemente, l'espressione in tale istruzione viene valutata
mediante un comando SQL  <command>SELECT</command> mandato al motore database principale.
L'espressione deve generare un singolo valore (possibilmente 
un valore riga, se la variabile è una variabile riga o record).
La variabile obiettivo
può essere una variabile semplice (opzionalmente qualificata con un nome di blocco),
un campo di una variabile riga o record, o un elemento di un array
che è una variabile o campo semplice. 
    </para>

    <para>
Se il tipo di dato risultante dell'espressione non corrisponde al tipo di dato 
della variabile, o la variabile ha una dimensione/precisione specifica
(tipo <type>char(20)</type>), il valore del risultato sarà implicitamente
convertito dall'interprete <application>PL/pgSQL</application> usando 
la funzione output del tipo del risultato e 
la funzione input del tipo della variabile. Si noti che questo risulta in potenziali 
errori in fase di esecuzione generati dalla funzioni di input, se la forma della stringa
del valore del risultato non è accettabile per la funzione di input.
    </para>

    <para>
Esempi:
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
    <title>Eseguire un comando senza risultato</title>

    <para>
Per qualsiasi comando SQL che non restituisce righe, per 
esempio <command>INSERT</command> senza una clausola <literal>RETURNING</literal>, 
è possibile eseguire il comando all'interno di una funzione  <application>PL/pgSQL</application>
semplicemente scrivendo il comando.
    </para>

    <para>
Qualsiasi nome di variabile <application>PL/pgSQL</application> che appare
nel testo del comando viene trattato come parametro, e quindi il valore corrente
della variabile viene fornito come il valore del parametro in fase
di esecuzione. Questo è esattamente come l'elaborazione descritta precedentemente
per le espressioni; per i dettagli si veda <xref linkend="plpgsql-var-subst"/>.
    </para>

    <para>
Quando si esegue un comando SQL in questo modo,
<application>PL/pgSQL</application> pianifica il comando solo una volta 
e riusa il piano per successive esecuzioni, fino alla fine della 
connessione al database. Le implicazioni di questo sono discusse
in dettaglio in <xref linkend="plpgsql-plan-caching"/>.
    </para>

    <para>
A volte è utile valutare un'espressione i una query <command>SELECT</command>
ma scartare il risultato, per esempio quando si chiama una funzione
che ha effetti collaterali ma non un risultato utile. Per fare questo
in <application>PL/pgSQL</application>, usare l'istruzione 
<command>PERFORM</command>:

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

Questo esegue  <replaceable>query</replaceable> e scarta il risultato.
Scrivere la <replaceable>query</replaceable> allo stesso modo di come
si scriverebbe un comando SQL <command>SELECT</command>, ma sostituire la parola 
chiave iniziale <command>SELECT</command> con <command>PERFORM</command>.
Le variabili <application>PL/pgSQL</application> saranno
sostituiti nella query esattamente come per i comandi che non restituiscono risultati,
e il piano viene sottoposto a cache nello stesso modo. Inoltre, la variabile speciale 
<literal>FOUND</literal> viene impostata a true se la query ha prodotto almeno 
una riga, o false se non ha prodotto righe (si veda 
<xref linkend="plpgsql-statements-diagnostics"/>).
    </para>

    <note>
     <para>
Ci si potrebbe aspettare che scrivere direttamente <command>SELECT</command>
avrebbe questo risultato, ma al momento l'unico modo accettato 
per farlo è 
<command>PERFORM</command>. Un comando SQL che può restituire righe, 
tipo un <command>SELECT</command>, sarà rifiutato come errore
finchè non ha una clausola <literal>INTO</literal> come discusso nella prossima sezione.
     </para>
    </note>

    <para>
Un esempio:
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
    <title>Eseguire una query con un risultato di una singola riga</title>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
Il risultato di una comando SQL che genera una singola riga (possibilmente di molteplici colonne)
può essere assegnato a una variabile record, tipo riga, o elenco di variabili scalari.
Questo viene fatto scrivendo il comando SQL di base e aggiungendo una 
clausola <literal>INTO</literal>. Per esempio,

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

dove <replaceable>target</replaceable> può essere una variabile record, una variabile riga,
o un elenco separato da virgole di variabili semplici e 
campi record/riga.
Le variabili <application>PL/pgSQL</application> saranno sostituite 
nel resto della query, e il piano viene sottoposto a cache,
esattamente come descritto sopra per comandi che non ritornano righe.
Questo funziona per <command>SELECT</command>,
<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> con 
<literal>RETURNING</literal>, e comandi di utilità che restituiscono risultati insieme di righe
(come <command>EXPLAIN</command>).
Ad eccezione della clausola <literal>INTO</literal>, il comando SQL è lo stesso  
di come sarebbe scritto fuori da <application>PL/pgSQL</application>.
    </para>

   <tip>
    <para>
Si noti che questa interpretazione di <command>SELECT</command> con <literal>INTO</literal>
è abbastanza diversa dal normale comando <command>SELECT INTO</command> 
di <productname>PostgreSQL</productname>, in cui il target di <literal>INTO</literal>
e una tabella creata ex-novo. Se si vuole creare una tabella dal risultato di una
<command>SELECT</command> all'interno di una funzione <application>PL/pgSQL</application>,
usare la sintassi
<command>CREATE TABLE ... AS SELECT</command>.
    </para>
   </tip>

    <para>
Se una riga o un elenco di variabili è usato come target, le colonne risultanti della query 
devono corrispondere esattamente alla struttura del target come numero e tipi di dato,
altrimenti si genera un errore in fase di esecuzione. 
Quando una variabile record è il target, essa automaticamente configura sè stessa 
al tipo riga delle colonne del risultato della query.
    </para>

    <para>
La clausola <literal>INTO</literal> può apparire quasi ovunque nel comando   
SQL. Di norma è scritta o appena prima o appena dopo    
l'elenco di <replaceable>select_expressions</replaceable> in un comando 
<command>SELECT</command>, o alla fine del comando per altri tipi di comando. 
Si raccomanda di seguire questa convenzione nel caso 
che il parser di <application>PL/pgSQL</application> diventi 
più rigido in versioni future.
    </para>

    <para>
Se <literal>STRICT</literal> non è specificato nella clausola <literal>INTO</literal>,
allora <replaceable>target</replaceable> sarà impostato alla prima 
riga restituita dalla query, o a null se la query non ha restituito righe.
(Notare che <quote>la prima riga</quote> non è
ben definita a meno che non si sia usato <literal>ORDER BY</literal>). Ogni riga risultante 
dopo la prima viene scartata.
Si può controllare la variabile speciale <literal>FOUND</literal> (si veda 
<xref linkend="plpgsql-statements-diagnostics"/>) per
determinare se una riga è stata restituita:

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

Se l'opzione <literal>STRICT</literal> è specificata, la query deve
ritornare esattamente una riga o sarà riportato un errore al momento dell'esecuzione, 
o <literal>NO_DATA_FOUND</literal> (nessusa riga) o <literal>TOO_MANY_ROWS</literal>
(più di una riga). Si può usare un blocco eccezione se si desidera intercettare 
l'errore, per esempio:

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
L'esecuzione con successo di un comando con <literal>STRICT</literal> 
imposta sempre <literal>FOUND</literal> a true. 
    </para>

    <para>
Per <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> con 
<literal>RETURNING</literal>, <application>PL/pgSQL</application> riporta un errore
per più di una riga restituita, anche quando 
<literal>STRICT</literal> non è specificato. Questo perchè non c'è un opzione tipo  
la <literal>ORDER BY</literal> con la quale determinare  
quali righe coinvolte dovrebbero essere restituite.
    </para>

    <note>
     <para>
L'opzione <literal>STRICT</literal> corrisponde al comportamento di  
del comando Oracle PL/SQL <command>SELECT INTO</command> e relative istruzioni.
     </para>
    </note>

    <para>
Per gestire casi dove si ha bisogno di elaborare moltpeplici righe risultanti da una query SQL,
si veda <xref linkend="plpgsql-records-iterating"/>.
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
    <title>Eseguire comandi dinamici</title>

    <para>
Spesso si vorrà generare comandi dinamici all'interno delle funzioni
<application>PL/pgSQL</application>, cioè, comandi 
che coinvolgeranno differenti tabelle o diversi tipi di dato ogni volta che sono 
vengono eseguiti. I normali tentativi di  <application>PL/pgSQL</application> 
di sottoporre a cache i piani per i comandi (come discusso in
<xref linkend="plpgsql-plan-caching"/>) non funzioneranno in queste
situazioni. Per gestire questa sorta di problemi, è disponibile 
l'istruzione <command>EXECUTE</command>:

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

dove <replaceable>command-string</replaceable>  è un'espressione
che genera una stringa (di tipo <type>text</type>) contenente il comando  
che deve essere eseguito. L'opzionale <replaceable>target</replaceable>
è una variabile record, una variabile riga, o un elenco separato da virgole di 
semplici variabili e campi di riga/record, nei quali i risultati del 
comando saranno salavti. Le espressioni <literal>USING</literal> opzionali  
forniscono valori da essere inseriti nel comando.
    </para>

    <para>
Nessuna sostituzione di variabili <application>PL/pgSQL</application> viene fatta sulla
stringa comando calcolata. Qualsiasi valore della variabile deve essere inserito 
nella stringa comando come è costruito; o si possono usare parametri 
come descritto sotto.
    </para>

    <para>
Inoltre, il piano non viene sottoposto a cache per comandi eseguiti attraverso
<command>EXECUTE</command>. Invece, il comando 
viene preparato ogni volta che l'istruzione è eseguita. Così la stringa comando 
può essere creata dinamicamente all'interno della funzione per eseguire azioni 
su diverse tabelle e colonne.
    </para>

    <para>
La clausola <literal>INTO</literal> specifica dove dovrebbero essere assegnati 
i risultati di un comando SQL che restituisce righe. Se viene fornita  una riga
o elenco variabile, deve corrispondere esattamente la struttura 
dei risultati della query (quando è usata una 
variabile record, essa configurerà automaticamente sè stessa per corrispondere  
la struttura del risultato). Se vengono restituite molteplici righe, 
solo la prima sarà assegnata alla variabile <literal>INTO</literal>.
Se non sono restituite righe, alla variabile/i NULL viene assegnato NULL.
Se non è specificata la clausola <literal>INTO</literal>,
i risultati della query vengono scartati.
    </para>

    <para>
Se viene fornita l'opzione <literal>STRICT</literal>, viene riportato un errore  
finchè la query esattamente una riga.
    </para>

    <para>
La stringa del comando può usare valori parametro, che sono referenziati 
nel comando come <literal>$1</literal>, <literal>$2</literal>, ecc.
Questi simboli si riferiscono a valori forniti nella clausola  <literal>USING</literal>
Questo metodo spesso è preferibile per inserire valori di dati 
nella stringa comando come testo: elimina overhead in fase di esecuzione convertendo
i valori a testo e viceversa, ed è molto meno soggetta a attacchi di tipo SQL.injection
dato che non c'è necessità di effettuare il quoting o l'escaping.
Un esempio è:
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    <para>
Notare che i simboli parametro possono essere usati solo per valori di dati -
se si vogliono usare nomi di tabelle o colonne determinati dinamicamente,
si devono inserire testualmente nella stringa comando.
Per esempio, se la precedente query necessitava di essere fatta su una tabella 
selezionata dinamicamente, si potrebbe fare così:
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || tabname::regclass
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
Un'altra restrizione sui simboli parametro è che funzionano solo in comandi
<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, e
<command>DELETE</command>. In altri tipi di  istruzione
(chiamate genericamente istruzioni d'ulitità), si devono inserire 
i valori testualmente anche se sono solamente valori di dati.
    </para>

    <para>
Una <command>EXECUTE</command> con una semplice stringa di comando costante e alcuni
parametri <literal>USING</literal>, come nel primo esempio sopra, è funzionalmente 
equivalente a scrivere semplicemente il comando direttamente in 
<application>PL/pgSQL</application> e permettendo che la sostituzione di 
variabili <application>PL/pgSQL</application> accada automaticamente.
La differenza importante è che <command>EXECUTE</command> ripianificherà il
comando ad ogni esecuzione, generando un piano che è specifico 
per i valori del parametro corrente; mentre
<application>PL/pgSQL</application> normalmente crea un piano generico
e lo sottopone a cache per il riuso. In situazioni dove il piano migliore dipende 
fortemente dai valori dei parametri, <command>EXECUTE</command> può essere
significativamente veloce; mentre quando il piano non è sensibile ai valori 
dei parametri, ripianificare sarà uno spreco.
    </para>

    <para>
<command>SELECT INTO</command> attualmente non è supportato all'interno di 
<command>EXECUTE</command>; invece, eseguire un semplice comando <command>SELECT</command>
e specificare <literal>INTO</literal> come parte dell'<command>EXECUTE</command>
stesso.
    </para>

   <note>
    <para>
L'istruzione <command>EXECUTE</command> di <application>PL/pgSQL</application>
non è correlata con la funzione SQL 
<xref linkend="sql-execute"/> supportata
dal server <productname>PostgreSQL</productname>. La funzione <command>EXECUTE</command>
del server non può essere usata direttamente all'interno di funzioni
<application>PL/pgSQL</application> (e non è necessaria). 
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
   <title>Quotare valori in query dinamiche</title>

    <indexterm>
     <primary>quote_ident</primary>
     <secondary>uso in PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
     <secondary>uso in PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>uso in PL/PgSQL</secondary>
    </indexterm>

    <para>
Quando si lavora con comandi dinamici spesso di dovrà gestire l'escape di 
apici singoli. Il metodo raccomandato per quotare testo fisso nel corpo di una funziona 
è il quoting con dollari. (Se si ha codice datato che non usa  
la quotazione con dollari, si prega di riferirsi alla panoramica 
in <xref linkend="plpgsql-quote-tips"/>, che può far risprmiare qualche sforzo  
quando si traduce tale codice a uno schema più ragionevole).
    </para>

    <para>
Valori dinamici che devono essere iseriti nella query costruita  
richiedono una gestione attenta dato che potrebbero contenere 
caratteri apice.
Un esempio (quato assume che si stia usando la quotazione con dollari per l'intera
funzione, così gli apici non necessitano di essere raddoppiati):
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

    <para>
Questo esempio dimostra l'utilizzo delle funzioni 
<function>quote_ident</function> e
<function>quote_literal</function> (si veda <xref
linkend="functions-string"/>). Per sicurezza, espressioni contenenti identificatori 
di colonna o tabella dovrebbero essere passati attraverso
<function>quote_ident</function>  prima dell'inserimento in una query dinamica.
Espressioni contenenti valori che dovrebbero essere stringhe letterali nel comando 
costruito dovrebbero essere passate attraverso <function>quote_literal</function>.
Queste funzioni eseguono i passi appropriati a restituire il testo in input  
racchiuso rispettivamente tra apici doppi o singoli, con qualsiasi carattere speciale incluso
sottoposto a appropriatamente a  escape.
    </para>

    <para>
Dato che <function>quote_literal</function> è etichettata come 
<literal>STRICT</literal>, restituirà sempre null quando chiamata con un argomento null.
Nell'esempio sopra, se <literal>newvalue</literal> o 
<literal>keyvalue</literal> erano null, l'intera stringa di query dinamica diventerebbe null, 
generando un errore da <command>EXECUTE</command>.
È possibile evitare questo problema usando la funzione <function>quote_nullable</function>,
che lavora allo stesso modi di <function>quote_literal</function> ad accezione che 
quando chiamata con un argomento null restituisce la stringa <literal>NULL</literal>.
Per esempio,
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
Se si stanno trattando valori che potrebbero essere null, si dovrebbe di solito
usare <function>quote_nullable</function> al posto di <function>quote_literal</function>.
    </para>

    <para>
Come al solito, dev'essere posta attenzione che i valori null in una query
non portino a risultati non voluti. 
Per esempio la clausola <literal>WHERE</literal>
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
non avrà mai successo se <literal>keyvalue</literal> è null, dato che
il risultato di usare l'operatore uguale <literal>=</literal> con un operando null
è sempre null. Se si desidera che null funzioni come un valore chiave normale,
si dovrà riscrivere il sopra come
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
(Al momento, <literal>IS NOT DISTINCT FROM</literal> viene gestito molto meno
efficientemente di <literal>=</literal>, quindi non farlo a meno che non si debba.
Si veda <xref linkend="functions-comparison"/> per 
maggiori informazioni sui null e <literal>IS DISTINCT</literal>).
    </para>

    <para>
Notare che la quitazione con dollari è utile solo per quotare testo fisso.
Sarebbe una cattiva idea provare a scrivere questo esempio come:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
dato che si romperebbe se i contenuti di <literal>newvalue</literal>
contenessero <literal>$$</literal>.  La stessa obiezione si applicherebbe 
a qualsiasi altro delimitatore di quotazione con dollari si scelga.
Quindi, per quotare in sicurezza testo che non è conosciuto in anticipo, si 
<emphasis>deve</emphasis> usare <function>quote_literal</function>,
<function>quote_nullable</function> o <function>quote_ident</function>, in modo appropriato.
    </para>
   </example>

    <para>
Un esempio più vasto di comando dinamico e 
<command>EXECUTE</command> si trova in <xref
linkend="plpgsql-porting-ex2"/>, che costruisce ed esegue un comando
<command>CREATE FUNCTION</command> per definire una nuova funzione.
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
    <title>Ottenere lo stato del risultato</title>

    <para>
Ci sono diversi modi di determinare l'effetto di un comando. Il primo metodo 
è di usare il comando <command>GET DIAGNOSTICS</command>,
che ha la forma:

<synopsis>
GET DIAGNOSTICS <replaceable>variable</replaceable> = <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

Questo comando permettere il recupero di indicatori dello stato del sistema. Ogni
<replaceable>item</replaceable> è una parola chiave che identifica il valore di uno stato
da assegnare alla specifica variabile (che dovrebbe essere del giusto tipo per
riceverlo). Gli elementi di stato attualmente disponibili sono <varname>ROW_COUNT</varname>, 
il numero di righe elaborate dall'ultimo comando <acronym>SQL</acronym> 
mandato al motore <acronym>SQL</acronym>, e <varname>RESULT_OID</varname>,
l'OID dell'ultima riga inserita dal più recente
comando <acronym>SQL</acronym>. Notare che <varname>RESULT_OID</varname>
è utile solo dopo un comando <command>INSERT</command> in una tabella contenente
OID.
    </para>

    <para>
Un esempio:
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>

    <para>
Il secondo metodo per determinare gli effetti di un comando è di controllare 
la variabile speciale chiamata <literal>FOUND</literal>, che è di tipo
<type>boolean</type>.  <literal>FOUND</literal> all'inizio è
false all'interno di ogni chiamata di funzione <application>PL/pgSQL</application>.
È impostata da ognuno dei seguenti tipi di istruzione:

         <itemizedlist>
          <listitem>
           <para>
Un'istruzione <command>SELECT INTO</command> imposta 
<literal>FOUND</literal> a true se una riga viene assegnata, 
false se non viene restituita nessuna riga.
           </para>
          </listitem>
          <listitem>
           <para>
Un'istruzione <command>PERFORM</command> imposta <literal>FOUND</literal>
a true se produce (e scarta) una o più righe, false se non vengono prodotte righe.
           </para>
          </listitem>
          <listitem>
           <para>
Le istruzioni <command>UPDATE</command>, <command>INSERT</command>, e <command>DELETE</command>
impostano <literal>FOUND</literal> a true se almeno una riga è coinvolta, 
false se nessuna riga è interessata.
           </para>
          </listitem>
          <listitem>
           <para>
Un'istruzione <command>FETCH</command> imposta <literal>FOUND</literal>
a true se restituisce una riga, false se non viene restituita nessuna riga.
           </para>
          </listitem>
          <listitem>
           <para>
Un'istruzione <command>MOVE</command> imposta <literal>FOUND</literal> a true
se riposiziona con successo il cursore, altrimenti false.
           </para>
          </listitem>

          <listitem>
           <para>
Un'istruzione <command>FOR</command> imposta <literal>FOUND</literal> a true
se itera una o più volte, altrimenti false. Questo si applica a tutte le quattro varianti di 
dell'istruzione <command>FOR</command> (cicli <command>FOR</command> di interi, 
cicli <command>FOR</command> di insiemi di record, cicli <command>FOR</command> di
insiemi di record dinamici e cicli <command>FOR</command> di cursori).
<literal>FOUND</literal> è impostato in questo modo quando 
il ciclo <command>FOR</command> esiste; all'interno dell'esecuzione del loop,
<literal>FOUND</literal> non viene modificato dall'istruzione 
<command>FOR</command>, sebbene potrebbe essere cambiato dall'esecuzione
di altre istruzioni all'interno del corpo del ciclo.
           </para>
          </listitem>
          <listitem>
           <para>
Le istruzioni <command>RETURN QUERY</command> e <command>RETURN QUERY
EXECUTE</command> impostano <literal>FOUND</literal>
a true se la query restituisce almeno una riga, false se non viene restituita nessuna riga.
           </para>
          </listitem>
         </itemizedlist>

Altre istruzioni <application>PL/pgSQL</application> non camnbiano
lo stato di <literal>FOUND</literal>.
Notare in particolare che <command>EXECUTE</command> cambia l'output
di <command>GET DIAGNOSTICS</command>, ma non cambia 
<literal>FOUND</literal>.
    </para>

    <para>
<literal>FOUND</literal> è una variabile locale all'interno di ogni 
funzione <application>PL/pgSQL</application>; qualsiasi cambiamento di essa
interessa solo la funzione corrente.
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
    <title>Non fare assolutamente niente</title>

    <para>
A volte è utile un'istruzione "segnaposto" che non faccia niente.
Per esempio, potrebbe indicare che un anello della catena if/then/else
è deliberatamente vuoto. Per questo scopo, usare l'istruzione
<command>NULL</command>:

<synopsis>
NULL;
</synopsis>
    </para>

    <para>
Per esempio, i seguenti due frammenti di codice sono equivalenti:
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- ignorare l'errore
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- ignorare l'errore
END;
</programlisting>
Quale sia preferibile è una questione di gusti.
    </para>

    <note>
     <para>
In  PL/SQL di Oracle, elenchi di istruzione vuoti non sono permessi, e quindi 
le istruzioni <command>NULL</command> sono <emphasis>richieste</emphasis> per situazioni
come questa. <application>PL/pgSQL</application> invece permette di non scrivere niente.
     </para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
   <title>Strutture di controllo</title>

   <para>
Le strutture di controllo sono probabilmente la parte più utile (e
importante) di <application>PL/pgSQL</application>. Con le
strutture di controllo di <application>PL/pgSQL</application>,
è possibile manipolare i dati di <productname>PostgreSQL</productname>
in modo molto flessibile e potente.
   </para>

   <sect2 id="plpgsql-statements-returning">
    <title>Ritorno da una funzione</title>

    <para>
Ci sono due comandi disponibili che permettono di restituire dati 
da una funzione: <command>RETURN</command> e <command>RETURN
NEXT</command>.
    </para>

    <sect3>
     <title><command>RETURN</command></title>

<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <para>
<command>RETURN</command> con un'espressione termina la funzione
e ritorna il valore di 
<replaceable>expression</replaceable> al chiamante. Questa forma è usata 
per funzioni <application>PL/pgSQL</application> che non restituiscono un
insieme.
     </para>

     <para>
Quando si restituisce un tipo scalare, può essere usata qualsiasi espressione. 
Il risultato dell'espressione sarà automaticamente convertito al tipo di 
ritorno della funzione come descritto per le assegnazioni. Per restituire un valore
composto (riga), si deve scrivere una variabile record o riga
come <replaceable>expression</replaceable>.
     </para>

     <para>
Se si dichiara la funzione con parametri di output, scrivere solo
<command>RETURN</command> senza espressione. Saranno restituiti i 
valori attuali dei parametri di 
output. 
     </para>

     <para>
Se si dichiara la funzione per ritornare <type>void</type>, un'istruzione
<command>RETURN</command> può essere usata per uscire dalla funzione
in anticipo; ma non scrivere un espressione dopo 
<command>RETURN</command>.
     </para>

     <para>
Il valore di ritorno di una funzione non può essere lasciato indefinito. Se
il controllo raggiunge la fine del blocco superiore della funzione
senza incontrare un'istruzione <command>RETURN</command>, viene generato un errore
in fase di esecuzione. Questa restrizione comunque non si applica a funzioni
con parametri di output e funzioni che restituiscono <type>void</type>.
In quei casi un'istruzione <command>RETURN</command> viene eseguita automaticamente 
quando il blocco superiore finisce.
     </para>
    </sect3>

    <sect3>
     <title><command>RETURN NEXT</command> e <command>RETURN QUERY</command></title>
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/PgSQL</secondary>
    </indexterm>
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/PgSQL</secondary>
    </indexterm>

<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     <para>
Quando una funzione <application>PL/pgSQL</application> viene dichiarata per restituire
<literal>SETOF <replaceable>sometype</replaceable></literal>, la procedura
da seguire e leggermente diversa. In quel caso, gli elementi individuali 
da restituire sono specificati da una sequenza di comandi <command>RETURN
NEXT</command> o <command>RETURN QUERY</command>, e 
quindi un comando <command>RETURN</command> finale senza argomenti
viene usato epr indicare che la funzione ha terminato l'esecuzione.
<command>RETURN NEXT</command> può essere usato sia con tipi di dato scalari che composti;
con un tipo di risultato composto, sarà restituita un'intera <quote>table</quote>.
<command>RETURN QUERY</command> aggiunge i risultati dell'esecuzione di una query
all'insieme dei risultati della funzione. <command>RETURN
NEXT</command> e <command>RETURN QUERY</command> possono essere liberamente
interscambiati in una singola funzione che ritorna un insieme, nel qual caso 
i loro risultati saranno concatenati.
     </para>

     <para>
<command>RETURN NEXT</command> e <command>RETURN
QUERY</command> in realtà non ritornano dalla funzione -
semplicemente aggiungono zero o più righe al risultato di una funzione.
L'esecuzione quindi continua con la prossima istruzione nella funzione 
<application>PL/pgSQL</application>. Come vengono eseguiti successivi
comandi <command>RETURN NEXT</command> o <command>RETURN
QUERY</command>, l'insieme risultato è formato.
Un <command>RETURN</command> finale, che non dovrebbe avere argomenti,
causa che il controllo esca dalla funzione (o è possibile
lasciare che il controllo raggiunga la fine della funzione).
     </para>

     <para>
<command>RETURN QUERY</command> ha una variante 
<command>RETURN QUERY EXECUTE</command>, che specifica che la query sia 
eseguita dinamicamente. Espressioni di parametro possono essere inserite 
nella stringa calcolata della query attraverso <literal>USING</literal>,
nello stesso modo del comando <command>EXECUTE</command>.
     </para>

     <para>
Se si è dichiarata la funzione senza parametri di output, scrivere
solo <command>RETURN NEXT</command>  senza espressione. Ad ogni esecuzione,  
i valori correnti della variabile/i parametro di output saranno salvati 
per l'eventuale ritorno come riga del risultato.
Si noti che si deve dichiarare la funzione in modo che ritorni  
<literal>SETOF record</literal> quando ci sono molteplici parametri di output, 
o <literal>SETOF <replaceable>sometype</replaceable></literal>
quando c'è sono un parametro di output di tipo
<replaceable>sometype</replaceable>, per creare una funzione che restituisce un insieme 
con parametri di output.
     </para>

     <para>
Ecco un esempio di una funzione che usa  <command>RETURN
NEXT</command>:

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION getAllFoo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEgin
    FOR r IN SELECT * FROM foo
    WHERE fooid &gt; 0
    LOOP
        -- qui è possibile fare elaborazioni
        RETURN NEXT r; -- restituisce la riga corrente della SELECT
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE 'plpgsql' ;

SELECT * FROM getallfoo();
</programlisting>
     </para>

     <note>
      <para>
L'implementazione corrente di <command>RETURN NEXT</command>
e <command>RETURN QUERY</command> salva l'intero insieme dei risultati  
prima di ritornare dalla funzione, come discusso sopra. Questo significa
che se una funzione <application>PL/pgSQL</application> produce un insieme di risultati molto grande,
le prestazioni potrebbero risentirne: i dati saranno scritti su disco
per evitare l'esaurimento della memoria, ma la funzione 
stessa non ritornerà finchè l'intero insieme dei risultati sia
stato generato. Una versione futura di <application>PL/pgSQL</application> potrebbe
permettere agli utenti di definire funzioni che ritornano insiemi 
che non hanno questa limitazione. Attualmente, il punto in cui i dati 
cominciano ad essere scritti su disco è controllato dalla variabile di configurazione 
<xref linkend="guc-work-mem"/>.
Gli amministratori che hanno memoria sufficiente per immagazzinare 
in memoria grandi insiemi di risultati dovrebbero considerare 
l'incremento di questo parametro.
      </para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-conditionals">
    <title>Condizioni</title>

    <para>
Le istruzioni <command>IF</command> e <command>CASE</command> ti permettono 
di eseguire comandi alternativi in base a certe condizioni.
<application>PL/pgSQL</application> ha tre forme di <command>IF</command>:
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE</literal></para>
     </listitem>
    </itemizedlist>

    e due forme di <command>CASE</command>:
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
Le istruzioni <literal>IF-THEN</literal> sono la forma più semplice di 
<literal>IF</literal>. Le istruzioni tra 
<literal>THEN</literal> e <literal>END IF</literal> saranno
eseguite se la condizione è true.  Altrimenti, vengono 
saltate.
       </para>

       <para>
Esempio:
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
Le istruzioni <literal>IF-THEN-ELSE</literal> si aggiungono a 
<literal>IF-THEN</literal> permettendo di specificare un insieme di istruzioni
alternative che dovrebbero essere eseguite se la condizione 
non è true. (Notare che questo include i casi dove la condizione è valutata
essere NULL).
       </para>

       <para>
Esempi:
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <para>
A volte ci sono più di due sole alternative. 
<literal>IF-THEN-ELSIF</literal> fornisce un metodo conveniente 
di controllare a turno diverse alternative. 
Le condizioni  <literal>IF</literal> sono testate successivamente
finchè la prima che è true viene trovata. Quindi 
l'istruzione/i associate sono eseguite, dopo le quali il controllo
passa alla prossima istruzione dopo <literal>END IF</literal>.
(Ogni successiva condizione <literal>IF</literal> <emphasis>non</emphasis> è testata).
Se nessuna delle condizioni <literal>IF</literal> è true,
allora viene eseguito il blocco <literal>ELSE</literal> (se presente). 
       </para>

       <para>
Ecco un esempio:

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- hmm, l'unica altra possibilità è che il numero sia null
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <para>
La parola chiave <literal>ELSIF</literal> può essere scritta anche
<literal>ELSEIF</literal>.
       </para>

       <para>
Un modo alternativo di svolgere lo stesso compito è di annidare le  istruzioni
<literal>IF-THEN-ELSE</literal>, come nell'esempio seguente:

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <para>
Comunque, questo metodo richiede la scrittura di un corrispondente <literal>END IF</literal>
per ogni <literal>IF</literal>, quindi è molto più scomodo rispetto ad usare
<literal>ELSIF</literal> quando ci sono molte alternative.
       </para>
     </sect3>

     <sect3>
      <title><literal>CASE</literal> semplice</title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
La forma semplice di <command>CASE</command> fornisce l'esecuzione condizionale 
basata sull'uguaglianza di operandi. La <replaceable>search-expression</replaceable>
viene valutata (una volta) e successivamente confrontata con ogni
<replaceable>expression</replaceable> nelle clausole <literal>WHEN</literal>.
Se viene trovata una corrispondenza, allora le corrispondenti 
istruzioni <replaceable>statements</replaceable> sono eseguite, e quindi il controllo
passa all'istruzione successiva dopo <literal>END CASE</literal>.  (Successive 
espressioni <literal>WHEN</literal> non sono valutate). Se non viene trovata nessuna corrispondenza,
vengono eseguite le istruzioni <replaceable>statements</replaceable> <literal>ELSE</literal>;
ma se <literal>ELSE</literal> non è presente, allora viene generata un'eccezione  
<literal>CASE_NOT_FOUND</literal>.
      </para>

      <para>
Ecco un semplice esempio:

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
      <title><literal>CASE</literal> cercato</title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
La forma cercata di <command>CASE</command> fornisce l'esecuzione condizionale
basata sulla verità di espressioni Booleane. Ogni <replaceable>boolean-expression</replaceable>
della clausola <literal>WHEN</literal> viene valutata a turno,
finchè non ne viene trovata una che risulta <literal>true</literal>. Quindi 
le corrispondenti istruzioni <replaceable>statements</replaceable> vengono eseguite, e
poi il controllo passa alla successiva istruzione dopo <literal>END CASE</literal>.
(Successive espressioni <literal>WHEN</literal> non sono valutate).
Se non vengono trovati risultati true, allora vengono eseguite 
le istruzioni <replaceable>statements</replaceable>
<literal>ELSE</literal>;
ma se  <literal>ELSE</literal> non è presente, allora viene generata un'eccezione
<literal>CASE_NOT_FOUND</literal>.
      </para>

      <para>
Ecco un esempio:

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

      <para>
Questa forma di <command>CASE</command> è completamente equivalente a 
<literal>IF-THEN-ELSIF</literal>, ad eccezione della regola per cui raggiungere 
una clausola <literal>ELSE</literal> omessa genera un errore invece di non fare niente.
      </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
    <title>Cicli semplici</title>

    <indexterm zone="plpgsql-control-structures-loops">
     <primary>ciclo</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
Con le istruzioni <literal>LOOP</literal>, <literal>EXIT</literal>,
<literal>CONTINUE</literal>, <literal>WHILE</literal> e <literal>FOR</literal>,
è possibile fare in modo che la funzione <application>PL/pgSQL</application>
ripeta una serie di comandi.
    </para>

    <sect3>
     <title><literal>LOOP</literal></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <para>
<literal>LOOP</literal> definisce un ciclo incondizionato che viene ripetuto 
indefinitzmente finchè terminato da un'istruzione <literal>EXIT</literal> o
<command>RETURN</command>. L'etichetta <replaceable>label</replaceable> opzionale
può essere usata dalle istruzioni <literal>EXIT</literal> e 
<literal>CONTINUE</literal> all'interno di cicli annidati per specificare 
a quale ciclo si riferiscono quelle istruzioni.
     </para>
    </sect3>

     <sect3>
      <title><literal>EXIT</literal></title>

     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
Se nessuna <replaceable>label</replaceable> è fornita, il ciclo 
più interno viene terminato e l'istruzione seguente <literal>END
LOOP</literal> viene eseguita. Se <replaceable>label</replaceable> 
è fornita, deve essere l'etichetta del ciclo annidato o del blocco corrente o esterno.
Quindi il ciclo nominato o il blocco viene terminato 
e il controllo continua con l'istruzione dopo la <literal>END</literal>
corrispondente del ciclo/blocco.
       </para>

       <para>
Se <literal>WHEN</literal> è specificato, l'uscita dal ciclo avviene solo se 
<replaceable>boolean-expression</replaceable> è true. Altrimenti, il controllo passa 
all'istruzione dopo <literal>EXIT</literal>.
       </para>

       <para>
<literal>EXIT</literal> può essere usato con tutti i tipi di ciclo; non è limitato all'utilizzo 
con cicli incondizionali. 
       </para>

       <para>
Quando usato con un blocco
<literal>BEGIN</literal>, <literal>EXIT</literal> passa il controllo
alla successiva istruzione dopo la fine del blocco. 
Notare che una etichetta deve essere usata per questo scopo; una 
<literal>EXIT</literal> senza etichetta non è mai considerata corrispondente a
un blocco <literal>BEGIN</literal>. (Questo è un cambiamento rispetto 
alle versioni precedenti la 8.4 di <productname>PostgreSQL</productname>, che
avrebbero permesso a una <literal>EXIT</literal> senza etichetta di corrispondere a un
blocco <literal>BEGIN</literal>).
       </para>

       <para>
Esempi:
<programlisting>
LOOP
    -- alcuni calcoli
    IF count &gt; 0 THEN
        EXIT;  -- esce dal ciclo
    END IF;
END LOOP;

LOOP
    -- alcuni calcoli
    EXIT WHEN count &gt; 0;  -- stesso risultato dell'esempio precedente
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- alcuni calcoli
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- causa l'uscita dal blocco BEGIN
    END IF;
    -- i calcoli qui saranno saltati quando stocks &gt; 100000
END;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</literal></title>

     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
Se non viene fornita nessuna <replaceable>label</replaceable>, la successiva iterazione 
del ciclo più interno è iniziata. Cioè, tutte le istruzioni restanti
nel corpo del ciclo sono saltate, e il controllo ritorna all'espressione 
di controllo del ciclo (se presente) per determinare se
un'altra iterazione del loop è necessaria.
Se <replaceable>label</replaceable> è presente, specifica  
l'etichetta del ciclo la cui esecuzione sarà continuata.
       </para>

       <para>
Se <literal>WHEN</literal> è specificata, la successiva iterazione del ciclo 
è cominciata solo se <replaceable>boolean-expression</replaceable> è
true. Altrimenti, il controllo passa all'istruzione dopo 
<literal>CONTINUE</literal>.
       </para>

       <para>
<literal>CONTINUE</literal> puù essere usato con tutti i tipi di ciclo; non è 
limitato all'uso con cicli incondizionali.
       </para>

       <para>
Esempi:
<programlisting>
LOOP
    -- alcuni calcoli
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- alcuni calcoli per count IN [50 .. 100]
END LOOP;
</programlisting>
       </para>
     </sect3>


     <sect3>
      <title><literal>WHILE</literal></title>

     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
L'istruzione <literal>WHILE</literal> ripete una sequenza di istruzioni
finchè l'espressione <replaceable>boolean-expression</replaceable>
risulta true. L'espressione è controllata appena prima 
ogni ingresso nel corpo del ciclo.
       </para>

       <para>
Per esempio:
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- alcuni calcoli qui
END LOOP;

WHILE NOT done LOOP
    -- alcuni calcoli qui
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
      <title><literal>FOR</literal> (variante intera)</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
Questa forma di <literal>FOR</literal> crea un ciclo che itera su un intervallo
di valori interi. La variabile 
<replaceable>name</replaceable> viene definita automaticamente come 
tipo  <type>integer</type> ed esiste solo all'interno del ciclo (qualsiasi 
definizione esistente del nome della variabile viene ignorata all'interno del ciclo).
Le due espressioni che forniscono il limite inferiore e superiore dell'intervallo
sono calcolate una volta quando si entra nel ciclo. 
Se la clausola <literal>BY</literal> non è specificata, il passo di iterazione è
1, altrimenti è il valore specificato nella clausola <literal>BY</literal>,
che di nuovo viene clcolato una volta all'ingresso del ciclo.
Se <literal>REVERSE</literal> è specificato allora il valore dell'incremento è 
sottratto, invece che aggiunto, dopo ogni iterazione.
       </para>

       <para>
Alcuni esempi di cicli <literal>FOR</literal> di interi:
<programlisting>
FOR i IN 1..10 LOOP
    -- i assumerà i valori 1,2,3,4,5,6,7,8,9,10 all'interno del ciclo
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- i assumerà i valori 10,9,8,7,6,5,4,3,2,1 all'interno del ciclo
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- i assumerà i valori 10,8,6,4,2 all'interno del ciclo
END LOOP;
</programlisting>
       </para>

       <para>
Se il limite inferiore è maggiore del limite superiore (o minore di,
nel caso di <literal>REVERSE</literal>), il corpo del ciclo non 
viene eseguito. Non viene generato errore.
       </para>

       <para>
Se una etichetta <replaceable>label</replaceable> viene assegnata al ciclo 
<literal>FOR</literal> allora ci si può riferire alla variabile ciclo di interi 
con un nome qualificato, usando quell'etichetta
<replaceable>label</replaceable>.
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
    <title>Cicli attraverso i risultati di una query</title>

    <para>
Usando un tipo diverso di ciclo <literal>FOR</literal>, è possibile iterare attraverso
i risultati di una query e manipolare quei dati 
di conseguenza. La sintassi è:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
Il <replaceable>target</replaceable> è una variabile record, variabile riga, o 
elenco separato da virgole di variabili scalari.
Il <replaceable>target</replaceable> successivamemente è assegnato ad ogni riga 
risultante dalla  <replaceable>query</replaceable> e il corpo del ciclo viene 
eseguito per ogni riga. Ecco un esempio:
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    PERFORM cs_log('Refreshing materialized views...');

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- Adesso "mviews" ha un record da cs_materialized_views

        PERFORM cs_log('Refreshing materialized view '
                   || quote_ident(mviews.mv_name) || ' ...');
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);
        EXECUTE 'INSERT INTO '
                   || quote_ident(mviews.mv_name) || ' '
                   || mviews.mv_query;
    END LOOP;

    PERFORM cs_log('Done refreshing materialized views.');
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Se il ciclo è terminato da un'istruzione <literal>EXIT</literal>, l'ultimo
valore assegnato della riga è comunque accessibile dopo il ciclo.

    </para>

    <para>
La <replaceable>query</replaceable> usata in questo tipo di istruzione <literal>FOR</literal>
può essere qualsiasi comando SQL che ritorna righe al chiamante:
<command>SELECT</command> è il caso più comune, 
ma si possono usare anche <command>INSERT</command>, <command>UPDATE</command>, o
<command>DELETE</command> con una clausola <literal>RETURNING</literal>. 
Funzioneranno anche alcuni comandi di utilità
tipo <command>EXPLAIN</command>. 
    </para>

    <para>
Le variabili <application>PL/pgSQL</application> sono sostituiti nel testo della query,
e il piano della query è sottoposto a cache per un possibile riutilizzo, come discusso in
dettaglio in <xref linkend="plpgsql-var-subst"/> e
<xref linkend="plpgsql-plan-caching"/>.
    </para>

    <para>
L'istruzione <literal>FOR-IN-EXECUTE</literal> rappresenta un altro modo di iterare 
le righe:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
Questo è simile alla forma precedente, ad eccezione che la query sorgente 
viene specificata come una espressione stringa, che è calcolata e ripianificata 
ad ogni voce del ciclo <literal>FOR</literal>. Questo permette al programmatore di 
scegliere la velocità di una query prepianificata o la flessibilità di una query dinamica, 
proprio come con una normale istruzione  <command>EXECUTE</command>.
Come con <command>EXECUTE</command>, i valori dei parametri possono essere inseriti 
nel comando dinamico con <literal>USING</literal>.
    </para>

    <para>
Un altro modo di specificare la query i cui risultati dovrebbero essere iterati
è di dichiararla come cursore. Questo è descritto in
<xref linkend="plpgsql-cursor-for-loop"/>.
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
    <title>Trapping Errors</title>

    <indexterm>
     <primary>eccezioni</primary>
     <secondary>in PL/PgSQL</secondary>
    </indexterm>

    <para>
In maniera predefinitia, qualsiasi errore accada in una funzione <application>PL/pgSQL</application>
annulla l'esecuzione della funzione, ed effettivamente anche la transazione circostante. 
È possibile intrappolare gli errori e ripristinarli usando un blocco <command>BEGIN</command> 
con una clausola <literal>EXCEPTION</literal>. La sintassi è una  estensione 
della sintassi normale di un blocco <command>BEGIN</command>:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>

    <para>
Se non si verificano errori, questa forma di blocco semplicemente esegue tutte le
istruzioni <replaceable>statements</replaceable>, e quindi il controllo passa
alla successiva istruzione dopo <literal>END</literal>. Ma se un errore
accade all'interno di <replaceable>statements</replaceable>, l'ulteriore elaborazione
di istruzioni <replaceable>statements</replaceable> viene abbandonata,
e il controllo passa all'elenco <literal>EXCEPTION</literal>.
L'elenco viene cercato per la prima <replaceable>condition</replaceable>
corrispondente all'errore accaduto. Se viene trovata una corrispondenza, 
vengono eseguite le corrispondenti istruzioni <replaceable>handler_statements</replaceable>,
e quindi il controllo passa alla successiva istruzione dopo 
<literal>END</literal>. Se non vengono trovate corrispondenze, l'errore si propaga  
sebbene la clausola <literal>EXCEPTION</literal> non ci fosse stata:
l'errore può essere catturato da un blocco con <literal>EXCEPTION</literal>,
o se non ce ne sono esso annulla l'elaborazione della funzione.
    </para>

    <para>
I nomi delle condizioni <replaceable>condition</replaceable> possono essere 
qualsiasi di quelli mostrati in <xref linkend="errcodes-appendix"/>. Un nome di categoria
corrisponde a qualsiasi errore all'interno della sua categoria. Il nome della condizione speciale
<literal>OTHERS</literal> corrisponde ad ogni tipo di errore ad eccezione di 
<literal>QUERY_CANCELED</literal>.  (È possibile, ma spesso imprudente,
intercettare <literal>QUERY_CANCELED</literal> dal nome). I nomi delle condizioni non 
sono sensibili al case. Inoltre, una condizione di errore può essere specificata
dal codice <literal>SQLSTATE</literal>; per esempio, questi sono equivalenti:
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

    <para>
Se succede un nuovo errore all'interno delle istruzioni 
<replaceable>handler_statements</replaceable>, non può essere catturato 
da questa clausola <literal>EXCEPTION</literal>, ma viene propagato al di fuori.
Una clausola <literal>EXCEPTION</literal> circostante potrebbe intercettarlo.
    </para>

    <para>
Quando un errore è catturato da una clausola <literal>EXCEPTION</literal>,
le variabili locali della funzione <application>PL/pgSQL</application>
rimangono come erano quando l'errore è accaduto, ma tutti i cambiamenti
allo stato persistente del database all'interno del blocco sono sottoposti a rollback.
Come esempio, considerare questo frammento:

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEgin
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

Quando il controllo raggiunge l'assegnazione a <literal>y</literal>, fallirà
con un errore <literal>division_by_zero</literal>. Questo sarà catturato dalla 
clausola <literal>EXCEPTION</literal>. Il valore restituito nell'istruzione 
<command>RETURN</command> sarà il valore incrementato di
<literal>x</literal>, ma gli effetti del comando <command>UPDATE</command> saranno stati
sottoposti a rollback. Il comando <command>INSERT</command> precedente il blocco 
non è sottoposto a rollback, comunque, quindi il risultato finale è che il database
contiene <literal>Tom Jones</literal> e  non <literal>Joe Jones</literal>.

    </para>

    <tip>
     <para>
Un blocco contenente una clausola <literal>EXCEPTION</literal> è significativamente 
più costoso da entrare e uscire rispetto a un blocco senza. Per questo,
non usare <literal>EXCEPTION</literal> senza bisogno.
     </para>
    </tip>

    <para>
All'interno di un gestore di eccezione, la variabile <varname>SQLSTATE</varname>
contiene il codice dell'errore che corrisponde all'eccezione che è
stata generata (si veda <xref
linkend="errcodes-table"/> per un elenco dei possibili codici di errore).
La variabile <varname>SQLERRM</varname> contiene il messaggio di errore 
associato con l'eccezione. Queste variabili sono 
indefinite all'esterno del gestore di eccezione.
    </para>

    <example id="plpgsql-upsert-example">
    <title>Eccezioni con <command>UPDATE</command>/<command>INSERT</command></title>
    <para>

Questo esempio usa la gestione delle eccezioni per eseguire o una 
<command>UPDATE</command> o una <command>INSERT</command>, come appropriato:

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEgin
    LOOP
        -- prima prova ad aggiornare la chiave 
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- non trovata, quindi prova ad inserire la chiave
        -- se qualcun altro inserisce la stessa chiave concorrentemente,
        -- potremmo ottenere un fallimento unique-key
        BEgin
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- non fa niente, e cicla per provare di nuovo l'UPDATE
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

    </para>
    </example>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
   <title>Cursori</title>

   <indexterm zone="plpgsql-cursors">
    <primary>cursore</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   <para>
Piuttosto che eseguire l'intera query tutta insieme, è possibile impostare un 
<firstterm>cursore</firstterm> che incapsula la query, e quindi legge 
il risultato della query un po' di righe alla volta. Un aragione per fare questo è
di evitare l'eccedere di memoria quando il risultato contiene un gran numero di 
righe. (Comunque, gli utenti di <application>PL/pgSQL</application>  normalmente non devo preoccuparsi
di questo, dato che i cicli <literal>FOR</literal> internamente usano automaticamente un cursore
per evitare problemi di memoria). Un utilizzo più interessante e di 
restituire un riferimento a un cursore che una funzione ha creato, permettendo 
al chiamante di leggere le righe. Questo fornisce un modo efficiente di restituire 
grandi insiemi di righe da funzioni.
   </para>

   <sect2 id="plpgsql-cursor-declarations">
    <title>Dichiarare variabili cursore</title>

    <para>
Tutto l'accesso ai cursori in <application>PL/pgSQL</application> avviene attraverso
variabili cursore, che sono sempre del tipo 
<type>refcursor</type>. Un modo di creare una variabile cursore 
e semplicemente dichiararla come variabile del tipo <type>refcursor</type>.
Un altro modo è di usare la sintassi di dichiarazione di cursore, 
che in generale è:
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
(<literal>FOR</literal> può essere sostituito da <literal>IS</literal> per 
compatibilità <productname>Oracle</productname>).
Sei viene specificato <literal>SCROLL</literal>, il cursore sarà capace di
scorrere all'indietro; se è specificato <literal>NO SCROLL</literal>, saranno rifiutate   
ricerche all'indietro; se non appare nessuna delle due specifiche, dipenderà dalla query 
se saranno permesse ricerche all'indietro. 
<replaceable>arguments</replaceable>, se specificato, è un elenco
separato da virgole di coppie <literal><replaceable>name</replaceable>
<replaceable>datatype</replaceable></literal> che definisce i nomi da essere 
sostituiti da valori dei parametri nella data query. I valori effettivi
da sostituire per questi nomi saranno specificati più tardi,
quando il cursore è aperto.
    </para>
    <para>
Alcuni esempi:
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
Tutte e tre queste variabili hanno il tipo di dato <type>refcursor</type>,
ma la prima può essere usata con qualsiasi query, mentre la seconda ha
una query completamente specificata già <firstterm>legata</firstterm> ad essa, e l'ultima
ha una query parametrizzata legata. (<literal>key</literal> sarà 
sostituita da un valore di parametro intero quando il cursore è aperto).
La variabile <literal>curs1</literal>
è detta essere <firstterm>non legata</firstterm> dato che non è legata a  nessuna 
query particolare.
    </para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
    <title>Aprire cursori</title>

    <para>
Prima che un cursore possa essere usato per recuperare righe, deve essere
<firstterm>aperto</firstterm>. (Questa è l'azione equivalente al comando SQL
<command>DECLARE CURSOR</command>). <application>PL/pgSQL</application> ha 
tre forme di istruzione <command>OPEN</command>, due delle quali usano variabili cursore
non legate mentre la terza usa una variabile cursore legata.
    </para>

    <note>
     <para>
Variabili di cursore legate possono anche essere usate senza aprire esplicitamente il cursore,
attraverso l'istruzione <command>FOR</command> descritta in
<xref linkend="plpgsql-cursor-for-loop"/>.
     </para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

       <para>
La variabile cursore è aperta ed è fornita la specifica query da eseguire.
Il cursore non può essere già aperto, e deve essere stato
dichiarato come una variabile cursore non legata (cioè, come semplice
variabile <type>refcursor</type>). La query deve essere una 
<command>SELECT</command>, o qualcos'altro che restituisce righe
(tipo <command>EXPLAIN</command>). La query
viene trattata allo stesso modo di altri comandi SQL in 
<application>PL/pgSQL</application>: i nomi delle variabili <application>PL/pgSQL</application>
sono sostituiti, e il piano della query viene sottoposto a cache per 
il possibile riuso. Quando una variabile <application>PL/pgSQL</application>
è sostituita nella query cursore, il valore che è sostituito 
è quello che era al momento della <command>OPEN</command>;
cambiamenti successivi alla variabile non avranno effetti sul comportamento
del cursore.
Le opzioni <literal>SCROLL</literal> e <literal>NO SCROLL</literal>
hanno gli stessi significati come per un cursore legato.
       </para>

       <para>
Un esempio:
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

         <para>
La variabile cursore è aperta è viene fornita la speifica query da eseguire.
Il cursore non può essere già aperto, e deve essere stato dichiarato come una variabile
dichiarata come un cursore non legato (cioè, come una semplice variabile
<type>refcursor</type>). La query è specificata come una espressione stringa,
nello stesso modo del comando <command>EXECUTE</command>.
Come al solito, questo dà flessibilità e così il piano della query può variare
da un'esecuzione ad un'altra (si veda <xref linkend="plpgsql-plan-caching"/>),
e significa anche che la sostituzione di variabili non viene fatta sulla stringa comando.
Come con <command>EXECUTE</command>, i valori dei parametri 
possono essere inseriti nel comando dinamico con <literal>USING</literal>.
Le opzioni <literal>SCROLL</literal> e <literal>NO SCROLL</literal>
hanno gli stessi significati come per un cursore legato.
         </para>

       <para>
Un esempio:
<programlisting>
OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)
                                        || ' WHERE col1 = $1' USING keyvalue;
</programlisting>
In questo esempio, il nome della tabella è inserito nella query testualmente,
così l'uso di <function>quote_ident()</function> è raccomandato per proteggersi contro 
le SQL injection. Il valore di confronto per <literal>col1</literal> è inserito 
attraverso un parametro <literal>USING</literal>, così non ha bisogno di quotazione.
       </para>
     </sect3>

    <sect3>
     <title>Aprire una cursore legato</title>

<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <replaceable>argument_values</replaceable> ) </optional>;
</synopsis>

         <para>
Questa forma di <command>OPEN</command> è usata per aprire una variabile 
cursore la cui query era legata ad esso quando fu dichiarato. Il cursore   
non può essere già aperto. Un elenco di espressioni argomento effettive 
deve apparire se e solo se il cursore è stato dichiarato per prendere argomenti.
Questi valori saranno sostituiti nella query. 
Il piano della query per un cursore legato è sempre considerato sottoponibile a cache;
non c'è un equivalente di <command>EXECUTE</command> in questo caso.
Notare che <literal>SCROLL</literal> e 
<literal>NO SCROLL</literal> non possono essere specificate, dato che il comportamento  
dello scorrimento del cursore era già stato determinato.
         </para>

         <para>
Notare che dato che la sostituzione di variabili è fatta sulla query del cursore legato,
ci sono due modi di passare valori al cursore:
o con un argomento esplicito a <command>OPEN</command>, o
implicitamente facendo riferimento a una variabile <application>PL/pgSQL</application>
nella query. Comunque, solo le variabili dichiarate prima che il cursore legato 
fosse dichiarato saranno sostituite in essa. In entrambi i casi 
il valore da essere passato è determinato al momento della
<command>OPEN</command>.
         </para>

    <para>
     Esempi:
<programlisting>
OPEN curs2;
OPEN curs3(42);
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
    <title>Usare i cursori</title>

    <para>
Una volta che un cursore è stato aperto, può essere manipolato con
le istruzioni descritte qui.
    </para>

    <para>
Queste manipolazioni non devono avvenire nella stessa funzione che 
ha aperto il cursore all'inizio. È possibile restituire un valore <type>refcursor</type>
da una funzione e lasciare operare il chiamante sul cursore.
(Internamente, un valore <type>refcursor</type> è semplicemenete in nome della stringa
di un portale così chiamato contenente la query attiva per il cursore. Questo nome
può essere passato in giro, assegnato ad altre variabili <type>refcursor</type>,
e così via, senza disturbare il portale).
    </para>

    <para>
Tutti i portali sono implicitamente chiusi alla fine della transazione. Quindi
un valore <type>refcursor</type> è usabile per riferirsi a un cursore aperto 
solo fino alla fine della transazione.
    </para>

    <sect3>
     <title><literal>FETCH</literal></title>

<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

    <para>
<command>FETCH</command> ottiene la riga successiva dal cursore
in un obiettivo, che potrebbe eserre una variabile riga, una variabile record, 
o un elenco separato da virgole di variabili semplici, esattamente come 
<command>SELECT INTO</command>. Se non c'è una riga seguente, l'obiettivo è
impostato a NULL. Come con <command>SELECT
INTO</command>, la variabile speciale <literal>FOUND</literal> può 
essere controllato per vedere se una riga è stata ottenuta o no.
    </para>

    <para>
La clausola <replaceable>direction</replaceable> può essere una qualsiasi delle varianti
permesse nel comando SQL <xref linkend="sql-fetch"/>
ad eccezione di quelle che possono ottenere 
più di una riga; vale a dire, può essere
<literal>NEXT</literal>,
<literal>PRIOR</literal>,
<literal>FIRST</literal>,
<literal>LAST</literal>,
<literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
<literal>RELATIVE</literal> <replaceable>count</replaceable>,
<literal>FORWARD</literal>, o
<literal>BACKWARD</literal>.
Omettere <replaceable>direction</replaceable> è lo stesso di 
specificare <literal>NEXT</literal>.
Valori di <replaceable>direction</replaceable> che richiedono il movimento
a ritroso probabilmente falliranno a meno che il cursore non fosse stato dichiarato o 
aperto con l'opzione <literal>SCROLL</literal>.
    </para>

    <para>
<replaceable>cursor</replaceable> deve essere il nome di una variabile <type>refcursor</type>
che si riferisce a un portale cursore aperto.
    </para>

    <para>
Esempi:
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>MOVE</literal></title>

<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

    <para>
<command>MOVE</command> riposiziona un cursore senza ottenere nessun dato.
<command>MOVE</command> funziona esattamente come il comando 
<command>FETCH</command>, ad eccezione che riposiziona solamente il cursore
e non restituisce la riga su cui si è mosso. Come con <command>SELECT
INTO</command>, la variabile speciale <literal>FOUND</literal> può
essere controllata per vedere se c'era una riga successiva su cui muoversi.
    </para>

    <para>
La clausola <replaceable>direction</replaceable> può essere qualsiasi delle varianti 
permesse nel comando SQL <xref linkend="sql-fetch"/>,
vale a dire
<literal>NEXT</literal>,
<literal>PRIOR</literal>,
<literal>FIRST</literal>,
<literal>LAST</literal>,
<literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
<literal>RELATIVE</literal> <replaceable>count</replaceable>,
<literal>ALL</literal>,
<literal>FORWARD</literal> <optional> <replaceable>count</replaceable> | <literal>ALL</literal> </optional>, o
<literal>BACKWARD</literal> <optional> <replaceable>count</replaceable> | <literal>ALL</literal> </optional>.
Omettere <replaceable>direction</replaceable> è lo stesso di specificare 
<literal>NEXT</literal>.
I valori di <replaceable>direction</replaceable> che richiedono il movimento all'indietro
probabilmente falliranno a meno che il cursorre non fosse stato dichiarato o aperto 
con l'opzione <literal>SCROLL</literal>.
    </para>

    <para>
Esempi:
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

       <para>
Quando un cursore è posizionato sulla riga di una tabella, quella riga può essere aggiornata
o cancellata usando il cursore per identificarla. Ci sono restrizioni
su cosa possa essere e la query del cursore (in particolare ,
no raggruppamenti) ed è meglio usare <literal>FOR UPDATE</literal> nel cursore.
Per maggiori informazioni si veda la pagina di riferimento
<xref linkend="sql-declare"/>.
       </para>

       <para>
Un esempio:
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>CLOSE</literal></title>

<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

       <para>
<command>CLOSE</command> chiude il portale sottostante un cursore aperto.
Questo può essere usato per rilasciare risorse prima della fine della transazione, 
o per liberare la variabile cursore per essere aperta di nuovo.
       </para>

       <para>
Un esempio:
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title>Cursori di ritorno</title>

       <para>
Le funzioni <application>PL/pgSQL</application> possono restituire cursori al chiamante.
Questo è utile per restituire molteplici righe o colonne, 
specialmente con insiemi di risultati molto grandi. Per fare ciò, la funzione
apre il cursore e restituisce il nome del cursore al chiamante (o semplicemente 
apre il cursore usando un nome di portale specificato da, o saputo in altro modo, 
al chiamante). Il chiamante può quindi recuperare righe dal cursore. Il cursore 
può essere chiuso dal chimante, o sarà chiuso automaticamente
quando la transazione si chiude.
       </para>

       <para>
Il nome del portale usato per un cursore può essere specificato dal programmatore
o generato automaticamente. Per specificare il nome di un portale, 
assegnare sempliciemente una stringa alla variabile <type>refcursor</type> prima 
si aprirla. Il valore della stringa della variabile <type>refcursor</type>
sarà usato da <command>OPEN</command> come nome del portale sottostante.
Comunque, se la variabile <type>refcursor</type> è null,
<command>OPEN</command> genera automaticamente un nome che non va in conflitto 
con nessun altro portale esistente, e lo assegna alla variabile 
<type>refcursor</type>.
       </para>

       <note>
        <para>
Una variabile cursore legata è inizializzata al valore della stringa
rappresentante il suo nome, così che il nome del portale è lo stesso del
nome della variabile cursore, a meno che il programmatore lo sovrascriva 
con un'assegnazione prima di aprire il cursore. Ma una variabile cursore non legata
è inizialmente null, così riceverà un nome unico generato automaticamente, 
a meno che sovrascritto.
        </para>
       </note>

       <para>
L'esempio seguente mostra un modo in cui il nome di un cursore possa essere fornito
dal chiamante:

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEgin
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEgin;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

       <para>
L'esempio seguente usa la generazione automatica del nome:

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEgin
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- need to be in a transaction to use cursors.
BEgin;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>

       <para>
L'esempio seguente mostra un modo di restituire molteplici cursori 
da una singola funzione:

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEgin
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- deve essere in una transazione per usare i cursori.
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
    <title>Looping Through a Cursor's Result</title>

    <para>
C'è una variante dell'istruzione <command>FOR</command> che permette
di iterare attraverso le righe ritornate da un cursore. La sintassi è:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <replaceable>argument_values</replaceable> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

La variabile cursore deve essere stata legata a qualche query quando è stata
dichiarata, e <emphasis>non può</emphasis> essere già aperta. L'istruzione
<command>FOR</command> apre automaticamente il cursore, e chiude di nuovo il cursore 
quando il ciclo termina. Un elenco dei valori degli argomenti effettivi 
deve apparire se e solo se il cursore fu dichiarato per prendere argomenti.
Questi valori saranno sostituiti nella query, esattamente nello stesso modo 
che durante una <command>OPEN</command>.
La variabile <replaceable>recordvar</replaceable> viene definita automaticamente
del tipo <type>record</type> ed esiste solo all'interno del ciclo (qualsiasi 
definizione esistente del nome della variabile viene ignorata all'interno del ciclo).
Ogni riga restituita dal cursore è successivamente assegnata a questa variabile record
e viene eseguito il corpo del ciclo.
    </para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
   <title>Errori e messaggi</title>

   <indexterm>
    <primary>RAISE</primary>
   </indexterm>

   <indexterm>
    <primary>riportare errori</primary>
    <secondary>in PL/PgSQL</secondary>
   </indexterm>

   <para>
Usare l'istruzione <command>RAISE</command> per riportare messaggi e 
sollevare errori.

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

L'opzione <replaceable class="parameter">level</replaceable> specifica
la gravità dell'errore. I livelli permessi sono <literal>DEBUG</literal>, 
<literal>LOG</literal>, <literal>INFO</literal>,
<literal>NOTICE</literal>, <literal>WARNING</literal>,
e <literal>EXCEPTION</literal>, con <literal>EXCEPTION</literal>
che è il predefinito.
<literal>EXCEPTION</literal> solleva un errore (che normalmente annulla la transazione
corrente); gli altri livelli generano solamente messaggi di diversi 
livelli di priorità.
Il fatto che i messaggi di una particolare priorità siano riportati al client, 
scritti sul log del server, o entrambi è controllato dalle variabili 
di configurazione 
<xref linkend="guc-log-min-messages"/> e
<xref linkend="guc-client-min-messages"/>. 
Si veda <xref linkend="runtime-config"/> per maggiori informazioni.
   </para>

   <para>
Dopo <replaceable class="parameter">level</replaceable>, se presente, 
è possibile scrivere  <replaceable class="parameter">format</replaceable>
(che deve essere una semplice stringa letterale,  non un'espressione). La stringa 
format specifica il testo del messaggio si errore da segnalare.
La stringa format può essere seguita 
da espressioni argomento opzionali da inserire nel messaggio.
All'interno della stringa format, <literal>%</literal> viene sostituita 
dalla rappresentazione in stringa del valore opzionale seguente. Scrivere
<literal>%%</literal> per emettere un <literal>%</literal> letterale.
   </para>

   <para>
In questo esempio, il valore di <literal>v_job_id</literal> sostituirà il 
<literal>%</literal> nella stringa:
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>

   <para>
È possibile allegare informazioni aggiuntive al resoconto dell'errore scriverndo
<literal>USING</literal> seguito da elementi <replaceable
class="parameter">option</replaceable> = <replaceable
class="parameter">expression</replaceable>.  
Le parole chiave 
<replaceable class="parameter">option</replaceable> permesse sono 
<literal>MESSAGE</literal>, <literal>DETAIL</literal>, <literal>HINT</literal>, e
<literal>ERRCODE</literal>, mentre ogni <replaceable
class="parameter">expression</replaceable> 
può essere qualsiasi espressione stringa.
<literal>MESSAGE</literal> imposta il testo del masseggio di errore (questa opzione
non può essere usata nella forma di <command>RAISE</command> che include una stringa format
prima di <literal>USING</literal>).
<literal>DETAIL</literal> fornisce un messaggio del dettaglio dell'errore, mentre
<literal>HINT</literal> fornisce un messaggio di suggerimento.
<literal>ERRCODE</literal> specifica il codice dell'errore da riportare (SQLSTATE),
o dal nome della condizione come mostrato in <xref linkend="errcodes-appendix"/>,
o direttamente come codice SQL di cinque caratteri.
   </para>

   <para>
Questo esempio annullerà la transazione con il dato messaggio di errore
e suggerimento:
<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user id';
</programlisting>
   </para>

   <para>
Questi due esempi mostrano modi equivalenti di impostare il SQLSTATE:
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

   <para>
C'è una secondo tipo di sintassi per <command>RAISE</command> in cui l'argomento principale
è il nome della condizione o SQLSTATE da riportare, per esempio:
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
In questa sintassi, <literal>USING</literal> può essere usato per indicare un messaggio d'errore, 
un dettaglio o un 
suggerimento personalizzato. Un altro modo di fare l'esempio precedente
è
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>

   <para>
Un'ulteriore variante è di scrivere <literal>RAISE USING</literal> o <literal>RAISE
<replaceable class="parameter">level</replaceable> USING</literal> e mettere
tutto il resto nell'elenco <literal>USING</literal>.
   </para>

   <para>
L'ultima variante di <command>RAISE</command> non ha parametri del tutto.
Quasta forma può essere usata solo all'interno della clausola <literal>EXCEPTION</literal>
di un blocco <literal>BEGIN</literal>;
esso causa che l'errore correntemente gestito sia lanciato di nuovo.
   </para>

   <note>
    <para>
Prima di <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> senza
parametri era interpretato come lanciare di nuovo l'errore dal blocco contenente
il gestore di eccezioni attivo. Così una clausola <literal>EXCEPTION</literal>
annidata all'interno di quel gestore potrebbe non catturarla, anche se
il <command>RAISE</command> era all'interno del blocco della clausa  <literal>EXCEPTION</literal>
annidata. Questo fu considerato anche essere sorprendentemente incompatibile con  
PL/SQL di Oracle.
    </para>
   </note>

   <para>
Se non è specificato nessun nome di condizione nè SQLSTATE in un comando  
<command>RAISE EXCEPTION</command>, come predefinito si usa 
<literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>). Se nessun messaggio di testo
viene specificato, il comportamento predefinito è di usare il nome della condizione o
SQLSTATE come messaggio di testo.
   </para>

   <note>
    <para>
Quando si specifica un codice di errore con un SQLSTATE, non si è limitati
a codici di errore predefiniti, ma si può selezionare qualsiasi
codice di errore che consiste di cinque cifre e/o lettere ASCII maiuscole, 
diverse da <literal>00000</literal>.  Si raccomanda di 
evitare di lanciare codici di errore che finiscano con tre zeri, dato che questi sono 
codici di categorie e possono essere intercettati solo intercettando l'intera
categoria.
    </para>
   </note>

 </sect1>

 <sect1 id="plpgsql-trigger">
  <title>Procedure Trigger</title>

  <indexterm zone="plpgsql-trigger">
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
  </indexterm>

  <para>
<application>PL/pgSQL</application> può essere usato per definire procedure 
trigger. Una procedura trigger viene creata con il comando 
<command>CREATE FUNCTION</command>, dichiarandola come  una funzione senza
argomenti e <type>trigger</type> come tipo di ritorno. Notare che   
la funzione deve essere dichiarata senza argomenti anche se si aspetta 
di ricevere argomenti specificati in <command>CREATE TRIGGER</command> -
gli argomenti del trigger sono passati via <varname>TG_ARGV</varname>, come descritto
sotto.
  </para>

  <para>
Quando una funzione <application>PL/pgSQL</application> è chiamata come trigger,
diverse variabili speciali sono create automaticamente nel blocco 
superiore. Esse sono:

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
Tipo di dato <type>RECORD</type>; variabile che tiene la nuova riga
del database per operazioni <command>INSERT</command>/<command>UPDATE</command> in 
trigger a livello di riga. Questa variabile è <symbol>NULL</symbol> in trigger a livello 
di istruzione e per operazioni <command>DELETE</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
Tipo di dato <type>RECORD</type>; variabile che tiene la vecchia riga del database
per operazioni <command>UPDATE</command>/<command>DELETE</command> in trigger a livello di 
riga. Questa variabile è <symbol>NULL</symbol> in trigger a livello di istruzione
e per operazioni <command>INSERT</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; variabile che contiene il nome del trigger attualmente attivato.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of either
Tipo di dato <type>text</type>; una stringa <literal>BEFORE</literal> o <literal>AFTER</literal>
a seconda della definizione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
Tipo di dato <type>text</type>; una stringa
<literal>ROW</literal> o <literal>STATEMENT</literal>
a seconda della definizione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of
Tipo di dato <type>text</type>; una stringa
<literal>INSERT</literal>, <literal>UPDATE</literal>,
<literal>DELETE</literal>, o <literal>TRUNCATE</literal>
che dice per quale operazione è stato attivato il trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
Tipo di dato  <type>oid</type>; l'ID dell'oggetto della tabella che ha causato 
l'invocazione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; il nome della tabella che ha causato l'invocazione del 
trigger. Questo ora è deprecato, e può sparire in una versione futura.
Usare invece <literal>TG_TABLE_NAME</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; il nome della tabella che ha causato 
l'invocazione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; il nome dello schema della tabella che 
ha causato l'invocazione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
Tipo di dato <type>integer</type>; il numero di argomenti forniti alla procedura trigger 
nell'istruzione <command>CREATE TRIGGER</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
Tipo di dato <type>text</type>; gli argomenti 
dell'istruzione <command>CREATE TRIGGER</command>.
L'indice conta da 0. Gli indici invalidi 
(minori di 0 o maggiori di, o uguali, a <varname>tg_nargs</varname>)
risultano in un valore null.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
Una funzione trigger deve restituire o <symbol>NULL</symbol> o un valore record/riga
avente esattamente la struttura della tabelle per cui è stato attivato il trigger.
   </para>

   <para>
Trigger a livello di riga attivati prima (<literal>BEFORE</literal>) possono restituire null
per segnalare al gestore dei trigger di saltare il resto dell'operazione per questa riga.
(per es., i trigger successivi non vengono attivati, e 
le <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> non accadono
per questa riga). Se viene restituito un valore nonnull
allora l'operazione procede con quel valore della riga.
Restituire un valore rida diverso dal valore originale di
<varname>NEW</varname> altera la riga che sarà inserita o aggiornata.
Così, se la funzione trigger vuole che l'azione di trigger
riesca normalmente senza alterare il valore della riga, 
deve essere restituito <varname>NEW</varname> (o un valore ad esso equivalente).
Per modificare la riga da salvare, è possibile 
sostituire singoli valori direttamente in  <varname>NEW</varname> e restituire 
la <varname>NEW</varname> modificata, o costruire un record/riga completamente nuovo
da restituire. Nel caso di un trigger before 
su <command>DELETE</command>, il valore restituito non ha un effetto diretto,
ma deve essere non null per permettere all'azione trigger di
procedere. Notare che <varname>NEW</varname> è null nei trigger
<command>DELETE</command>, quindi restituirlo di solito non è sensato. 
Un'espressione utile nei trigger <command>DELETE</command>
potrebbe restituire <varname>OLD</varname>.
   </para>

   <para>
Il valore di ritorno di un trigger a livello di riga
attivato <literal>AFTER</literal> o un trigger a livello di instruzione
attivato <literal>BEFORE</literal> o <literal>AFTER</literal> è
sempre ignorato; potrebbe anch'esso essere null. Comunque, uno qualsiasi di questi tipi di 
trigger potrebbe ancora annullare l'intera operazione sollevando un errore.
   </para>

   <para>
<xref linkend="plpgsql-trigger-example"/> mostra un esempio di una procedura trigger
in <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-trigger-example">
    <title>Una procedura trigger <application>PL/pgSQL</application></title>

    <para>
Questo trigger di esempio assicura che ogni volta una riga venga inserita o aggiornata
nella tabella, il nome utente corrente e l'orario siano salvati nella riga.
E controlla che oil nome di un impiegato sua fornito e che il salario
sia un valore positivo.
    </para>

<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEgin
        -- Check that empname and salary are given
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- Who works for us when she must pay for it?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- Remember who changed the payroll when
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();
</programlisting>
   </example>

   <para>
Un altro modo di annotare i cambiamenti a una tabella implica la creazione di una nuova tabella
che salva una riga per ogni insert, update, o delete che accade. Questo approccio
può essere pensato come una revisione dei cambiamenti a una tabella.
<xref linkend="plpgsql-trigger-audit-example"/> mostra un esempio di una procedura trigger
di revisione in <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-trigger-audit-example">
    <title>Una procedura trigger <application>PL/pgSQL</application> per la revisione</title>

    <para>
Questo trigger di  esempio assicura che qualsiasi inserimento, aggiornamento o cancellazione di una riga
nella tabella <literal>emp</literal> sia registrata nella tabella <literal>emp_audit</literal>.
L'orario e il nome utente corrente sono salvati nella riga, insieme al 
tipo di operazione svolta.
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- Crea una riga un emp_audit per riflettere l'operazione eseguita su emp, 
        -- usa la variabile speciale TG_OP per portare a termine l'operazione.
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- il risultato viene ignorato dato che questo è un trigger AFTER
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();
</programlisting>
   </example>

   <para>
Un uso dei trigger è di mantenere una tabella di sommario
di un'altra tabella. Il sommario risultante può essere usato al posto della
tabella originale per certe query - spesso con tempi di esecuzione enormemente 
ridotti.
Questa tecnica è usata comunemente nel Data Warehousing, dove le tabelle
dei dati misurati o osservati (chiamate tabelle dei fatti) potrebbero essere estremamente grandi.
<xref linkend="plpgsql-trigger-summary-example"/> mostra un esempio di una 
procedura trigger in <application>PL/pgSQL</application> che mantiene
una tabella di sommario per una tabella di fatti in un data warehouse.
   </para>


   <example id="plpgsql-trigger-summary-example">
    <title>Una procedura trigger <application>PL/pgSQL</application> per mantenere una tabella di sommario</title>

    <para>
Lo schema presentato in dettaglio qui è basato parzialmente sull'esempio <emphasis>Grocery Store
</emphasis> preso da <emphasis>The Data Warehouse Toolkit</emphasis>
di Ralph Kimball.
    </para>

<programlisting>
--
-- Main tables - time dimension and sales fact.
-- Tabelle principali - time dimension e sales fact.
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- Tabella di sommario - sales by time.
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- Funzioni e trigger per rettificare le colonne sommarizate sulle UPDATE, INSERT, DELETE.
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEgin

        -- Mette a posto l'ammontare degli incrementi/decrementi.
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- forbid updates that change the time_key -
            -- (probably not too onerous, as DELETE + INSERT is how most
            -- changes will be made).
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- Inserisce o aggiorna la riga di sommario con i nuovi valori.
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- non fare niente
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>

  </sect1>

  <sect1 id="plpgsql-implementation">
   <title><application>PL/pgSQL</application> Under the Hood</title>

   <para>
Questa sezione discute alcuni dettagli dell'implementazione che frequentemente
sono importanti da sapere per gli utenti  <application>PL/pgSQL</application>.
   </para>

  <sect2 id="plpgsql-var-subst">
   <title>Sostituzione di variabili</title>

   <para>
Le funzioni SQL e le espressioni all'interno di funzioni <application>PL/pgSQL</application>
possono fare riferimento a variabili e parametri della funzione. Dietro le quinte,
<application>PL/pgSQL</application> sostituisce i parametri della query per tali riferimenti.
I parametri saranno sostituiti solo in posti dove un riferimento a un parametro o 
colonna è permesso sintatticamente. Come caso estremo, considerare 
questo esempio di scarso stile di programmazione:
<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
La prima occorenza di <literal>foo</literal> dev'essere sintatticamente il nome di una tabella, 
quindi non sarà sostituito, anche se la funzione ha una variabile 
chiamata <literal>foo</literal>.  La seconda occorrenza deve essere il nome di una
colonna della tabella, quindi non sarà sostituita. Solo la terza occorrenza  
è un candidato per essere un riferimento alla variabile della funzione.
   </para>

   <note>
    <para>
Le versioni di <productname>PostgreSQL</productname> precedenti la 9.0 avrebbero provato
a sostituire la variabile in tutti e tre i casi, generando errori di sintassi.
    </para>
   </note>

   <para>
Dato che i nomi delle variabili non sono sintatticamente diversi dai nomi 
delle colonne della tabella, ci può essere ambiguità in istruzioni che si riferiscono anche
alle tabelle: un fato nome è inteso riferirsi a una colonna di tabella, o a una variabile?
Si cambi l'esempio precedente in
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
Qui, <literal>dest</literal> e <literal>src</literal> devono essere nomi di tabella, e 
<literal>col</literal> deve essere una colonna di <literal>dest</literal>, ma <literal>foo</literal>
e <literal>bar</literal> potrebbero ragionevolmente essere variabili della funzione
o colonne di <literal>src</literal>.
   </para>

   <para>
Come predefinito, <application>PL/pgSQL</application> riporterà un errore se un nome
in un'istruzione SQL potrebbe riferirsi sia a una variabile che alla colonna di una tabella.
Si può risolvere tale problema rinominando la variabile o la colonna,
o qualificando il riferimento ambiguo, o dicendo a
<application>PL/pgSQL</application> quale interpretazione preferire.
   </para>

   <para>
La soluzione più semplice è di rinominare la variabile o la colonna.
Una regola comune di programmazione è  di usare una
convenzione di nomenclatura diversa per le variabili <application>PL/pgSQL</application> 
rispetto a quella usata per i nomi delle colonne. Per esempio,
se coerentemente le variabili delle funzioni si chiamano 
<literal>v_<replaceable>something</replaceable></literal>
mentre nessuno dei nomi delle colonne comincia con <literal>v_</literal>,
non si verificheranno conflitti.
   </para>

   <para>
Alternativamente si possono qualificare riferimenti ambigui per renderli chiari.
Nell'esempio sopra, <literal>src.foo</literal> sarebbe un riferimento non ambiguo
alla colonna della tabella. Per creare un riferimento non ambiguo a una variabile,
dichiararla in un blocco con etichetta ed usare l'etichetta del blocco 
(si veda <xref linkend="plpgsql-structure"/>).  Per esempio,
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEgin
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
Qui <literal>block.foo</literal> infica la variabile anche se c'è una colonna 
<literal>foo</literal> in <literal>src</literal>.  
I parametri di funzione, così come
variabili speciali tipo <literal>FOUND</literal>, possono essere qualificate 
dal nome della funzione, dato che sono dichiarati implicitamente in un blocco esterno 
etichettato con il nome della funzione.
   </para>

   <para>
A volte è impraticabile risolvere tutti i riferimenti ambigui in un sostanzioso
pezzo di codice <application>PL/pgSQL</application>. In tali casi è possibile specificare 
che <application>PL/pgSQL</application> dovrebbe risolvere riferimenti ambigui
come riferimenti a  variabile (che è compatibile con il comportamento di <application>PL/pgSQL</application>
prima di <productname>PostgreSQL</productname> 9.0), o come riferimento alla colonna della tabella  
(che è compatibile con alcuni altri sistemi come
<productname>Oracle</productname>).
   </para>

   <indexterm>
     <primary>parametro di configurazione <varname>plpgsql.variable_conflict</varname></primary>
   </indexterm>

   <para>
Per cambiare questo comportamento a livello di sistema, impostare il parametro di configurazione
<literal>plpgsql.variable_conflict</literal> ad un valora tra
<literal>error</literal>, <literal>use_variable</literal>, o
<literal>use_column</literal> 
(dove <literal>error</literal> è il predefinito).
Questo parametro influisce successive compilazioni 
o istruzioni in funzioni <application>PL/pgSQL</application>, ma non istruzioni 
già compilate nella sessione corrente. Per impostare il parametro prima 
che <application>PL/pgSQL</application> sia stato caricato, è necessario aver aggiunto
<quote><literal>plpgsql</literal></quote> all'elenco <xref
linkend="guc-custom-variable-classes"/> in
<filename>postgresql.conf</filename>. Dato che cambiare quest'impostazione
può causare cambiamenti inaspettati nel comportamento di funzioni <application>PL/pgSQL</application>,
può essere cambiato solo da un superutente.
   </para>

   <para>
È anche possibile impostare il comportamento funzione per funzione, inserendo 
uno di questi comandi speciali all'inizio del testo della funzione:
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
Questi comandi hanno consegnuenze solo sulla funzione in cui sono scritti, e sovrascrivono
l'impostazione di <literal>plpgsql.variable_conflict</literal>. Un esempio è
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
Nel comando <literal>UPDATE</literal>, <literal>curtime</literal>, <literal>comment</literal>
e <literal>id</literal> faranno riferimento alle variabili e parametri della funzione
sia che <literal>users</literal> abbia o no colonne chiamate in quel modo. Notare 
che si è dovuto qualificare il riferimento a <literal>users.id</literal> nella 
clausola <literal>WHERE</literal> per renderlo un riferimento alla colonna della tabella.
Ma non si è dovuto qualificare il riferimento a <literal>comment</literal>
come obiettivo dell'elenco <literal>UPDATE</literal>, dato che sintatticamente
quella deve essere una colonna di <literal>users</literal>. Si poteva scrivere la stessa
funzione senza dipendere dall'impostazione di <literal>variable_conflict</literal>
in questo modo:
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEgin
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
La sostituzione di variabili non avviene nella stringa del comando fornito a 
<command>EXECUTE</command> o una delle sue varianti. Se si ha bisogno di 
inserire un valore variabile in tale comando, farlo come parte della
costruzione del valore stringa, o usare  <literal>USING</literal>, come illustrato in
<xref linkend="plpgsql-statements-executing-dyn"/>.
   </para>

   <para>
La sostituzione di variabile correntemente funziona solo in comandi
<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command>,
dato che il motore SQL principale permette parametri per query solo in questi
comandi. Per usare un nome o un valore non costante in altri tipi di istruzione
(chiamate genericamente instruzioni di utilità), si deve costruire 
l'istruzione di utilità come una stringa ed eseguirla con  <command>EXECUTE</command>.
   </para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
   <title>Cache del piano</title>

   <para>
L'interprete <application>PL/pgSQL</application> fa il parsing del sorgente della funzione 
e produce un albero di istruzioni binarie interne la prima volta che la funzione 
viene chiamata (all'interno di ogni sessione). L'albero di istruzioni
traduce completamente la struttura delle istruzioni
<application>PL/pgSQL</application>, ma espressioni e comandi <acronym>SQL</acronym> 
individuali usate nella funzione non sono tradotte immediatamente.
   </para>

   <para>
Ogni volta che un espressione e comando <acronym>SQL</acronym> viene eseguita,
l'interprete  <application>PL/pgSQL</application> crea
un piano di esecuzione (usando le funzioni del gestore 
<acronym>SPI</acronym> <function>SPI_prepare</function>
e <function>SPI_saveplan</function>).
<indexterm><primary>preparare una query</primary><secondary>in
PL/pgSQL</secondary></indexterm> 
Visite successive a questa espressione o comando 
riusano il piano preparato. Perciò, una funzione con codice condizionale 
che contiene istruzioni per la cui esecuzione potrebbero essere necessari
piani preparerà e salvera solo quei piani che sono realmente usati durante 
il ciclo di vita della connessione al database.
Questo può
ridurre sostanzialmente l'ammontare totale del tempo richiesto per fare il parsing
e generare i piani di esecuzione per le istruzioni in una funzione
<application>PL/pgSQL</application>. Uno svantaggio è che errori 
in una specifica espressione o comando non possono essere individuati finchè quella
parte della funzione viene raggiunta durante l'esecuzione. (Errori di sintassi trascurabili
saranno individuati durante il passo iniziale di parsing, ma qualsiasi cosa più
approfondita non sarà individuata fino all'esecuzione).
   </para>

   <para>
Un piano salvato sarà ripianificato automaticamente se c'è qualsiasi cambiamento allo schema
in qualsiasi tabella usata nella query, o se una qualsiasi  funzione definita dall'utente
usata nella query viene ridefinita. Questo rende il riuso di piano preparati
trasparente nella maggior parte dei casi, ma ci sono casi limite dove un vecchio piano 
potrebbe essere riusato. Un esempio è che eliminare e ricreare un operatore definito dall'utente
non influenzerà piani già sottoposti a cache; loro continueranno a 
chiamare la funzione originale sottostante dell'operatore, se non è stato cambiato.
Quando necessario, la cache può essere svuotata cominciando una nuova sessione di database.
   </para>

   <para>
Dato che <application>PL/pgSQL</application> salva i piani di esecuzione 
in questo modo, i comando SQL che appaiono direttamente in una
funzione <application>PL/pgSQL</application> devono fare riferimento alle
stesse tabelle e colonne ad ogni esecuzione; cioè, non è possbile usare 
un parametro come nome di una tabella o colonna in un comando SQL. Per superare 
questa restrizione, è possibile costruire comandi dinamici usando 
l'istruzione <application>PL/pgSQL</application> <command>EXECUTE</command> -
al prezzo di costruire un nuovo piano di esecuzione ad ogni esecuzione.
   </para>

   <para>
Un altro punto importante è che i piani preparati vengono parametrizzati
per permettere ai valori delle variabili <application>PL/pgSQL</application> 
di cambiare da un uso al prossimo, come discusso in dettaglio sopra.
A volte questo significa che un piano è meno efficiente rispetto a quello che sarebbe stato
se generato per un valore della variabile specifico. Come esempio, considerare
<programlisting>
SELECT * INTO myrec FROM dictionary WHERE word LIKE search_term;
</programlisting>
dove <literal>search_term</literal> è una variabile <application>PL/pgSQL</application>.
Il piano sottoposto a cache per questa query non userà mai un indice su 
<structfield>word</structfield>, dato che il pianificatore non può assumere che 
il modello <literal>LIKE</literal> sia fissato a sinistra durante l'esecuzione. Per usare 
un indice la query deve essere pianificata fornendo con uno specifico modello 
<literal>LIKE</literal>. Questa è un'altra situazione dove 
<command>EXECUTE</command> può essere usato per forzare la generazione di un nuovo piano per 
ogni esecuzione.
   </para>

    <para>
La natura mutabile delle variabili record presenta un altro problema in questa 
connessione. Quando i campi di una variabile  record sono usati in espressioni 
o istruzioni, i tipi di dato del campo non devono cambiare
da una chiamata della funzione alla successiva, dato che ogni 
espressione sarà pianificata usando il tipo di dato che è presente 
quando l'espressione viene raggiunta per la prima volta. <command>EXECUTE</command> può essere
usata per scavalcare questo problema quando necessario.
    </para>

    <para>
Se la stessa funzione viene usata come trigger  per più di una tabella, 
<application>PL/pgSQL</application> prepara e sottopone a cache i piani 
indipendentemente per ogni tabella - cioè, c'è una cache
per ogni funzione  trigger e combinazione di tabella, non solo per ogni
funzione. Questo allieva alcuni dei problemi con tipi di dato variabili;
per esempio, una funzione trigger sarà capace di funzionare 
con successo con una colonna chiamata  <literal>key</literal> anche se ha 
tipi diversi in tabelle diverse.
    </para>

    <para>
Ugualmente, funzioni aventi tipi di argomento polimorfici hanno una cache di piano   
separata per ogni combinazione dei tipi effettivi degli argomenti per i quali 
sono invocate, così quelle differenze tra tipi di dato non causano fallimenti 
inaspettati.
    </para>

   <para>
La cache del piano può a volte avere effetti sull'interpretazione
di valori sensibili al tempo. Per esempio c'è una differenza 
tra quello che queste due funzioni fanno: 

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

e:

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <para>
Nel caso di <function>logfunc1</function>, il parser principale
di <productname>PostgreSQL</productname> sa quando 
preparare il piano per la <command>INSERT</command> che la 
stringa <literal>'now'</literal> dovrebbe essere interpretrata come
<type>timestamp</type>, dato che la colonna obiettivo di 
<classname>logtable</classname> è di quel tipo. Perciò,
<literal>'now'</literal> sarà convertito a una costante quando la 
<command>INSERT</command> è pianificata, e quindi usata in tutte le invocazioni
di <function>logfunc1</function> durante il ciclo di vita della
sessione. Inutile dire che questo non è quello che voleva il programmatore.
    </para>

    <para>
Nel caso di <function>logfunc2</function>, il parser principale di 
<productname>PostgreSQL</productname> non sa quale tipo dovrebbe
diventare <literal>'now'</literal> e quindi restituisce 
un valore di tipo <type>text</type> contenente la stringa 
<literal>now</literal>. Durante l'assegnamento conseguente 
alla variabile locale <varname>curtime</varname>, l'interprete
<application>PL/pgSQL</application> converte questa stringa 
al tipo <type>timestamp</type> chiamando le funzioni per la conversione <function>text_out</function>
e <function>timestamp_in</function>. 
Così, il timestap calcolato viene aggiornato ad ogni esecuzione 
come si aspetta il programmatore.
    </para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
  <title>Consigli per lo sviluppo in <application>PL/pgSQL</application></title>

   <para>
Un buon modo di sviluppare in
<application>PL/pgSQL</application> è di usare l'editor di testo di propria scelta
per creare le funzioni, e in un'altra finestra, usare
<application>psql</application> per caricare e testare quelle funzioni.
Se si fa in questa maniera, è una 
buona idea scrivere la funzione usando <command>CREATE OR
REPLACE FUNCTION</command>.  In questo modo è possibile ricaricare il file per aggiornare
la definizione della funzione. Per esempio: 
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
Mentre <application>psql</application> è in esecuzione, si può caricare o ricaricare
tale definizione di funzione con:
<programlisting>
\i filename.sql
</programlisting>
e quindi fornire immediatamente comandi SQL per testare la funzione.
   </para>

   <para>
Un altro ottimo modo di sviluppare in <application>PL/pgSQL</application> è con uno strumento 
GUI di accesso al database che facilita lo sviluppo in un linguaggio 
procedurale. Un esempio di tale strumento è 
<application>pgAdmin</application>, anche se ne esistono altri. Questi strumenti spesso
forniscono caratteristiche utili come l'escape di apici singoli e
rendono più facile ricreare e fare il debug delle funzioni.
   </para>

  <sect2 id="plpgsql-quote-tips">
   <title>Handling of Quotation Marks</title>

   <para>
Il codice di una funzione <application>PL/pgSQL</application> è specificato 
in <command>CREATE FUNCTION</command> come una stringa. Se si scrive 
la stringa nel modo ordinario circondato da apici singoli, 
quindi qualsiasi apice singola dentro il corpo della funzione 
deve essere raddoppiato; allo stesso modo le barre inverse devono essere raddoppiate (assumendo
che sia usata la sintassi escape stringa).
Raddoppiare gli apici è tedioso, e nei casi più complicati  
il codice può diventare assolutamente incomprensibile, perchè è facile
che si necessiti di mezza dozzina o più apici adiacenti.
Si raccomanda di scrivere il corpo della funzione come una stringa
<quote>quotata con dollari</quote> (si veda <xref
linkend="sql-syntax-dollar-quoting"/>). Nell'approccio 'dollar-quoting', 
non si raddoppia mai nessun apice, fare attenzione a scegliere 
un delimitatore di quotazione con dollari diverso per ogni livello di 
annidemento che si necessita. Per esempio, si potrebbe scrivere il comando
<command>CREATE FUNCTION</command> come:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
All'interno di questo, si potrebbero usare le virgolette per semplici stringhe letterali 
in comandi SQL e <literal>$$</literal> per delimitare frammenti di comandi SQL
che si assemblano come stringhe. Se si necessita quotare testo che 
include <literal>$$</literal>, si può usare <literal>$Q$</literal>, e così via.
   </para>

   <para>
Il seguente grafico mosta cosa si deve fare quando si scrivono virgolette 
senza la quotazione con dollari. Potrebbe essere utile quando si traduce 
codice pre-quotazione con dollari in qualcosa di più comprensibile.
  </para>

  <variablelist>
   <varlistentry>
    <term>1 virgoletta</term>
    <listitem>
     <para>
      To begin and end the function body, for example:
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
Ovunque all'interno del corpo di una funzione tra singoli apici, le virgolette 
<emphasis>devono</emphasis> apparire in coppia.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>2 virgolette</term>
    <listitem>
     <para>
Per letterali stringa all'interno del corspo della funzione, per esempio:
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      In the dollar-quoting approach, you'd just write:
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
che è esattamente quello che vedrebbe il parser <application>PL/pgSQL</application> 
in ogni caso.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>4 virgolette</term>
    <listitem>
     <para>
Quando si necessita di una virgoletta singola in una costante stringa all'interno del
corpo della funzione, per esempio:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
Il valore effettivamente aggiunto a <literal>a_output</literal> sarebbe:
<literal> AND name LIKE 'foobar' AND xyz</literal>.
     </para>
     <para>
Nell'approccio di quotazione con dollari, si scriverebbe:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
facendo attenzione che ogni delimitatore di quotazione con dollari intorno a questo non sia 
solo <literal>$$</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>6 virgolette</term>
    <listitem>
     <para>
Quando una virgoletta singola in una stringa all'interno del corpo della funzione è
adiacente alla fine di quella costante stringa, per esempio:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
Il valore aggiunto a <literal>a_output</literal> quindi sarebbe:
      <literal> AND name LIKE 'foobar'</literal>.
     </para>
     <para>
Nell'approccio di quotazione con dollari, questo diventa:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>10 virgolette</term>
    <listitem>
     <para>
      When you want two single quotation marks in a string constant (which
      accounts for 8 quotation marks) and this is adjacent to the end of that
      string constant (2 more).  You will probably only need that if
      you are writing a function that generates other functions, as in
      <xref linkend="plpgsql-porting-ex2"/>.
Per esempio:
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
Il valore di <literal>a_output</literal> quindi sarebbe:
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
     <para>
Nell'approccio di quotazione con dollari, questo diventa:
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
dove si assume che si abbia bisogno solo di mettere virgolette singole in 
<literal>a_output</literal>, dato che sarà riquotato prima dell'uso.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
  <title>Porting da PL/SQL di <productname>Oracle</productname></title>

  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>porting da PL/SQL a PL/pgSQL</secondary>
  </indexterm>

  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>porting a PL/pgSQL</secondary>
  </indexterm>

  <para>
Questa sezione spiega le differenze tra il linguaggio 
<application>PL/pgSQL</application> di <productname>PostgreSQL</productname> 
e il linguaggio <application>PL/SQL</application> di Oracle,
per aiutare di sviluppatori che portano applicazioni da
<trademark class="registered">Oracle</trademark>  a  <productname>PostgreSQL</productname>.
  </para>

  <para>
<application>PL/pgSQL</application>  è simile a PL/SQL in molti aspetti.
Esso è un linguaggio strutturato a blocchi, imperativo, e tutte le variabili devono essere dichiarate.
Assegnamenti, cicli e condizioni sono simili. Le differenze principali 
che si dovrebbero tenere in mente quando si fa il porting da 
<application>PL/SQL</application> a <application>PL/pgSQL</application> sono:

    <itemizedlist>
     <listitem>
      <para>
Se un nome usato in un comando SQL può essere sia il nome di una colonna o di una tabella sia
un riferimento a una variabile della funzione, 
<application>PL/SQL</application> lo tratta come nome di una colonna. Questo corrisponde
al comportamento <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>
di <application>PL/pgSQL</application>, che non è il modo predefinito,
come spiegato in <xref linkend="plpgsql-var-subst"/>.
Spesso è meglio evitare queste ambiguità fin da subito,
ma se si deve portare una grande quantità di codice che usa
questo comportamento, impostare <literal>variable_conflict</literal> potrebbe essere 
la migliore soluzione.
      </para>
     </listitem>

     <listitem>
      <para>
In <productname>PostgreSQL</productname> il corpo della funzione deve essere scritto come 
una stringa letterale. Perciò è necessario usare la quotazione con dollari o fare l'escape
dei singoli apici nel corpo della funzione. (Si veda <xref
linkend="plpgsql-quote-tips"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
Invece di pacchetti, usare gli schemi per organizzare in gruppi le funzioni.
      </para>
     </listitem>

     <listitem>
      <para>
Dato che non ci sono pacchetti, non ci sono nemmeno variabili a livello di pacchetto. 
Questo è abbastanza irritante. È possibile invece mantenere gli stati della sessione 
in tabelle temporanee.
      </para>
     </listitem>

     <listitem>
      <para>
I cicli <command>FOR</command> di interi con <literal>REVERSE</literal> funzionano 
diversamente: <application>PL/SQL</application> conta all'indietro dal secondo numero al primo,
mentre <application>PL/pgSQL</application> conta all'indietro 
dal primo numero al secondo, richiedendo che i limiti del ciclo siano 
invertiti quando si fa il porting. Questa incompatibilità è spiacevole
ma probabilmente non sarà cambiata. (Si veda <xref
linkend="plpgsql-integer-for"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
Anche i cicli <command>FOR</command> sulle query (all'infuori che i cursori) 
funzionano diversamente: la variabile/i deve essere stata dichiarata,
mentre  <application>PL/SQL</application> li dichiara sempre implicitamente.
Un vantaggio di questo è che i valori della variabile sono comunque accessibili 
dopo l'uscita dal ciclo.
      </para>
     </listitem>

     <listitem>
      <para>
Ci sono varie differenze di notazione per l'uso di variabili cursore.
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
   <title>Esempi di porting</title>

   <para>
<xref linkend="pgsql-porting-ex1"/> mostra come portare una funzione semplice
da <application>PL/SQL</application> a <application>PL/pgSQL</application>.
   </para>

   <example id="pgsql-porting-ex1">
    <title>Portare una funzione semplice da <application>PL/SQL</application> a 
    <application>PL/pgSQL</application></title>

    <para>
Ecco una funzione <productname>Oracle</productname> <application>PL/SQL</application>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURN varchar IS
BEgin
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

    <para>
Guardiamo questa funzione per vedere le differenze comparate a 
<application>PL/pgSQL</application>:

     <itemizedlist>
      <listitem>
       <para>
La parola chiave <literal>RETURN</literal> nel prototipo della funzione 
(non nel corpo della funzione) diventa 
<literal>RETURNS</literal> in
<productname>PostgreSQL</productname>.
Inoltre, <literal>IS</literal> diventa <literal>AS</literal>, e c'è bisogno di 
aggiungere una clausola <literal>LANGUAGE</literal> dato che <application>PL/pgSQL</application>
non è l'unico linguaggio possibile per la funzione.
       </para>
      </listitem>

      <listitem>
       <para>
In <productname>PostgreSQL</productname>, il corpo della funzione viene cosiderato 
essere una stringa letterale, così è necessario usare le virgolette o la quotazione con dollari
attorno ad essa. Questo sostituisce la <literal>/</literal> terminante
nell'approccio Oracle.
       </para>
      </listitem>

      <listitem>
       <para>
Il comando <literal>show errors</literal> non esiste in 
<productname>PostgreSQL</productname>, e non è necessario dato che gli errori sono  
riportati automaticamente.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
Così è come apparirebbe la funzione quando portata a 
<productname>PostgreSQL</productname>:

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEgin
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
   </example>

   <para>
<xref linkend="plpgsql-porting-ex2"/> mostra come portare una funzione 
che crea un'altra funzione e come gestire i conseguenti problemi 
di quotazione.
   </para>

   <example id="plpgsql-porting-ex2">
    <title>Portare una funzione che crea un'altra funzione da
    <application>PL/SQL</application> a <application>PL/pgSQL</application></title>

    <para>
La procedura seguente prende righe da un'istruzione <command>SELECT</command>
e costruisce una grande funzione con i risultati in istruzioni <literal>IF</literal>,
nell'interesse dell'efficienza.
    </para>

    <para>
Questa è la versione Oracle:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEgin';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

    <para>
Ecco come questa funzione diventerebbe in <productname>PostgreSQL</productname>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEgin
    func_body := 'BEgin';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
Notare come corpo della funzione sia costruito separatamente e passato
attraverso <literal>quote_literal</literal> per raddoppiare qualsiasi virgoletta. Questa
tecnica è necessario perchè non è possibile usare la quotazione con dollari in sicurezza per
definire la nuova funzione: non sappiamo con sicurezza quali stringhe saranno
interpolate dal campo <structfield>referrer_key.key_string</structfield>.
(Si sta assumendo che <structfield>referrer_key.kind</structfield> possa essere 
creduto come essere sempre <literal>host</literal>, <literal>domain</literal>, o
<literal>url</literal>, ma <structfield>referrer_key.key_string</structfield> potrebbe essere 
qualsiasi cosa, in particolare potrebbe contenere segni dollaro). Questa funzione
attualmente è effettivamente un miglioramento rispetto a Oracle, dato che non genererà
codice rotto quando <structfield>referrer_key.key_string</structfield> o
<structfield>referrer_key.referrer_type</structfield> contengono virgolette.
    </para>
   </example>

   <para>
<xref linkend="plpgsql-porting-ex3"/> mostra come portare una funzione 
con parametri <literal>OUT</literal> e manipolazione di stringhe.
<productname>PostgreSQL</productname> non ha una funzione <function>instr</function>
incorporata, ma si può crearla usando una combinazione di 
altre funzioni. <indexterm><primary>instr</primary></indexterm> 
In <xref linkend="plpgsql-porting-appendix"/> c'è un'implementazione <application>PL/pgSQL</application>
di <function>instr</function> che si più usare per rendere più facile il porting.
   </para>

   <example id="plpgsql-porting-ex3">
    <title>Portare una procedura con manipolazione di stringhe 
    e parametri <literal>OUT</literal> da <application>PL/SQL</application> a
    <application>PL/pgSQL</application></title>

    <para>
La procedura <productname>Oracle</productname> PL/SQL seguente viene usata 
per fare il parsing di un URL e restituire diversi elementi (host, path e query).
    </para>

    <para>
Questa è la versione Oracle:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- This will be passed back
    v_path OUT VARCHAR,  -- This one too
    v_query OUT VARCHAR) -- And this one
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

    <para>
Ecco una possibile traduzione in <application>PL/pgSQL</application>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- This will be passed back
    v_path OUT VARCHAR,  -- This one too
    v_query OUT VARCHAR) -- And this one
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEgin
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

Questa procedura può essere usata in questo modo:
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
   </example>

   <para>
<xref linkend="plpgsql-porting-ex4"/> mostra come portare una procedura 
che usa numerose caratteristiche che sono specifiche di Oracle.
   </para>

   <example id="plpgsql-porting-ex4">
    <title>Portare una procedura da <application>PL/SQL</application> a <application>PL/pgSQL</application></title>

    <para>
     La versione Oracle:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma"/>
BEgin
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable"/>

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- free lock<co id="co.plpgsql-porting-commit"/>
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEgin
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>

   <para>
Procedure come questa possono essere facilmente convertire in funzioni <productname>PostgreSQL</productname>
che ritornano <type>void</type>. Questa procedura in particole
è interessante perchè insegna alcune cose:

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-pragma">
      <para>
In <productname>PostgreSQL</productname> non c'è l'istruzione <literal>PRAGMA</literal>.
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-locktable">
      <para>
Se si fa una <command>LOCK TABLE</command> in <application>PL/pgSQL</application>,
il lock non sarà rilasciato finchè la transazione chiamante non è finita. 
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-commit">
      <para>
Non è possibile specificare <command>COMMIT</command> in una funzione 
<application>PL/pgSQL</application>. La funzione è
in esecuzione all'interno di qualche altra transazione e quindi <command>COMMIT</command>
implicherebbe la terminazione dell'esecuzione della funzione. Comunque, in questo caso particolare
non è necessaria, dato che il lock ottenuto da <command>LOCK TABLE</command>
sarà rilasciato quando si genere un errore.
      </para>
     </callout>
    </calloutlist>
   </para>

   <para>
È possibile portare questa procedura a <application>PL/pgSQL</application> in questo modo:

<programlisting>
CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEgin
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEgin
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <co id="co.plpgsql-porting-exception"/>
            -- don't worry if it already exists
    END;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
La sintassi di <literal>RAISE</literal> è considerevolmente diversa dall'istruzione
Oracle, anche se il caso base <literal>RAISE</literal>
<replaceable class="parameter">exception_name</replaceable> funziona
similmente.
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
I nomi delle eccezioni supportate da <application>PL/pgSQL</application> sono 
diversi da quelli di Oracle. L'insieme dei nomi di eccezione incorporate
è molto più grande (si veda <xref linkend="errcodes-appendix"/>). Attualmente non c'è un modo
per dichiarare nomi di eccezioni definite dall'utente,
anche se è possibile lanciare valori SQLSTATE scelti dall'utente.
      </para>
     </callout>
    </calloutlist>

La principale differenza funzionale tra questa procedura e l'equivalente 
Oracle è che il lock esclusivo sulla tabella <literal>cs_jobs</literal>
sarà preso finchè la transazione chiamante si completa. Inoltre, se 
il chiamante più tardi fallsice (per esempio a caus di un errore), gli effetti di questa procedura saranno
sottoposti a rollback.
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
   <title>Altre cose da tenere di conto</title>

   <para>
Questa sezione spiega alcune altre cose da tenere di conto quando si portano
funzioni <application>PL/SQL</application> di Oracle a 
<productname>PostgreSQL</productname>.
   </para>

   <sect3 id="plpgsql-porting-exceptions">
    <title>Rollback implicito dopo eccezioni</title>

    <para>
In <application>PL/pgSQL</application>, quando un'eccezione viene catturata con una clausola 
<literal>EXCEPTION</literal>, tutti i cambiamenti al database dal blocco <literal>BEGIN</literal>
vengono automaticamente sottoposti a rollback. Cioè, il comportamento è equivalente
a quello che si otterrebbe in Oracle con:     

<programlisting>
BEgin
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;
</programlisting>

Se si sta traducendo una procedura Oracle che usa
<command>SAVEPOINT</command> e <command>ROLLBACK TO</command> in questo stile, 
il compito è semplice: omettere semplicemente  <command>SAVEPOINT</command> e
<command>ROLLBACK TO</command>. Se si ha una procedura che usa
<command>SAVEPOINT</command> e <command>ROLLBACK TO</command> in maniera differente allora
sarà richiesto qualche effettivo pensiero.
    </para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para>
La versione  <application>PL/pgSQL</application> di
<command>EXECUTE</command> funziona similarmente alla versione
<application>PL/SQL</application>, ma si deve ricordare di usare 
<function>quote_literal</function> e
<function>quote_ident</function> come descritto in <xref
linkend="plpgsql-statements-executing-dyn"/>. Costrutti del tipo
<literal>EXECUTE 'SELECT * FROM $1';</literal> non funzioneranno 
correttamente finchè si usano queste fuzioni.
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
    <title>Ottimizzare funzioni <application>PL/pgSQL</application></title>

    <para>
<productname>PostgreSQL</productname> fornisce due modificatori di creazione di funzioni
per ottimizzare l'esecuzione: <quote>volatility</quote> (se la funzione restituisce 
sempre lo stesso risultato quando forniti gli stessi argomenti) e 
<quote>strictness</quote> (nel caso la funzione 
restituisca null se qualsiasi argomento è null). Consultare la pagina di riferimento 
<xref linkend="sql-createfunction"/> per dettagli.
    </para>

    <para>
Quando si fa uso di questi attributi di ottimizzazione, 
l'istruzione <command>CREATE FUNCTION</command> potrebbe somigliare a qualcosa del genere:

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
   <title>Appendice</title>

   <para>
Questa sezione contiene il codice per un insieme di funzioni 
compatibili Oracle <function>instr</function> che si possono usare per semplificare 
gli sforzi di porting.
   </para>

<programlisting>
--
-- funzioni instr che imitano la controparte Oracle
-- Sintassi: instr(string1, string2, [n], [m]) dove [] denota parametri opzionali.
--
-- Le ricerche di string1 cominciano dal n-esimo carattere per la m-esima occorrenza
-- di string2.  Se n è negativo, cerca all'indietro.  Se m non è passato,
-- assume 1 (la ricerca comincia dal primo carattere).
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEgin
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEgin
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEgin
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
  </sect2>

 </sect1>

</chapter>

<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="backup">
 <title>Backup e ripristino</title>

 <indexterm zone="backup"><primary>backup</primary></indexterm>

 <para>
Come ogni cosa che contiene dati preziosi, 
si dovrebbero fare regolarmente dei backup dei database 
<productname>PostgreSQL</productname>. 
Mentre la procedura è essenzialmente semplice, è importante avere una comprensione
chiara delle tecniche di fondo e delle assunzioni.
 </para>

 <para>
Fondamentalmente ci sono tre differenti approcci per fare il back up di  
dati <productname>PostgreSQL</productname>:
  <itemizedlist>
   <listitem><para><acronym>SQL</acronym> dump</para></listitem>
   <listitem><para>Backup a livello di file sustem</para></listitem>
   <listitem><para>Archiviazione continua</para></listitem>
  </itemizedlist>
Ognuno ha i propri punti di forza e le proprie debolezze; ognuno è discusso a turno
nelle sezioni seguenti.
 </para>

 <sect1 id="backup-dump">
  <title><acronym>SQL</acronym> Dump</title>

  <para>
L'idea che sta dietro a questo metodo di dump è di generare un file di testo con
comandi SQL che, quando ritrasmesso al server, ricreerà il database
nello stesso stato in cui si trovava al momento del dump.
<productname>PostgreSQL</productname> fornisce il programma d'utilità
<xref linkend="app-pgdump"/> per questo scopo. L'utilizzo di base di questo
comando:
<synopsis>
pg_dump <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">outfile</replaceable>
</synopsis>
Come si può notare, <application>pg_dump</application> scrive il risultato nello
standard output. Si vedrà sotto in che modo questo può essere utile.
  </para>

  <para>
<application>pg_dump</application> è una normale applicazione client per 
<productname>PostgreSQL</productname>  (sebbene sia particolarmente intelligente).
Questo significa che è possibile eseguire questa procedura di backup da ogni
host remoto che ha accesso al database. Ricordare comunque che 
<application>pg_dump</application> non funziona con permessi speciali.
In particolare, deve avere accesso in lettura a tutte le tabelle di cui si vuole
fare il back up, in pratica si dovrà lanciarlo quasi sempre come superutente del database.
  </para>

  <para>
   To specify which database server <application>pg_dump</application> should
Per specificare quale server database dovrebbere essere contattato da 
<application>pg_dump</application>, usare l'opzione a linea di comando
   contact, use the command line options <option>-h
<option>-h <replaceable>host</replaceable></option> e 
   <replaceable>host</replaceable></option> and <option>-p <replaceable>port</replaceable></option>. The
<option>-p <replaceable>port</replaceable></option>. L'host predefinito
è l'host locale o quello specificato dalla variabile di sistema <envar>PGHOST</envar>.
Similarmente, la porta predefinita è indicata dalla variabile di sistema <envar>PGPORT</envar>
o, fallendo quella, la predefinita alla compilazione.
(Convenientemente, il server normalmente avrà lo stesso valora predefinito alla  
compilazione).
  </para>

  <para>
Come ogni altra applicazione client <productname>PostgreSQL</productname>,
<application>pg_dump</application> si connetterà in maniera predefinita al database  
con lo stesso nome dell'utente corrente del sistema operativo. Per cambiare questo 
comportamento, specificare l'opzione <option>-U</option> o impostare 
la variabile d'ambiente <envar>PGUSER</envar>. Ricordare che le connessioni
<application>pg_dump</application> sono sottoposte ai normali meccanismi 
di autenticazione dei client (che sono descritti nel <xref
linkend="client-authentication"/>).
  </para>

  <para>
Un vantaggio importante di <application>pg_dump</application> rispetto agli altri
metodi di backup descritti successivamente è che l'output di 
<application>pg_dump</application> può essere generalmente importato in versioni successive
di <productname>PostgreSQL</productname>,
mentre backup a livello di file system e l'archiviazione continua sono entrambi
estremamente scpecifici alla versione del server. <application>pg_dump</application> è
anche l'unico metodo che funzionerà quando si dovrà trasferire un 
database su una macchina con architettura differente, come il passaggio 
da un server a 32 bit ad uno a 64 bit.
  </para>

  <para>
I dump creati da <application>pg_dump</application> sono internamente consistenti,
cioè, il dump rappresenta un'istantanea del database al momento che 
<application>pg_dump</application> è stato lanciato. <application>pg_dump</application>
non blocca altre operazioni sul database mentre sta lavorando.
(Ad eccezione di operazioni che hanno bisogno di operare con un lock esclusivo,
come la maggior parte delle forme di <command>ALTER TABLE</command>).
  </para>

  <important>
   <para>
Se lo schema del database si basa sgli OID (per esempio, come chiavi esterne)
si deve istruire <application>pg_dump</application> ad eseguire il dump anche degli OID
Per farlo, usare l'opzione a linea di comando <option>-o</option>.
   </para>
  </important>

  <sect2 id="backup-dump-restore">
   <title>Ripristinare il dump</title>

   <para>
I file di testo creati da <application>pg_dump</application> sono fatti per 
essere letti dal programma <application>psql</application>. Il comando generale
per ripristinare un dump è
<synopsis>
psql <replaceable class="parameter">dbname</replaceable> &lt; <replaceable class="parameter">infile</replaceable>
</synopsis>
dove <replaceable class="parameter">infile</replaceable> è il file creato dal comando
<application>pg_dump</application>. 
Il database <replaceable class="parameter">dbname</replaceable>
non sarà creato da questo comando, per questo si dovrà crearlo da <literal>template0</literal> 
prima di eseguire <application>psql</application> (per es., con
<literal>createdb -T template0 <replaceable class="parameter">dbname</replaceable></literal>).
<application>psql</application> supporta opzioni simili a <application>pg_dump</application>
per specificare il server database al quale connettersi e il nome utente da usare.
Se veda la pagina di referenza  <xref linkend="app-psql"/> per maggiori informazioni.
   </para>

   <para>
Prima di ripristinare un dump SQL, tutti gli utenti che possiedono oggetti o 
a cui sono stati concessi permessi su oggetti nel database sottoposto a dump devono già
esistere. Altrimenti, il ripristino fallirà nel ricreare gli oggetti 
con l'originale proprietà e/o permessi.
(A volte questo è quello che si vuole, ma di solito no).
   </para>

   <para>
In maniera predefinita, lo script <application>psql</application> continuerà a
viaggiare dopo che viene riscontrato un errore SQL. Si potrebbe voler lanciare
<application>psql</application> con la variabile <literal>ON_ERROR_STOP</literal>
impostata per modificare quel comportamento e far si che <application>psql</application>
esca con uno stato d'uscita 3 se si presenta un errore SQL:
<programlisting>
psql --set ON_ERROR_STOP=on dbname &lt; infile
</programlisting>
D'altro canto, si avrà un database ripristinato solo parzialmente.
Alternativamente, è possibile specificare che l'intero dump dovrebbe essere
ripristinato come una singola transazione, così il ripristino sarà o completamente 
compeltato o completamente revertito. Questo modo può essere specificato passando 
l'opzione a riga di comando <option>-1</option> o <option>--single-transaction</option>
a <application>psql</application>. Quando si usa questo modo,
fare attenzione che anche un piccolo errore può portare al rollback di un ripristino
che stava girando da molte ore. Comunque, sarebbe preferibile pulire a mano
un database complesso dopo un dump parzialmente rispristinato.
   </para>

   <para>
L'abilità di <application>pg_dump</application> e <application>psql</application> di
di scrivere e leggere dalle pipe rende possibile fare il dump di un database
direttamente da un server ad un altro, per esempio:
<programlisting>
pg_dump -h <replaceable>host1</replaceable> <replaceable>dbname</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>dbname</replaceable>
</programlisting>
   </para>

   <important>
    <para>
I dump prodotti da <application>pg_dump</application> sono relativi a
<literal>template0</literal>. Questo significa nel dump finirà anche ogni linguaggio, 
procedura,
ecc. aggiunta attraverso <literal>template1</literal>. Come risultato,
quando si esegue un ripristino, se si sta utilizzando un <literal>template1</literal>
modificato, si deve creare un database vuoto da <literal>template0</literal>,
come nell'esempio sopra.
    </para>
   </important>

   <para>
Dopo il ripristino di un backup, è saggio lanciare <xref
linkend="sql-analyze"/> su ogni database, così l'ottimizzatore di query
avrà statistiche utili;
si veda <xref linkend="vacuum-for-statistics"/> e
<xref linkend="autovacuum"/> per maggiori informazioni.
Per ulteriori consigli su come caricare grandi quantità di dati 
in <productname>PostgreSQL</productname> efficentemente, si rimanda al
<xref linkend="populate"/>.
   </para>
  </sect2>

  <sect2 id="backup-dump-all">
   <title>Usare <application>pg_dumpall</application></title>

   <para>
<application>pg_dump</application> esegue il dump di un solo database alla volta,
e non esegue il dump delle informazioni sui ruoli o sui tablespace
(dato che queste sono a livello di cluster piuttosto che a livello di database).
Per avere un dump comodo dell'intero contenuto di un cluster database, è
disponibile il programma <xref linkend="app-pg-dumpall"/>.
<application>pg_dumpall</application> esegue il backup di ogni database in un dato cluster,
e conserva anche i dati a livello di cluster che sono ruoli e definizioni
tablespace. L'utilizzo di base di questo comando è:
<synopsis>
pg_dumpall &gt; <replaceable>outfile</replaceable>
</synopsis>
Il dump risultante può essere ripristinato con <application>psql</application>:
<synopsis>
psql -f <replaceable class="parameter">infile</replaceable> postgres
</synopsis>
(Attualmente, è possibile specificare ogni nome di database esistente da cui partire,
ma se si sta caricando in un cluster vuoto allora di solito dovrebbe essere usato
<literal>postgres</literal>). È sempre necessario avere accesso
al database come superutente quando si ripristina un dump fatto con 
<application>pg_dumpall</application>, dato che è richiesto di ripristino di informazioni
sui ruoli e sui tablespace, assicurarsi che i percorsi dei tablespace nel dump
siano appropriati per la nuova installazione.
   </para>

   <para>
<application>pg_dumpall</application> funziona emettendo comandi per ricreare 
ruoli, tablespace, e database vuoti, quindi invocando
<application>pg_dump</application> per ogni database. Questo significa che mentre
ogni database sarà internamente consistente, l'istantanea dei 
diversi database potrebbe non essere esattamente identica.
   </para>
  </sect2>

  <sect2 id="backup-dump-large">
   <title>Gestire grandi database</title>

   <para>
Qualche sistema operativo ha limiti per la dimensione massima dei file che causa problemi
quando si creano file <application>pg_dump</application> grandi.
Fortunatamente, <application>pg_dump</application> può scrivere sullo standard output, 
così è possibile usare gli strumenti Unix standard per superare questo potenziale problema. 
Ci sono diversi metodi possibili:
   </para>

   <formalpara>
    <title>Usare dump compressi.</title>
    <para>
È possibile usare il programma di compressione preferito, per esempio
<application>gzip</application>:

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | gzip &gt; <replaceable class="parameter">filename</replaceable>.gz
</programlisting>

     Ricaricare con:

<programlisting>
gunzip -c <replaceable class="parameter">filename</replaceable>.gz | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>

     o:

<programlisting>
cat <replaceable class="parameter">filename</replaceable>.gz | gunzip | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title>Usare <command>split</command>.</title>
    <para>
Il comando <command>split</command>
permette di dividere l'output il file più piccoli che sono
accettabili in dimensione per il file system. Per esempio, 
per fare pezzi da 1 megabyte:

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 1m - <replaceable class="parameter">filename</replaceable>
</programlisting>

     Ricaricare con:

<programlisting>
cat <replaceable class="parameter">filename</replaceable>* | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title>Usare il formato di dump 
    personalizzato di <application>pg_dump</application></title>
    <para>
Se <productname>PostgreSQL</productname> è stato compilato su un sistema con la libreria
di compressione <application>zlib</application> installata, il formato di 
compressione personalizzato comprimerà i dati mentre li scrive nel file di output. 
Questo produrrà dimensioni dei file di dump simili all'utilizzo di <command>gzip</command>,
ma avrà il vantaggio aggiuntivo che le tabelle possono essere ripristinate selettivamente. 
Il seguente comando fa il dump di un database usando il formato di dump personalizzato:

<programlisting>
pg_dump -Fc <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">filename</replaceable>
</programlisting>

Un file di dump generato in questo modo non è uno script per <application>psql</application>, 
ma deve essere ripristinato con <application>pg_restore</application>, per esempio:

<programlisting>
pg_restore -d <replaceable class="parameter">dbname</replaceable> <replaceable class="parameter">filename</replaceable>
</programlisting>

Si veda le pagine di referenza <xref linkend="app-pgdump"/> e <xref
linkend="app-pgrestore"/> per dettagli.
    </para>
   </formalpara>

   <para>
Per database molto grandi, si potrebbe aver necessità di combinare <command>split</command>
con uno degli altri due approcci.
   </para>

  </sect2>
 </sect1>

 <sect1 id="backup-file">
  <title>Backup a livello di file system</title>

  <para>
Una strategia alternativa per il backup è copiare direttamente i file usati da 
<productname>PostgreSQL</productname> per immagazzinare i dati nel database;
<xref linkend="creating-cluster"/> spiega dove sono collocati questi file.
È possibile usare qualsiasi metodo si preferisce 
per fare backup di file system; per esempio:

<programlisting>
tar -cf backup.tar /usr/local/pgsql/data
</programlisting>
  </para>

  <para>
Ci sono due restrizioni, comunque, che rendono questo metodo impraticabile,
o almeno inferiore al metodo <application>pg_dump</application>:

   <orderedlist>
    <listitem>
     <para>
Il server database <emphasis>deve</emphasis> essere spento per ottenere un backup usabile.
Mezze misure, tipo non permettere altre connessioni, non funzioneranno
(in parte perchè <command>tar</command> e strumenti simili non prendono 
un'istantanea atomica dello stato del file system,
ma anche perchè ci sono operazioni di buffering all'interno del server).
Informazioni sull'arresto del server possono essere trovate in
<xref linkend="server-shutdown"/>. Inutile dire che è necessario 
arrestare il server anche prima del ripristino dei dati.
     </para>
    </listitem>

    <listitem>
     <para>
Se ci si è addentrati nei dettagli dei come sul file system è organizzato il database, 
si potrebbe esser tentati di provare a fare il backup o il ripristino solo alcune
tabelle o database dai loro rispettivi file o directory.
Questo <emphasis>non</emphasis> funzionerà perchè le informazioni contenute
in questi file non sono usabili senza i file di log delle commit,
<filename>pg_clog/*</filename>, che contiene lo stato delle commit di tutte le transazioni.
Un file di una tabella è usabile solo con queste informazioni.
Ovviamente è impossibile anche ripristinare solo una tabella 
e l'associatio <filename>pg_clog</filename>  perchè questo renderà 
tutte le altre tabelle nel cluster inutili.
Per questo, i backup a livello di file system funzioneranno solo per 
l'intero cluster.
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
Un approccio alternativo per un backup a livello di file system è di 
fare una <quote>consistent snapshot</quote> della directory dei dati, se
il file system supporta quella funzionalità (e ti fidi che sia implementata 
correttamente). La procedura tipica è di fare una <quote>frozen snapshot</quote> 
del volume che contiene il database, quindi copiare l'intera directory dei dati 
(non solo parti, vedere sopra) dalla snapshot a un dispositivo di backup, quindi rilasciare
la <quote>frozen snapshot</quote>. Questo funzionerà anche mentrw il database è in esecuzione.
Comunque, un backup creato in questo modo salva i file del database
in uno stato come se il server database non fosse stato terminato nel modo giusto;
quindi, quando si avvia il server database
sui dati sottoposti a backup, esso penserà che la precedente istanza del server 
abbia subito un crash e repeterà il log WAL. Questo non è un problema;
esserne semplicemente consapevoli (e assicurarsi di includere i file WAL nel proprio backup).
  </para>

  <para>
Se il database è distibuito su più filesystem, non ci potrebbe essere modo di
ottenere frozen snapshot esattamente simultanee di tutti i volumi.
Per esempio, se i dati e i log WAL sono su dischi diversi,
o se i tablespace sono su differenti file system, potrebbe non essere possibile 
usare il meodo di backup basato sulle snapshot dato che queste <emphasis>devono</emphasis> 
essere
simultanee.
Leggere la documentazione del file system molto attentamente prima di usare
la tecnica delle snapshot consistenti.
  </para>

  <para>
Se snapshot simultanee non sono possibili, un'opzione è di spengere il server database
abbastanza a lungo da determinare tutte le frozen snapshot. 
Un'altra opzione è quella di eseguire backup basati sull'archiviazione continua (<xref
linkend="backup-base-backup"/>) perchè questi backup sono immuni ai cambiamenti
del file system durante il backup. Questo richiede l'autorizzazione all'archiviazione
continua solo durante il processo di backup; il ripristino viene fatto
usando <xref linkend="backup-pitr-recovery"/>.
  </para>

  <para>
Un'altra opzione è di usare <application>rsync</application> per compiere un backup
di file system. Questo è fatto lanciando prima <application>rsync</application>
mentre il serve è in esecuzione, quindi terminando il server database
abbastanza a lungo per fare una seconda <application>rsync</application>. Questa
sarà molto più veloce della prima, 
dato che ha relativamente pochi dati da trasferire, e il risultato finale
sarà consistente perchè il server è spento. Questo metodo
permette a un backup a livello di file system di essere eseguito con un tempo
minimo in cui il server non gira.
  </para>

  <para>
Notare che un backup a livello di file system sarà tipicamente più grande
di un dumpo SQL. (<application>pg_dump</application> non ha bisogno di fare il dump
del contenuto degli indici, solo dei comandi per ricrearli). 
Comunque, eseguire un backup di file system potrebbe essere più veloce.
  </para>
 </sect1>

 <sect1 id="continuous-archiving">
  <title>Archiviazione continua e Ripristino Point-In-Time (PITR)</title>

  <indexterm zone="backup">
   <primary>archiviazione continua</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>ripristino point-in-time</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>

  <para>
In ogni momento, <productname>PostgreSQL</productname> tiene un
<firstterm>write ahead log</firstterm> (WAL) 
nella sottodirectory <filename>pg_xlog/</filename>
della directory dei dati del cluster. Il log registra
ogni cambiamento fatto ai file dei dati del database. Questo log esiste 
principalmente per motivi di sicurezza rispetto ai crash: se il sistema si blocca,
il database può essere ripristinato alla consistenza facendo un 
<quote>replay</quote> delle voci di log
dall'ultimo punto di controllo (checkpoint). Comunque, l'esistenza
del log rende possibile una terza strategia per effetuare il backup dei 
database: è possibile combinare un backup a livello di file system con un backup dei 
file WAL. Se è necessario un recupero, ripristinare il backup e successivamente
fare un replay di ogni voce dai file WAL del backup per portare il sistema allo stato
corrente. Questo approccio è più complesso da amministrare rispetto i precedenti
approcci, ma ha alcuni vantaggi significanti:
  <itemizedlist>
   <listitem>
    <para>
Non si avrà bisogno di un backup a livello di file system perfettamente consistente 
come punto di partenza. Ogni inconsistenza interna nel backup verrà corretta dal replay
del log (questo non è significativamente diverso da cosa accade durante un 
recupero da un crash). Così non si avrà bisogno di capacità di snapshot del file system,
basterà <application>tar</application> o uno strumento di archiviazione simile.
    </para>
   </listitem>
   <listitem>
    <para>
Dato che è possibile combinare sequenze di file WAL indefinitamente lunghe per il replay,
un backup continuo può essere realizzato semplicemente continuando ad archiviare 
i file WAL. Questo è particolarmente vantaggioso per grandi database, dove 
potrebbe non essere conveniente eseguire un backup completo frequentemente.
    </para>
   </listitem>
   <listitem>
    <para>
Non è necessario fare il replay delle voci WAL sempre fino alla fine.
È possibile fermare il replay in qualsiasi momento e avere una snapshot
consistente del database com'era in quel momento. Così,
questa tecnica supporta <firstterm>recuperi point-in-time</firstterm>: è 
possibile ripristinare il database al suo stato in ogni momento da quando è
stato effettuato il backup di base.
    </para>
   </listitem>
   <listitem>
    <para>
Se si alimenta continuamente un'altra macchina, che è stata caricata con lo stesso 
file  backup di base, 
con la serie di file WAL, si ottiene un sistema di <firstterm>warm standby</firstterm>:
in ogni istante è possibile tirare su la seconda macchina e avremo una copia del database
corrente.
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <note>
   <para>
<application>pg_dump</application> e <application>pg_dumpall</application>
non producono backup a livello di file system e non possono essere usati come parte
si una soluzione di archiviazione continua.
Quei dump sono <emphasis>logici</emphasis> e non contengono abbastanza 
informazioni da essere usati come replay WAL.
   </para>
  </note>

  <para>
Come con la tecnica del backup semplice a livello di file system, questo metodo  
supporta il ripristino di un intero cluster, non di un sottoinsieme.
Inoltre, richiede molto spazio per l'archiviazione: 
il backup di base potrebbe essere voluminoso,
e un sistema impegnato genererà molti megabute di traffico WAL che devono essere
archiviati. Inoltre, è la tecnica di backup preferita in
molte situazioni dove è necessaria alta affidabilità.
  </para>

  <para>
Per recuperare con successo usando l'archiviazione continua (chiamata anche
<quote>backup online</quote> da molti commercianti di database), si ha bisogno di 
continue sequenze di file WAL archiviati che si estendono all'indietro almeno 
al momento di inizio del backup. Così, per iniziare, si dovrebbe impostare e testare 
la procedura per l'archiviazione dei file WAL <emphasis>prima</emphasis> di effettuare 
il backup di base. Di conseguenza, verranno discussi prima i meccanismi di 
archiviazione dei file WAL.
  </para>

  <sect2 id="backup-archiving-wal">
   <title>Impostare l'archiviazione WAL</title>

   <para>
Parlando in senso astratto, un sistema <productname>PostgreSQL</productname> in esecuzione
produce una sequenza di record WAL indefinitamente lunga. Il sistema fisicamente
divide questa sequenza in <firstterm>file di segmento</firstterm> WAL,
che normalmente sono di 16MB (anche se la dimensione del segmento
può essere modificata durante la compilazione di <productname>PostgreSQL</productname>).
Ai file di segmento vengono dati nomi numerici che rispecchiano la loro posizione
nella sequenza WAL astratta. Quando non si usa l'archiviazione WAL, il sistema normalmente
crea solo pochi file segmento e successivamente li 
<quote>ricicla</quote> rinominando i file segmento non più necessari 
in numeri di segmento più alti. Si assume che i file segmento il cui contenuto 
precede il checkpoint precedente all'ultimo non siano di interesse e possano
essere riciclati.
   </para>

   <para>
Quando si archiviano dati WAL, si deve catturare il contenuto di ogni file segmento
una volta che è pieno, e salvare quei dati da qualche parte prima che il file segmento
sia riciclato. A seconda dell'applicazione e dell'hardware disponibile,
ci possono essere molti modi diversi di <quote>salvare i dati da qualche parte</quote>:
è possibile copiare i file segmento in una directory montata con NFS in un'altra macchina, 
scriverli su un drive a nastro (assicurandosi che ci sia un modo per indentificare il nome 
originale di ogni file), o raggrupparli e scriverli su CD, o qualcos'altro, 
Per dare all'amministratore di database flessibità, <productname>PostgreSQL</productname>
non tenta di prevede come l'archiviazione verrà fatta. 
Al contrario, <productname>PostgreSQL</productname> lascia che l'amministratore 
specifichi un comando shell da essere eseguito per copiare un file segmento completo
verso ovunque debba andare. Il comando può essere semplice come un <literal>cp</literal>,
o può invocare uno script shell complesso - è a vostra discrezione.
   </para>

   <para>
Per abilitare l'archiviazione WAL, impostare il parametro di configurazione 
<xref linkend="guc-wal-level"/> a <literal>archive</literal> 
(o <literal>hot_standby</literal>),
<xref linkend="guc-archive-mode"/> a <literal>on</literal>,
e specificare il comando shell da usare nel parametro di configurazione
linkend="guc-archive-command"/>. In pratica
queste impostazioni saranno sempre posizionate nel file 
<filename>postgresql.conf</filename>.
In <varname>archive_command</varname>,
<literal>%p</literal> è sostituito dal percorso del file da archiviare, 
mentre <literal>%f</literal> è sostituito dal nome del file.
(Il percorso è relativo alla directory di lavoro corrente, 
per esempio, la directory dati del cluster).
Usare <literal>%%</literal> se si ha necessità di includere il carattere 
<literal>%</literal> nel comando. Il comando più semplice è qualcosa simile a:
<programlisting>
archive_command = 'cp -i %p /mnt/server/archivedir/%f &lt;/dev/null'
</programlisting>
che copierà i segmenti WAL archiviabili nella directory
<filename>/mnt/server/archivedir</filename>. (Questo è un esempio, non una raccomandazione,
e potrebbe non funzionare su tutte le piattaforme). Dopo che i parametri 
<literal>%p</literal> e <literal>%f</literal> sono stati sostituiti,
il comando potrebbe somigliare a questo:
<programlisting>
cp -i pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065 &lt;/dev/null
</programlisting>
Un comando simile sarà generato per ogni nuovo file che deve essere archiviato.
   </para>

   <para>
Il comando archive sarà eseguito sotto la stessa proprietà dello stesso utente
col quale il server <productname>PostgreSQL</productname> è in esecuzione. Dato che
le serie di file WAL archiviate contengono effettivamente ogni cosa
del database, si vorrà essere sicuri che i dati archiviati siano protetti da
occhi indiscreti; per esempio, archiviarli in una directory che 
non ha accesso in lettura per il gruppo o per il mondo.
   </para>

   <para>
È importante che il comando di archiviazione restituisca zero come stato di uscita se
e solo se ha successo. Se ottiene come risultato zero,
<productname>PostgreSQL</productname> assumerà che il file è stato archiviato con successo,
e lo rimuoverà o lo riciclerà. Comunque, uno stato non zero
dice a  <productname>PostgreSQL</productname> che il file non è stato archiviato;
e periodicamente verrà fatto un tentativo finchè non avrà successo.
   </para>

   <para>
Il comando di archiviazione dovrebbe generalmente essere pensato per rifiutare di 
sovrascrivere i file di archivio pre-esistenti. 
Questa è una caratteristica importante per la sicurezza, per preservare l'integrità 
dell'archivio in caso di errori dell'amministratore (tipo l'invio dell'output di due
differenti server alla stessa directory d'archivio).
È consigliabile testare il comando d'archiviazione per assicurare che effettivamente
non sovrascriva file esistenti, <emphasis>e che in quel caso restituisca 
stato non zero</emphasis>. Su molte piattaforme Unix, <command>cp
-i</command> fa si che la copia chieda prima di sovrascrivere un file, e 
<literal>&lt; /dev/null</literal> causa il fallimento in caso di sovrascrittura.
Se la piattaforma usata non supporta questo comportamento, si dovrebbe aggiungere
un comando per testare l'esistenza del file archivio. Per esempio, 
qualcosa simile a:
<programlisting>
archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'
</programlisting>
funziona correttamente sulla maggior parte delle varianti Unix.
   </para>

   <para>
Quando si progetta il setup di archiviazione, considerare cosa accadrà se
il comando di archiviazione fallisce ripetutamente, se per esempio qualche
aspetto richiede l'intervento dell'opertore o l'archivio eccede lo spazio disponibile.
Per esempio, questo puù accadere se si scrive su nastro senza un sostitutore automatico;
quando il nastro è pieno, non è possibile archiviare niente finchè il nastro 
non viene sostituito.
Ci si dovrebbe assicurare che ogni condizione d'errore o richiesta di intervento umano
venga riportato appropriamente in modo che la situazione possa essere
risolta ragionevolmente velocemente. La directory <filename>pg_xlog/</filename>
continuerà a riempirsi con file segmento WAL finchè la situazione non è risolta.
(Se il file system contenente <filename>pg_xlog/</filename> è pieno,
<productname>PostgreSQL</productname> produrrà un arresto PANIC. Le transazioni che non
hanno eseguito il commit saranno perse, ma il database rimarrà offline finchè
non si libera un po' di spazio).
   </para>

   <para>
La velocità del comando di archiviazione non è impotante dato che può tenere il passo
con la velocità media con la quale il server genera dati WAL. Le normali 
operazioni continuano anche se il processo di archiviazione resta un po' indietro.
Se l'archiviazione rimane molto indietro, questo incrementerà l'ammontare dei 
dati che possono essere persi in caso di disastro. Questo significherà anche che
la directory <filename>pg_xlog/</filename> conterrà grandi quantità di file segmento
non ancora archiviati, che eventualmente possono eccedere lo spazio su disco disponibile.
È consigliabile controllare il processo di archiviazione per essere sicuri che 
funzioni come si vuole. 
   </para>

   <para>
Nello scrivere il comando di archivio, si dovrebbe assumere che i nomi dei file da
archiviare possano essere lunghi più di 64 caratteri e possano contenere qualsiasi 
combinazione di lettere ASCII, cifre, e punti. Non è necessario preservare 
il percorso relativo originale (<literal>%p</literal>) ma è necessario 
preservare il nome del file (<literal>%f</literal>).
   </para>

   <para>
Notare che sebbene l'archiviazione WAL permetterà il ripristino di qualsiasi
modifica fatta ai dati del database <productname>PostgreSQL</productname>,
essa non ripristinerà i cambiamenti fatti ai file di configurazione (tipo,
<filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> e
<filename>pg_ident.conf</filename>), dato che questi file sono modificati manualmente 
piuttosto che attraverso operazioni SQL.
Si potrebbe desiderare mantere i file di configurazione in una posizione che sarà
sottoposta a backup dalle normali procedure di backup a livello di file system. Si veda 
<xref linkend="runtime-config-file-locations"/> per capire come trasferire 
i file di configurazione.
   </para>

   <para>
Il comando di archiviazione viene invocato solo su segmenti WAL  completati. Da ora,
se il server genera solo poco traffico WAL (oppure ha periodi morti 
in cui accade), ci potrebbe essere molto ritardo tra il completamento 
di una transazione e la sua registrazione sicura nello spazio di archiviazione. Per mettere
un limite a come possanno essere i vecchi dati non archiviati, è possibile impostare
<xref linkend="guc-archive-timeout"/> per forzare il server a passare
a un nuovo file segmento WAL come minimo ogni tot. Notare che i file archiviati 
che sono archiviati prima a causa dell'opzione vista sopra sono sempre della stessa
lunghezza di file completamente pieni. Non è comunque saggio impostare un 
<varname>archive_timeout</varname> molto piccolo  &mdash; gonfierà lo spazio di archiviazione.
Impostare <varname>archive_timeout</varname> a circa un minuto di solito è ragionevole.
   </para>

   <para>
Inoltre, è possibile forzare un cambiamento di segmento manualmente con
<function>pg_switch_xlog</function> se si vuole assicurare che una transazione
appena terminata venga archiviata il più presto possibile. Altre funzioni utili
relative alla gestione del WAL sono elencate nella <xref
linkend="functions-admin-backup-table"/>.
   </para>

   <para>
Quando <varname>wal_level</varname> è <literal>minimal</literal> alcuni comandi SQL
sono ottimizzati per evitare il log di WAL, come descritto in <xref
linkend="populate-pitr"/>. Se l'archiviazione o la replicazione streaming sono state
attivate durante l'esecuzione di una di queste istruzioni, WAL non conterrebbe
abbastanza informazioni per il recupero dell'archivio. (Il recupero dal crash non viene 
toccato). Per questa ragione, <varname>wal_level</varname> può essere cambiato solo
all'avvio del server. Comunque, <varname>archive_command</varname> può essere cambiato con
un ricaricamento del file di configurazione. Se si desidera fermare temporaneamente 
l'archiviazione, un modo di farlo è impostando <varname>archive_command</varname>
a una stringa vuota  (<literal>''</literal>).
Questo farà si che i file WAL si accumolino in <filename>pg_xlog/</filename> fino a che
non viene stabilito un <varname>archive_command</varname> funzionante. 
   </para>
  </sect2>

  <sect2 id="backup-base-backup">
   <title>Realizzare un backup di base</title>

   <para>
La procedura per realizzare un backup di base è relativamente semplice:
  <orderedlist>
   <listitem>
    <para>
Assicurare che l'archiviazione WAL sia abilitata e funzionante.
    </para>
   </listitem>
   <listitem>
    <para>
Connettersi al database come superurtente e immettere il comando:
<programlisting>
SELECT pg_start_backup('label');
</programlisting>
dove <literal>label</literal> è qualsiasi stringa si voglia usare per indentificare
in modo univoco l'operazione di backup. (Una buona pratica è usare il percorso completo 
nel quale si intende mettere il file dump di backup).
<function>pg_start_backup</function> crea un file <firstterm>etichetta di backup</firstterm>,
chiamato <filename>backup_label</filename>, nella directory cluster, con 
informazioni sul backup, incluso l'orario di inizio e la stringa etichetta.
    </para>

    <para>
Non importa a quale database all'interno del cluster ci si connette per lanciare 
questo comando. È possibile ignorare il risultato restituito dalla funzione;
ma se viene riportato un errore, crercare di ricolverlo prima di procedere.
    </para>

    <para>
In maniera predefinita, <function>pg_start_backup</function> può metterci molto tempo
per finire. 
Questo perchè esegue un checkpoint, e l'I/O richiesto per il checkpoint
sarà spalmato in un periodo di tempo significativo, automaticamente metà dell'intervallo
tra i checkpoint (si veda il parametro di configurazione 
<xref linkend="guc-checkpoint-completion-target"/>). Questo di solito è quello che vuoi,
dato che minimizza l'impatto sull'elaborazione della query.
Se si vuole avviare il backup appena possibile,
usare:
<programlisting>
SELECT pg_start_backup('label', true);
</programlisting>
Questo fa sì che il checkpoint sia fatto il più velocemente possibile.
    </para>
   </listitem>
   <listitem>
    <para>
Esegue il backup, usando qualsiasi strumento utile per il backup a livello di
file system, come <application>tar</application> o <application>cpio</application> (non
<application>pg_dump</application> o <application>pg_dumpall</application>).
Non è necessario nè auspicabile fermare le normali operazioni sul database 
mentre lo si fà.
    </para>
   </listitem>
   <listitem>
    <para>
Connettersi nuovamente al database come superutente, e lanciare il seguente comando:
<programlisting>
SELECT pg_stop_backup();
</programlisting>
Questo termina la modalità backup e compie un cambiamento automatico al prossimo
segmento WAL. La ragione per il cambiamento è di prendere accordi che l'ultimo 
segmento WAL scritto durante l'intervallo di backup sia pronto per l'archiviazione.
    </para>
   </listitem>
   <listitem>
    <para>
Una volta che i segmenti WAL attivi durante il backup sono archiviati, si è finito.
Il file identificato dal risultato di <function>pg_stop_backup</function> è l'ultimo
segmento richiesto per formare un insieme completo di file di backup.
Se <varname>archive_mode</varname> è attivo,
<function>pg_stop_backup</function> non restituisce niente finchè l'ultimo segmento
è stato archiviato. 
L'archiviazione di questi file avviene automaticamente dato che si è
già configurato l'<varname>archive_command</varname>. In molti casi questo avviene 
velocemente, ma si consiglia di controllare il sistema di archiviazione 
per assicurarsi che non ci siano ritardi.
Se il processo di archiviazione è rimasto indietro 
causa fallimenti del comando d'archiviazione, continuerà a provare
finchè l'archiviazione non avrà successo e il backup è completo.
Se si desidera impostare un limite di tempo all'esecuzione di 
<function>pg_stop_backup</function>, specificare un valore appropriato per
<varname>statement_timeout</varname>.
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
Alcuni strumenti di backup a livello di file system producono warning o errori
se i file che stanno tentando di copiare cambiano mentre la copia procede.
Quando si prende un backup base di un database attivo, questa situazione è normale
e non un errore. Comunque, è necessario assicurarsi di poter distinguere
queste situazioni da errori reali. Per esempio, alcune versioni di 
<application>rsync</application> restituiscono un codice di errore separato per 
<quote>file sorgente spariti</quote>, ed è possibile scrivere uno script che
accetti questo codice d'uscita non come un erroe. Inoltre, alcune versioni di 
GNU <application>tar</application> restituiscono un codice di errore indistinguibile
da un errore fatale se un file viene troncato mentre <application>tar</application>
lo sta copiando. Fortunatamente, le versioni di GNU <application>tar</application> 
dalla 1.6 e successive terminano con <literal>1</literal>  se un file è cambiato durante 
il backup e <literal>2</literal> per gli altri errori.
   </para>

   <para>
Non è necessario preoccuparsi dell'ammontare di tempo passato tra
<function>pg_start_backup</function> e l'inizio del backup attuale,
e nemmeno tra la fine del backup e <function>pg_stop_backup</function>; pochi minuti 
di ritardo non saranno dannosi. (Comunque, se normalmente si esegue il server con 
<varname>full_page_writes</varname> disaiblitata, si potrebbe notare un calo
delle prestazioni tra <function>pg_start_backup</function> e
<function>pg_stop_backup</function>, dato che <varname>full_page_writes</varname> è
effettivamente forzata a "on" durante la modilità backup). È necessario assicurare che  
questi passi siano svolti in sequenza, senza qualsiasi possibile 
sovrapposizione, o il backup sarà invalidato.
   </para>

   <para>
Assicurarsi che il dump di backup includa tutti i file sotto 
la directory cluster (per es. <filename>/usr/local/pgsql/data</filename>).
Se si stanno usando tablespace che non stanno in questa directory,
fare attenzione ad includerli (e assicurarsi che il dump di backup archivi 
link simbolici come link, altrimenti il ripristino rovinerà i tablespace).
   </para>

   <para>
È possibile, comunque, omettere dal dump di backup i file dentro la sottodirectory
<filename>pg_xlog/</filename> del cluster. Questo piccolo aggiustamento 
è utile in quanto riduce il rischio di errori durante il ripristino.
Questo è facile da realizzare se <filename>pg_xlog/</filename> è un link simbolico 
che punta fuori dalla directory cluster, che comunque è una pratica comune
per questioni di prestazione.
   </para>

   <para>
Per fare uso del backup, si dovrà tenere tutti i file segmento WAL generati 
durante e dopo il backup a livello di file system.
Per aiutarti a farlo, la funzione <function>pg_stop_backup</function> crea
un <firstterm>file storico di backup</firstterm> che viene immediatamente 
immagazzinato nell'aria di archivio WAL. Questo file è nominato dopo il primo
file segmento WAL di cui si ha bisogno per il backup.
Per esempio, se il file WAL di partenza è
<literal>0000000100001234000055CD</literal> il file storico di backup sarà chiamato 
<literal>0000000100001234000055CD.007C9330.backup</literal>. (La seconda parte 
del nome del file sta per l'esatta posizione all'interno del file WAL,
e puà essere tranquillamente ignorata). Una volta che i file segmento WAL 
e quelli di backup usati durante il backup
sono stati archiviati in modo sicuro (come specificato nel file storico di backup),
tutti i segmenti WAL archiviati con nomi numericamente minori non sono più necessari
per recuperare il backup a livello di file system e possono essere eliminati.
Comunque, si dovrebbe considerare il mantenimento di diversi insiemi di backup 
per essere assolutamente certi che 
si possano recuperare i dati.
   </para>

   <para>
Il file storico di backup è solo un piccolo file di testo. Esso contiene
l'etichetta fornita a  <function>pg_start_backup</function>, così come 
gli orari di inizio e fine e i segmenti WAL del backup.
Se si è usata l'etichetta per identificare il file dump associato, 
allora il file storico archiviato è sufficiente a dirti quale file dump ripristinare.
   </para>

   <para>
Dato che si sono tenuti tutti i file WAL archiviati dall'ultimo backup,
l'intervallo tra i backup di base dovrebbe essere, di solito, 
scelto basandosi su quanto spazio di immagazzinamento di vuole dedicare 
ai file WAL archiviati. Si dovrebbe considerare anche il tempo che si preparati a spendere
per il recupero, se il recupero è necessario - il sistema dovrà fare il replay di tutti quei 
segmenti WAL, e questo potrebbe prendere un po' di tempo se è passato molto tempo 
dall'ultimo backup di base.
   </para>

   <para>
È importante anche notare che la funzione <function>pg_start_backup</function>
crea un file chiamato <filename>backup_label</filename> nella directory di cluster,
che viene rimosso da <function>pg_stop_backup</function>.
Questo file sarà certamente archiviato come parte del file dump di backup.
Il file etichetta di backup include la stringa fornita a
<function>pg_start_backup</function>, così come l'orario dell'avvio di 
<function>pg_start_backup</function>, e il nome del file di partenza del WAL.
In caso di confuzione è inoltre possibile guardare nel file dump di backup 
e determinare esattamente da quale sessione di backup arriva il file dump
   </para>

   <para>
<warning>
    <para>
        TODO
    </para>
</warning>
    It is also possible to make a backup dump while the server is
    stopped.  In this case, you obviously cannot use
    <function>pg_start_backup</function> or <function>pg_stop_backup</function>, and
    you will therefore be left to your own devices to keep track of which
    backup dump is which and how far back the associated WAL files go.
    It is generally better to follow the continuous archiving procedure above.
   </para>
  </sect2>

  <sect2 id="backup-pitr-recovery">
   <title>Ripristino usando un backup ad archiviazione continua</title>

   <para>
Ok, il peggio è successo e si ha bisogno di recuperare dati da un backup.
Ecco la procedura:
  <orderedlist>
   <listitem>
    <para>
Fermare il server, se è in esecuzione.
    </para>
   </listitem>
   <listitem>
    <para>
Se si ha lo spazio per farlo,
copiare l'intera directory di cluster ed ogni tablespace in un luogo temporaneo
nel caso in cui se ne abbia bisogno più tardi. Notare che questa precauzione 
richiederà che si abbia abbastanza spazio libero sul sistema da contenere
due copie dei database esistenti. Se non si ha sufficiente spazio su disco,
si dovrebbe almeno salvare il contenuto della sottodirectory 
del cluster <filename>pg_xlog</filename>, dato che potrebbe contenere log che non
sono stati archiviati prima che il sistema sia caduto.
    </para>
   </listitem>
   <listitem>
    <para>
Rimuovere tutti i file e le sottodirectory esistenti nella directory di cluster
e sotto le directory radice dei tablespace che si stanno usando.
    </para>
   </listitem>
   <listitem>
    <para>
Ripristinare i file del database dal proprio backup di file system. Assicurarsi che
siano ripristinati con la giusta proprietà (l'utente del sistema database, non 
<literal>root</literal>!) e con i giusti permessi. Se si stanno  usando 
tablespace, 
si dovrebbe verificare che i link simbolici in <filename>pg_tblspc/</filename>
siano stati ripristinati correttamente.
    </para>
   </listitem>
   <listitem>
    <para>
Rimuovere qualsiasi file presente in <filename>pg_xlog/</filename>; questi arrivano
dal backup a livello di file system e quindi probabilmente  sono obsoleti.
Se non si è archiviato <filename>pg_xlog/</filename> per niente, allora crearlo 
con i giusti permessi, 
facendo attenzione a impostarlo come link simbolico 
se lo era precedentemente.
    </para>
   </listitem>
   <listitem>
    <para>
Se si hanno file segmento WAL non archiviati salvati dal passo 2,
copiarli in <filename>pg_xlog/</filename>. (È meglio copiarli, 
non spostarli, così da avere comunque i file non modificati se succedesse qualche problema
e di dovesse cominciare tutto daccapo).
    </para>
   </listitem>
   <listitem>
    <para>
Creare un file di recupero <filename>recovery.conf</filename> nella directory  
di cluster (si veda <xref linkend="recovery-config"/>). Si potrebbe anche
voler modificare temporaneamente <filename>pg_hba.conf</filename> per impedire
a utenti comuni di connettersi finchè non si è sicuri che il recupero abbia avuto successo.
    </para>
   </listitem>
   <listitem>
    <para>
Avviare il server. Il server entrerà in modalità recovery e 
leggerà attraverso i file WAL di cui ha bisogno. Se il recupero dovesse terminare
causa errori esterni, il server può essere riavviato semplicemente  
ed esso continuerà il recupero. Fino al completamento del processo di recupero, 
il server rinominerà <filename>recovery.conf</filename> in <filename>recovery.done</filename> 
(per prevenire l'accidentale rientro in modalità recovery) e quindi 
inizierà le normali operazioni del database.
    </para>
   </listitem>
   <listitem>
    <para>
Ispezionare il contenuto del database per assicurarsi di essere tornati allo stato desiderato. 
Se non è cos', ritornare al passo 1. Se tutto è a posto,
permettere agli utenti di connettersi ripristinando <filename>pg_hba.conf</filename> alla normalità.
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
La parte chiave di tutto questo è l'impostazione di un file di configurazione di recupero 
che descriva come si vuole recuperare e quanto lontano dovrebbe arrivare il recupero.
È possibile usare <filename>recovery.conf.sample</filename> (normalmente 
si trova nella directory <filename>share/</filename> del percorso di installazione) come 
prototipo.  La sola cosa che si deve assolutamente specificare in 
<filename>recovery.conf</filename> è la <varname>restore_command</varname>,
che dice a <productname>PostgreSQL</productname> come recuperare i segmenti WAL archiviati.
Come l'<varname>archive_command</varname>, questa è una stringa di comando shell.
Può contenere  <literal>%f</literal>, che verrà
sostituito dal nome del file di log desiderato, e <literal>%p</literal>,
che verrà sostituito dal percorso in cui copiare il file di log. 
(Il percorso è relativo alla directory di lavoro corrente, 
per es., la directory data del cluster).
Scrivere <literal>%%</literal> se si ha bisogno di includere un carattere <literal>%</literal>
nel comando. Il comando più semplice sarà qualcosa simile a:
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f %p'
</programlisting>
che copierà i segmenti WAL archiviati precedentemente dalla directory 
<filename>/mnt/server/archivedir</filename>. Certamente, è possibile usare qualcosa di
molto più complicato, come uno script shell che richiede che l'operatore
monti un nastro appropriato.
   </para>

   <para>
<warning>
    <para>
        TODO
    </para>
</warning>
    It is important that the command return nonzero exit status on failure.
    The command <emphasis>will</emphasis> be called requesting files that are not present
    in the archive; it must return nonzero when so asked.  This is not an
    error condition.  Not all of the requested files will be WAL segment
    files; you should also expect requests for files with a suffix of
    <literal>.backup</literal> or <literal>.history</literal>. Also be aware that
    the base name of the <literal>%p</literal> path will be different from
    <literal>%f</literal>; do not expect them to be interchangeable.
   </para>

   <para>
I segmenti WAL che non possono essere trovati nell'archivio saranno cercati dentro 
<filename>pg_xlog/</filename>; questo permette l'utilizzo di segmenti non archiviati.
Comunque, saranno usati i segmenti che sono disponibili dall'archivio preferibilmente ai
file in <filename>pg_xlog/</filename>. Il sistema non sovrascriverà i contenuti esistenti di 
<filename>pg_xlog/</filename> quando recupera i file archiviati.
   </para>

   <para>
    Normally, recovery will proceed through all available WAL segments,
Normalmente, il recupero procederà attraverso tutti i segmenti WAL disponibili,
    thereby restoring the database to the current point in time (or as
(o più 
vicino possibile ai segmenti WAL disponibli).  Inoltre, un recupero normale  
finirà finirà con un messaggio <quote>file not found</quote>, il testo esatto 
del messaggio di errore dipende dalla scelta di
<varname>restore_command</varname>. Si potrebbe vedere anche un messaggio di errore
all'avvio di un recupero per un file chiamato in maniera simile a 
<filename>00000001.history</filename>. Anche questo è normale e non indica un 
problema in situazioni di recupero semplici; si veda 
<xref linkend="backup-timelines"/> per discussioni a riguardo.
   </para>

   <para>
Se si vuole tornare a qualche istante nel tempo (tipo, appena prima 
che il DBA junior ha cancellato la tabella di transazione principale), basta specificare
il punto di arresto richiesto in <filename>recovery.conf</filename>. Si può specificare
il punto d'arresto, noto come <quote>recovery target</quote>, sia 
attraverso data/orario sia per completamento di uno specifico ID di transazione. Al momento
della scrittura di questo libro, solo l'opzione data/orario è molto usabile, 
dato che non ci sono strumenti
che aiutino l'identificazione con accuratezza di quale transazione usare.
   </para>

   <note>
     <para>
Il punto di arresto deve essere successivo al momento finale del backup di base, per es.,
il momento finale di <function>pg_stop_backup</function>. Non è possibile usare un backup base
per recuperare un momento in cui il backup era in corso. (Per recuperare
a un momento del genere, si deve tornare indietro al precedente backup di base e 
andare in avanti da quello).

     </para>
   </note>

   <para>
Se il recupero trova dati WAL corrotti, si arresterà a quel momento
e il server non partirà. In quei casi il processo di recupero
può essere lanciato di nuovo dall'inizio, specificando un 
<quote>recovery target</quote>  precedente il punto di corruzione, così che il recupero possa
completarsi normalmente.
Se il recupero fallisce per una ragione esterna, tipo un crash del sistema o
se gli archivi WAL sono diventati inaccessibili, allora il recupero può semplicemente 
essere riavviato e ripartirà circa da dove è fallito.
<warning>
    <para>
        TODO
    </para>
</warning>
    Recovery restart works much like checkpointing in normal operation:
    the server periodically forces all its state to disk, and then updates
    the <filename>pg_control</filename> file to indicate that the already-processed
    WAL data need not be scanned again.
   </para>

  </sect2>

  <sect2 id="backup-timelines">
   <title>Timeline</title>

  <indexterm zone="backup">
   <primary>timeline</primary>
  </indexterm>

   <para>
La capacità di ripristinare il database a un istante passato crea 
delle complessità che sono affini a storie di fantascienza sui viaggi temporali 
e universi paralleli.
Per esempio, nello storico originale del database,
supporre di aver eliminato una tabella critica alle  17:15 di martedì sera, ma 
non non essersi accorti dell'errore fino al mezzogiorno di giovedì. 
Prendere il backup, ripristinare all'istante 17:14 di martedì sera, e ecco qua.
In <emphasis>questo</emphasis> storico del database, non si è mai cancellata la tabella.
Ma supporre che più tardi si sia realizzato che questa non è stata proprio una grande idea,
e che si voglia tornare a qualche istante di giovedì mattina nello storico originale.
Non potremmo farlo se, 
mentre il database era in esecuzione, ha sovrascritto alcuni dei file segmento WAL
che precedevano l'istante al quale si desidera tornare ora.
Così, per evitare ciò, è necessario distinguere le serie di 
record WAL generata dopo che è stato fatto un recupero a un istante nel tempo da 
quelle state generate nello storico originale del database.
   </para>

   <para>
Per gestire questo problema, <productname>PostgreSQL</productname> ha la nozione di 
<firstterm>timelines</firstterm>.   Ogni volta che un recupero è completo,
una nuova timeline viene creata per identificare la serie di record WAL
generati dopo quel recupero. L'ID della timeline
è parte dei nome dei file segmento WAL, così una che nuova timeline non   
sovrascriva i dati WAL generati da timeline precedenti. Infatti è possibile
archiviare molte timeline differenti. Mentre questa potrebbe sembrare una caratteristica
inutile, spesso salva la vita. Considerare la 
situazione in cui non si è abbastanza sicuri a quale istante recuperare,
e così dover fare diversi recuperi per tentativi finchè non si trova il migliore. 
Senza le timeline questa operazione genererà presto confusione. Con le timeline,
è possibile recuperare da <emphasis>qualsiasi</emphasis> stato precedente, inclusi
stati in ramificazioni di timeline abbandonate precedentemente.
   </para>

   <para>
Ogni volta che una nuova timeline viene creata, <productname>PostgreSQL</productname> crea
uno file <quote>timeline history</quote> che mostra da quale timeline è stata generata 
e quando. Questi file storico sono necessari per permettere al sistema
di pescare i giusti file segmento WAL quando si recupera da un archivio che contiene  
molteplici timeline. Quindi, sono archiviati all'interno dell'area di archivio WAL 
semplicemente cole file segmento WAL. I file storico sono semplicemente
piccoli file di testo, così è economico e giusto tenerne traccia 
indefinitamente (a differenza dei file segmento che sono grandi). È possibile, 
se si vuole, aggiungere commenti a un file storico per registrare le proprie note 
sul come e perchè quella particolare timeline è stata creata. Questi commenti saranno  
utili specialmente quando si ha un folto gruppo di timeline come risultato di 
sperimentazioni.
   </para>

   <para>
Il comportamento predefinito è do recuperare lungo la stella timeline 
che era la corrente quando il backup di base è stato fatto. Se si desidera recuperare
all'interno di timeline figlie (cioè, si vuole restituire qualche stato che
è stato generato dopo un tentativo di recupero), bisogna specificare l'ID della timeline 
"bersaglio" in <filename>recovery.conf</filename>. Non è possibile recuperare all'interno di timeline
che ramificate precedentemente rispetto al backup di base.
   </para>
  </sect2>

  <sect2 id="backup-tips">
   <title>Suggerimenti e esempi</title>

   <para>
Proponiamo qui alcuni suggerimenti per configurare l'archiviazione continua. 
   </para>

    <sect3 id="backup-standalone">
     <title>Hot backup a sè stanti</title>

     <para>
È possibile usare le funzionalità di backup <productname>PostgreSQL</productname> per produrre  
hot backup a sè stanti. Questi sono backup che non possono essere usati  
per recuperi di istanti nel tempo, sono tipicamente molto più veloci a svolgere backup e ripristino
rispetto ai dump fatti con <application>pg_dump</application>. (Sono anche molto più grandi
dei dump <application>pg_dump</application>, per questo in alcuni casi il vantaggio di velocità 
potrebbe essere vanificato).
     </para>

     <para>
Per prepararsi a hot backup a sè stanti, impostare <varname>wal_level</varname> a
<literal>archive</literal> (o <literal>hot_standby</literal>), <varname>archive_mode</varname> a
<literal>on</literal>, e impostare un <varname>archive_command</varname> che esegue 
l'archiviazione solo quando un <emphasis>file seitch</emphasis> esiste. Per esempio:
<programlisting>
archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || cp -i %p /var/lib/pgsql/archive/%f &lt; /dev/null'
</programlisting>
Questo comando compierà l'archiviazione quando 
<filename>/var/lib/pgsql/backup_in_progress</filename> esiste, altrimenti
silenziosamente restituirà lo stato di uscita zero (permettendo a <productname>PostgreSQL</productname>
di riciclare i file WAL non voluti).
     </para>

     <para>
Con questa preparazione, un backup può essere effettuato usando uno script simile 
al seguente:
<programlisting>
touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
</programlisting>
Il file switch <filename>/var/lib/pgsql/backup_in_progress</filename> viene 
creato prima, abilitando l'archiviazione di file WAL completi. 
Dopo che il backup è terminato il file switch viene rimosso. I file WAL archiviati sono
quindi aggiunti al backup così che sia il backup di base che tutti i file WAL richiesti
siano parte della stesso file <application>tar</application>.
Per favore, ricordare di aggiungere la gestione degli errori agli script di backup.
     </para>

     <para>
Se la dimensione dell'archivio è proccupante, usare <application>pg_compresslog</application>,
<ulink url="http://pglesslog.projects.postgresql.org"></ulink>, per 
rimuovere <xref linkend="guc-full-page-writes"/> non necessarie e spazio in coda
dai file WAL. Si può poi usare 
<application>gzip</application> per comprimere ulteriormente l'output di
<application>pg_compresslog</application>:
<programlisting>
archive_command = 'pg_compresslog %p - | gzip &gt; /var/lib/pgsql/archive/%f'
</programlisting>
Si avrà poi la necessità di usare <application>gunzip</application> e
<application>pg_decompresslog</application> durante il recupero:
<programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f | pg_decompresslog - %p'
</programlisting>
     </para>
    </sect3>

    <sect3 id="backup-scripts">
     <title><varname>archive_command</varname> scripts</title>

     <para>
Molte persone scelgono di usare script per definire i loro 
<varname>archive_command</varname>, così che le loro voci
<filename>postgresql.conf</filename> appariranno molto semplici:
<programlisting>
archive_command = 'local_backup_script.sh'
</programlisting>
Usare uno script separato è consigliabile ogni volta che si vuole usare 
più di un singolo comando nel processo di archiviazione.
Questo permette la gestione di tutta la complessità all'interno dello script, che
può essere scritto in linguaggi di scripting popolari tipo
<application>bash</application> o <application>perl</application>.
Qualsiasi messaggio scritto su <literal>stderr</literal> dallo script apparirà
nel log del server database, permettendo che configurazioni complesse siano
diagnosticate facilmente se falliscono.
     </para>

     <para>
Esempi di esigenze che potrebbero essere risolti all'interno di uno script includono:
      <itemizedlist>
       <listitem>
        <para>
Copiare dati verso luoghi di immagazzinamento sicuro non in loco
        </para>
       </listitem>
       <listitem>
        <para>
Raggruppare file WAL così che siano trasferiti ogni tre ore, 
invece che uno alla volta
        </para>
       </listitem>
       <listitem>
        <para>
Interfacciarsi con altri software di backup e ripristino
        </para>
       </listitem>
       <listitem>
        <para>
Interfacciarsi con software di monitoraggio per segnalare errori
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect3>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
   <title>Avvertimenti</title>

   <para>
Al momento di questa scrittua, ci sono diverse limitazioni alla tecnica di archiviazione
continua. Queste probabilmente saranno risolte in versioni future:

  <itemizedlist>
   <listitem>
    <para>
Operazioni su indici hash attualmente non sono sottoposte a log WAL, per questo motivo il
replay non aggiornerà questi indici. Questo significherà che ogni nuovo inserimento 
sarà ignorato dall'indice, le righe aggiornate apparentemente scompariranno e
le righe cancellate manterranno comunque puntatori. In altre parole, se si modifica una
tabella che ha un indice hash allora si otterranno risultati di query incorretti
su un server standby. Quando il ripristino è completato si raccomanda di 
<xref linkend="sql-reindex"/> manualmente ogni indice dopo il completamento 
di un'operazione di ripristino.
    </para>
   </listitem>

   <listitem>
    <para>
Se un comando <xref linkend="sql-createdatabase"/>
viene eseguito mentre sta avendo luogo un backup di base, e quindi 
il database template copiato da <command>CREATE DATABASE</command> viene modificato
mentre il backup di base è in esecuzione, è possibile
che il ripristino faccia si che queste modifiche siano propagate
anche all'interno del database creato. Questo comportamento ovviamente è indesiderabile.
Per evitare questo rischio, è meglio non modificare nessun database template
mentre un backup di base è in esecuzione.
    </para>
   </listitem>

   <listitem>
    <para>
I comandi <xref linkend="sql-createtablespace"/>
sono sottoposti a log WAL con il percorso assoluto, e saranno inoltre
sottoposti a replay come creazioni di tablespace con lo stesso percorso 
assoluto. Questo potrebbe essere indesiderabile se il log è stato sottoposto a 
replay su una macchina diversa. Può essere pericoloso anche se 
il log viene sottoposto a replay sulla stessa macchina, ma all'interno di una 
nuova directory dati: il replay sovrascriverà comunque il contenuto del tablespace
originale. Per evitare potenziali incomprensioni, 
la buona pratica è di realizzare un nuovo backup di base dopo aver creato o 
eliminato dei tablespace.
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <para>
Si dovrebbe notare inoltre che il formato <acronym>WAL</acronym>
predefinito è abbastanza enorme dato che include molte snapshot di pagina del disco.
Queste snapshot di pagina sono progettate per sostenere il ripristino dai crash, dato che
si potrebbe aver bisogno di mettere a posto pagine disco scritte parzialmente. 
In dipendenza del proprio hardware e software di sistema, il rischio di scritture parziali
potrebbe essere abbastanza piccolo da ignorare, nel qual caso è possibile 
ridurre significativamente il volume totale dei log archiviati disabilitando 
le snapshot di pagina usando il parametro <xref linkend="guc-full-page-writes"/>.
(Leggere le note e i warning in <xref linkend="wal"/> prima di farlo).
Disabilitare le snapshot non previene l'uso dei log per operazioni PITR. 
Un area per sviluppo futuro è di comprimere dati WAL archiviati rimuovendo
copie di pagine non necessarie anche quando <varname>full_page_writes</varname> è
attivo. Nel frattempo, gli amministratori potrebbero desiderare ridurre il numero
di snapshot di pagina incluse nel WAL incrementando i parametri d'intervallo di checkpoint 
tanto quanto tanto quanto fattibile.
   </para>
  </sect2>
 </sect1>

 <sect1 id="migration">
  <title>Migrazioni fra versioni</title>

  <indexterm zone="migration">
   <primary>aggiornamento</primary>
  </indexterm>

  <indexterm zone="migration">
   <primary>versione</primary>
   <secondary>compatibilità</secondary>
  </indexterm>

  <para>
Questa sezione discute come migrare i dati di un database da una versione di 
<productname>PostgreSQL</productname> a una nuova.
La procedura di installazione di per se non è oggetto di questa sezione; si vedano dettagli  
in <xref linkend="installation"/>.
  </para>

  <para>
Le principali versioni di <productname>PostgreSQL</productname> sono rappresentate dai
gruppi di prime due cifre del numero di versione, per es., 8.4. 
Versioni minori di <productname>PostgreSQL</productname> sono rappresentate dal terzo gruppo
di cifre di versione, per es.  8.4.2 è il sendo rilascio minore 
della 8.4. Rilasci minori non cambiano mai il formato di immagazzinamento interno
e sono sempre compatibili con versioni minori successive e precedenti della stessa versione
principale, per es. 8.4.2 è compatibile con 8.4, 8.4.1 e 8.4.6. Per aggiornare 
a versioni compatibili, basta semplicemente sostituire gli eseguibili mentre il server
è fermo e riavviare il server. La directory dei dati rimane immutata -
aggiornamenti minori sono così semplici.
  </para>

  <para>
Per rilasci <emphasis>principali</emphasis> di <productname>PostgreSQL</productname>, 
il formato interno per l'immagazzinamento dei dati è soggetto a cambiamenti, così come
gli aggiornamenti. Il metodo tradizionale per spostare dati verso una nuova versione 
principale è di fare un dump e ricaricare il database. Altrimenti, sono disponibili 
altre possibilità testate meno bene, come discusso sotto.
  </para>

  <para>
Nuove versioni principali tipicamente introducono incompatibilità visibili all'utente,
così da richiedere cambiamenti all'applicazione.
Utenti cauti vorranno testare le loro applicazioni client sulla nuova versione
prima di migrare totalmente; per questo, spesso è una buona idea mettere su
installazioni concorrenti di versioni vecchie e nuove. Quando si testa un aggiornamento 
principale di <productname>PostgreSQL</productname>, considerare le seguenti categorie
di possibili cambiamenti:
  </para>

  <variablelist>

   <varlistentry>
    <term>Administration</term>
    <listitem>
     <para>
Le funzionalità disponibili agli amministratori per monitorare e controllare 
il server spesso cambiano e migliorano in ogni release principale. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <para>
Tipicamente questo include nuove capacità di comandi SQL e non cambiano
nel comportamento, a meno che sia specificamente menzionato nelle note di rilascio.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API di libreria</term>
    <listitem>
     <para>
Tipicamente librerie come <application>libpq</application> aggiungono solo nuove 
funzionalità, di nuovo a meno che non siano menzionate nelle note di rilascio.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Cataloghi di sistema</term>
    <listitem>
     <para>
I cambiamenti di catalogo di sistema solitamente hanno effetti solo sugli strumenti di 
gestione del database.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API C lato server</term>
    <listitem>
     <para>
Questo coinvolge cambiamenti nell'API del backend, che è scritto nel linguaggio
di programmazione C. Questi cambiamenti riguardano codice che 
referenziano funzioni di backend profondamente dentro al server.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="migration-methods-pgdump">
   <title>Migrazione dei dati via <application>pg_dump</application></title>

  <para>
Per fare il dump di dati da una versione principale di <productname>PostgreSQL</productname>
e caricarla in un'altra, si deve usare <application>pg_dump</application>; metodi di backup
a livello di file system non funzioneranno. (Ci sono controlli in loco che prevengono
l'usi di una directory dati con una versione di <productname>PostgreSQL</productname>
incompatibile, così non possono essere fatti grossi danni provando ad avviare 
la versione sbagliata del server su una directory dati).
  </para>

  <para>
Si raccomanda di usare i programmi <application>pg_dump</application> e 
<application>pg_dumpall</application> dalle nuove versioni di 
<productname>PostgreSQL</productname>, per sfruttare i miglioramenti che potrebbero 
essere stati fatti in questi programmi. Le versioni correnti dei programmi di dump 
possono leggere dati da qualsiasi versione del server indietro fino alla 7.0.
  </para>

  <para>
L'ultimo momento di guasto può essere ottenuto installando il nuovo server in una
directory diversa e avviando sia il vecchio server che il nuovo 
in parallelo, su porte differenti. Quindi è possibile usare qualcosa simile a:

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 6543
</programlisting>

per trasferire i dati. O si può usare un file intermedio se si desidera.
Quindi si può spengere il vecchio server e avviare il nuovo usando
la porta su cui stava viaggiando il vecchio. Si dovrebbe far sì che il vecchio database
non sia aggiornato dopo che si è lanciato <application>pg_dumpall</application>,
altrimenti si perderanno quegli aggiornamenti. Si veda <xref linkend="client-authentication"/>
per informazioni su come proibire l'accesso.
  </para>

  <para>
Se non si può o non si vuole eseguire due server in parallelo, si può
fare il backup prima di installare la nuova versione, mandare giù il vecchio server, 
togliere di mezzo la vecchia versione, installare la nuova versione, 
avviare il nuovo server, e rispristinare i dati. Per esempio:

<programlisting>
pg_dumpall &gt; backup
pg_ctl stop
mv /usr/local/pgsql /usr/local/pgsql.old
# Rename any tablespace directories as well
cd ~/postgresql-&version;
gmake install
initdb -D /usr/local/pgsql/data
postgres -D /usr/local/pgsql/data
psql -f backup postgres
</programlisting>

Si veda <xref linkend="runtime"/> sui modi di avviare e fermare il server e altri dettagli.
Le istruzioni di installazione ti consiglieranno posti strategici per effettuare 
questi passi.
  </para>

  <note>
   <para>
Quando si <quote>toglie di mezzo il vecchio database</quote>
potrebbe non essere più perfettamente usabile. Alcuni dei programmi eseguibili 
contengono percorsi assoluti a vari programmi e file di dati.
Questo usualmente non è un grande problema, ma se si pianifica di usare due 
installazioni in parallelo per un po' si dovrebbe assegnarle 
differenti directory d'installazione al tempo della compilazione. (Questo problema
viene rettificato in <productname>PostgreSQL</productname> versione 8.0 e successive, finchè
si muovono tutte le sottodirectory contenenti file installati insieme;
per esempio se  <filename>/usr/local/postgres/bin/</filename> va in 
<filename>/usr/local/postgres.old/bin/</filename>, allora 
<filename>/usr/local/postgres/share/</filename> deve andare in 
<filename>/usr/local/postgres.old/share/</filename>. In versioni precedenti la 8.0
muovere un'installazione in questo modo non funzionerà).
   </para>
  </note>
  </sect2>

  <sect2 id="migration-methods-other">
   <title>Altri metodi per la migrazione di dati</title>

  <para>
Il programma <filename>contrib</filename>
<link linkend="pgupgrade"><application>pg_upgrade</application></link>
permette che un'installazione sia migrata in loco da una versione principale di
<productname>PostgreSQL</productname> alla prossima. Tenere a mente che questo
metono non fornisce nessuna opportunità di eseguire vecchie e nuove versioni
concorrentemente. Inoltre, <application>pg_upgrade</application> è molto meno 
testato di <application>pg_dump</application>, così avere un backup aggiornato è fortemente
raccomandato in caso che qualcosa vada storto.
  </para>

  <para>
È possibile anche usare metodi di replicazione sicuri, tipo 
<productname>Slony</productname>, per creare un server di standby con la versione aggiornata
di <productname>PostgreSQL</productname>. Lo standby può essere sullo stesso computer o 
su un computer differente. Una volta che è sincronizzato con il server master
(che esegue la versione vecchia di <productname>PostgreSQL</productname>), è possibile
cambiare il master e rendere lo standy il master e spengere l'istanza database più vecchia.
Questo cambiamento provoca solo pochi secondi di arresto per un aggiornamento.
  </para>

  </sect2>
 </sect1>
</chapter>

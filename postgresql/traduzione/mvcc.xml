<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

 <chapter id="mvcc">
  <title>Controllo concorrente</title>

  <indexterm>
   <primary>concorrenza</primary>
  </indexterm>

  <para>
Questo capitolo descrive il comportamento del sistema di database
<productname>PostgreSQL</productname> quando due o più
sessioni provano ad accedere agli stessi dati contemporaneamente. Gli obiettivi
in questa situazione sono di permettere un accesso efficiente per tutte le sessioni
mentre si mantiene una severa integrità dei dati. Ogni sviluppatore
di applicazioni database dovrebbe essere familiare con gli argomenti trattati
in questo capitolo.
  </para>

  <sect1 id="mvcc-intro">
   <title>Introduzione</title>

   <indexterm>
    <primary>MVCC</primary>
   </indexterm>

   <para>
<productname>PostgreSQL</productname> fornisce agli sviluppatori un ricco insieme di strumenti
per gestire l'accesso concorrente ai dati. Internamente, 
la consistenza dei dati è mantenuta usando un modello multiversione
(Multiversion Concurrency Control, <acronym>MVCC</acronym>).
Questo significa che mentre una transazione interroga un database, vede
un'istantanea dei dati (una <firstterm>versione del database</firstterm>)
come era poco prima, senza curarsi dello stato attuale dei dati sottostanti.
Questo protegge una transazione dal vedere dati inconsistenti che 
potrebbero essere causati da (altre) transazioni di update concorrenti sulle stesse
righe di dati, fornendo un  <firstterm>isolamento di transazione</firstterm>
per ogni sessione di database. <acronym>MVCC</acronym>, evitando
le metodologie di lock esplicite dei sustemi di database tradizionali,
minimizano i lock in modo da permettere performance elevate in
sistemi multiutente.
   </para>

   <para>
Il vantaggio principale dell'uso del modello di controllo concorrente <acronym>MVCC</acronym> 
piuttosto che i meccanismi di lock è che nell'<acronym>MVCC</acronym>
i lock acquisiti per interrogare dati (lettura), non vanno in conflitto 
con i lock acquisiti per scrivere dati, e così 
la lettura non blocca mai la scrittura e la scrittura non blocca mai la lettura.
   </para>

   <para>
Funzionalità di locking a livello di riga e tabella sono comunque disponibili 
in <productname>PostgreSQL</productname> per applicazioni che non si adattano
facilmente al comportamento <acronym>MVCC</acronym>. Comunque, un uso appropriato
di <acronym>MVCC</acronym> generalmente risulterà in performance migliori 
rispetto ai lock. Inoltre, i lock consultivi prevedono un meccanismo 
per l'acquisizione dei lock che non sono legati
a una singola transazione.
   </para>
  </sect1>

  <sect1 id="transaction-iso">
   <title>Isolamento transazionale</title>

   <indexterm>
    <primary>isolamento transazionale</primary>
   </indexterm>

   <para>
Lo standard <acronym>SQL</acronym> definisce quattro livelli di 
isolamento transazionale in termini di tre fenomeni che devono essere
preventivati tra transazioni concorrenti. Questi fenomeni indesiderati sono:

    <variablelist>
     <varlistentry>
      <term>
       lettura sporca
       <indexterm><primary>lettura sporca</primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione legge i dati scritti da una transazione concorrente che non ha fatto un commit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lettura non ripetibile
       <indexterm><primary>lettura non ripetibile </primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione legge di nuovo dati che ha letto precedentemente e scopre che i 
dati sono stati modificati da un'altra transazione (che ha eseguito un commit dopo la 
lettura iniziale).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lettura fantasma
       <indexterm><primary>lettura fantasma</primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione esegue di nuovo una query che restituisce un insieme di righe che soddisfa
una condizione di ricerca e scopre che l'insieme di righe che soddisfano la condizione 
è cambiata a causa di un'altra transazione che ha eseguito un commit di recente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <indexterm>
     <primary>livello di isolamento transazionale</primary>

    </indexterm>
I quattro livelli di isolamento transazionale e i comportamenti corrispondenti
sono descritti in <xref linkend="mvcc-isolevel-table"/>.
   </para>

    <table tocentry="1" id="mvcc-isolevel-table">
     <title>Livelli di isolamento di transazione <acronym>SQL</acronym></title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>
         Livello di isolamento
        </entry>
        <entry>
         Lettura sporca
        </entry>
        <entry>
         Lettura non ripetibile
        </entry>
        <entry>
         Lettura fantasma
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         Lettura che non ha fatto commit
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Lettura che ha fatto commit
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Lettura ripetibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Serializzabile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
In <productname>PostgreSQL</productname>, è possibile richiedere uno qualsiasi 
dei quattro livelli standard di isolamento di transazione. Ma internalmente, ci sono 
solo due distinti livelli di isolamento, che corrispondono ai livelli Read
Committed e Serializable. Quando si sceglie il livello Read Uncommitted 
in realtà si otterrà Read Committed, e quando si sceglie 
Repeatable Read in realtà si otterrà Serializable, così il livello di isolamento effettivo
potrebbe essere più stretto di quello scelto. Questo è permesso dallo standard SQL:
i quattro livelli di isolamento definiscono solo quali fenomeni 
non devono accadere, non definiscono quali fenomeni devono accadere.
La ragione per la quale <productname>PostgreSQL</productname>
fornisce solo due livelli di isolamento è che questo è l'unico modo sensato
per gestire i livelli di isolamento standard nell'architettura 
di controllo concorrente. Il comportamento dei livelli di isolamento 
è spiegato in dettaglio nelle sottosezioni seguenti.
   </para>

   <para>
Per impostare il livello di isolamento transazionale di una transazione, usare 
il comando <xref linkend="sql-set-transaction"/>.
   </para>

  <sect2 id="xact-read-committed">
   <title>Livello di isolamento  Read Committed </title>

   <indexterm>
    <primary>livello di isolamento transazionale</primary>
    <secondary>read committed</secondary>
   </indexterm>

   <para>
<firstterm>Read Committed</firstterm> è il livello di isolamento predefinito
in <productname>PostgreSQL</productname>. Quando una transazione usa 
questo livello di isolamento, una query <command>SELECT</command> 
(senza clausola <literal>FOR UPDATE/SHARE</literal>) vede solo i dati 
che sono stati sottoposti a commit prima che query iniziasse; essa non vede mai nè 
i dati non sottoposti a commit nè i cambiamenti sottoposti a commit da transazioni  
concorrenti durante l'esecuzione
della query.  In effetti, una query <command>SELECT</command> vede un'istantanea
del database nell'istante in cui è partita.
Ad ogni modo,  <command>SELECT</command> vede gli effetti
di update precedenti eseguite all'interno della propria transazione, 
anche se non sono ancora stati sottoposti a commit. Notare inoltre che due 
comandi <command>SELECT</command> possono vedere dati differenti, anche 
se sono all'interno di una singola transazione, se altre transazioni 
eseguono cambiamenti durante l'esecuzione della prima <command>SELECT</command>.
   </para>

   <para>
I comandi <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
FOR UPDATE</command>, e <command>SELECT FOR SHARE</command> 
si comportano allo stesso modo di <command>SELECT</command>
che sono state sottoposte a commit dopo il momento di inizio del comando. In ogni caso, tale
riga potrebbe essere già stata aggiornata (o cancellata, o sottoposta a lock) da un'altra
    another concurrent transaction by the time it is found.  In this case, the
transazione concorrente nel momento che viene trovata. In questo caso, 
    would-be updater will wait for the first updating transaction to commit or
    roll back (if it is still in progress).  
    If the first updater rolls back,
Se la prima transazione esegue un rollback,
allora i suoi effetti sono negati e la seconda transazione di aggiornamento può procedere 
con l'aggiornamento della riga trovata originariamente. Se la prima transazione esegue un commit, la seconda
ignorerà la riga se la transazioni l'ha cancellata,
altrimenti tenterà di applicare la sua operazione alla versione aggiornata della riga. 
La condizione di ricerca del comando (la clausola <literal>WHERE</literal>) viene 
rivalutata per vedere se la versiona ggiornata della riga corrisponde ancora alla condizione di ricerca.
Se si, la seconda transazione procede con le sue operazioni
usando la versione aggiornata della riga. Nel caso di 
<command>SELECT FOR UPDATE</command> e <command>SELECT FOR
SHARE</command>, questo significa che è la versione aggiornata della riga che
viene sottoposta a lock e restituita al client.
   </para>
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->

   <para>
A causa della regola sopra, è possibile, per un comando di aggiornamento, vedere 
un'istantanea inconsistene: può vedere gli effetti di comandi di aggiornamento
concorrenti sulle stesse righe che sta tentando di aggiornare, ma non vede 
gli effetti di quei comandi sulle altre righe nel database.
Questo comportamento rende la modalità Read Committed inadatta a comandi che 
coinvolgono condizioni di ricerca complesse; in ogni caso, va bene per casi più semplici.
Per esempio, considerare l'aggiornamento di saldi bancari con transazioni tipo:

<screen>
BEgin;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
</screen>

Se due di quelle transazioni provano a cambiare concorrentemente il saldo dell'account 
12345, chiaramente si vorrà che la seconda transazione cominci con la versione 
aggiornata della riga di account. Dato che ogni comando incluisce solamente su una riga 
predetermiata, lasciargli vedere la versione aggiornata della riga non crea 
nessun problema di inconsistenza.
   </para>

   <para>
Un utilizzo più complesso può produrre risultati non desiderati in modalità
Read Committed. Per esempio, considerare un comando <command>DELETE</command>
che opera su dati che sono stati sia aggiunti che rimossi dai suoi 
criteri di restrizione da un altro comando, per es., sia
<literal>website</literal> una tabella  con due righe con
<literal>website.hits</literal> uguale a <literal>9</literal> e
<literal>10</literal>:

<screen>
BEgin;
UPDATE website SET hits = hits + 1;
-- eseguito da un'altra sessione:  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

<command>DELETE</command> non avrà effetti dato che 
c'è una riga <literal>website.hits = 10</literal> prima e dopo 
l'<command>UPDATE</command>. Questo accade perchè 
il valore di riga precedentemente aggiornato <literal>9</literal> viene saltato, e quando
l'<command>UPDATE</command> è completo e <command>DELETE</command>
ottiene un lock, il nuovo valore di riga non è più <literal>10</literal> ma
<literal>11</literal>, che non corrisponde più ai criteri di ricerca.
   </para>

   <para>
Dato che la modalità Read Committed comincia ogni comando con una nuova istantanea
che include tutte le transazioni sottoposte a commit fino a quell'istante,
i comandi successivi nella stessa transazione vedranno gli effetti 
della transazione concorrente sottoposta a commit in ogni caso. Il punto della questione 
è se un <emphasis>singolo</emphasis> comando ha o meno una visione assolutamente consistente del database.
   </para>

   <para>
L'isolamento transazionale parziale fornito dalla modalità Read Committed
è adeguato per molte applicazioni, e questa modalità è veloce e semplice da usare;
comunque, non è sufficiente per tutti i casi. Le applicazioni che 
fanno query e aggiornamenti complessi potrebbero richiedere una visione consistente del database
più rigorosa che quella fornita dalla modalità Read Committed.
   </para>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Livello di isolamento serializzabile</title>

   <indexterm>
    <primary>livello di isolamento transazionale</primary>
    <secondary>serializzabile</secondary>
   </indexterm>

   <para>
Il livello di isolamento <firstterm>Serializable</firstterm> fornisce l'isolamento
transazionale più rigido. Questo livello emula l'esecuzione di transazioni seriali,
come se le transazioni fossero state eseguite una dopo l'altra, in maniera seriale,
invece che concorrentemente. Comunque, applicazioni che usano questo livello devono 
essere preparate a ritentare le transazioni dopo fallimenti della serializzazione.
   </para>

   <para>
Quando una transazione usa il livello serializzabile,
una query <command>SELECT</command> vede i dati sottoposti a commit prima che la transazione sia iniziata;
non vede mai nè dati non sottoposti a commit nè cambiamenti
sottoposti a commit durante l'esecuzione di transazione 
da parte di transazioni concorrenti. (Comunque, 
la query vede gli effetti di aggiornamenti precedenti
eseguiti all'interno della propria transazione, anche se non sono ancora state 
sottoposte a commit). Questo è diverso dal Read Committed nel quale 
una query in una transazione serializzabile 
vede un'istantanea all'inizio della  <emphasis>transazione</emphasis>,
non all'inizio della quey corrente all'interno della transazione. Così,
comandi <command>SELECT</command> successivi all'interno di una <emphasis>singola</emphasis>
transazione vedono gli stessi dati, per es., non vedono cambiamenti fatti 
da altre transazioni che sono stati sottoposti a commit dopo che le proprie transazioni sono partite.
(Questo comportamento può essere ideale per applicazioni di riportistica).
   </para>

   <para>
I comandi <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
FOR UPDATE</command>, e <command>SELECT FOR SHARE</command> 
si comportano come <command>SELECT</command>
in termini di ricerca di righe: trovano solo righe che sono state sottoposte a commit
dal momento di inizio della transazione. Comunque, quella riga
potrebbe essere già stata aggiornata (o cancellata, o sottoposta a lock) da
un'altra transazione concorrente, nel momento in cui è stata trovata. In questo caso,
la transazione serializzabile aspetterà che la prima transazione esegua un commit o un
rool back (se è ancora in corso). Se la prima transazione esegue un rollback, 
allora i suoi effetti sono negati e la transazione serializzabile può procedere
con l'aggiornamento della riga trovata originariamente. Ma se la prima transazione esegue un commit
(ed effettivamente aggiorna o cancella la riga, non esegue semplicemente un lock)
allora la transazione serializzabile sarà sottoposta a rollback con il messaggio

<screen>
ERROR:  could not serialize access due to concurrent update
</screen>

dato che una transazione serializabile non può modificare i eseguire lock su righe 
cambiate da altre transzioni dopo che la transazione serializzabile è iniziata.
   </para>

   <para>
Quando l'applicazione riceve questo messaggio di errore, dovrebbe 
annullare la transazione corrente e riprovare l'intera transazione dall'inizio.
La seconda volta, la transazione vedrà il cambiamento sottoposto a commit precedentemente
come parte della sua visione iniziale del database,
così non c'è conflitto logico nell'usare la nuova versione della riga 
come punto di partenza per la nuova transazione.
   </para>

   <para>
Notare che solo transazioni di aggiornamento potrebbero necessitare di essere riprovate; 
transazioni a sola lettura non avranno mai conflitti di serializzazione.
   </para>

   <para>
La modalità Serializable fornisce una garanzia rigorosa che ogni 
transazione abbia una visione completamente consistente del database. Comunque,
l'applicazione dev'essere preparata a ritentare le transazioni quando aggiornamenti concorrenti
rendono impossibile l'illusione di esecuzione seriale.
Dato che il costo di rifare transazioni complesse può essere significativo,
la modalità Serializable è raccomandata solo quando transazioni di aggiornamento contengono
logiche sufficientemente complesse che potrebbero fornire risposte sbagliate in modalità
Read Committed. Di solito, la modalità Serializable è necessaria quando 
una transazione esegue diversi comandi successivi che devono avere
visioni identiche del database.
   </para>

<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
   <sect3 id="mvcc-serializability">
    <title>Serializable Isolation versus True Serializability</title>

   <indexterm>
    <primary>serializability</primary>
   </indexterm>

   <indexterm>
    <primary>predicate locking</primary>
   </indexterm>

<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
   <para>
Il significato intuitivo (e la definiziona matematica) di 
esecuzione <quote>serializzabile</quote> è che qualsiasi due transazioni che hanno 
effettuato un commit con successo appariranno come se fossero state eseguite in maniera strettamente
seriale, una dopo l'altra - sebbene quale appaia come eseguita prima potrebbe
non  essere prevedibile in anticipo. È importante rendersi conto che vietare  
i comportamenti indesiderati elencati nella <xref linkend="mvcc-isolevel-table"/>
non è sufficiente a garantire una vera serializzazione, e infatti 
la modalità Serializable di <productname>PostgreSQL</productname> <emphasis>non
garantisce l'esecuzione serializzabile in questo senso</emphasis>. Come esempio,
considerare una tabella <structname>mytab</structname>, contenente inizialmente: 
<screen>
 class | value 
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200
</screen>
Supporre che la transazione serializzabile A calcola:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 1;
</screen>
e poi inserisce il risultato (30) come <structfield>valore</structfield> in una 
nuova riga con <structfield>class</structfield><literal> = 2</literal>. Concorrentemente, la transazione
serializzabile B calcola:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 2;
</screen>
e ottiene il risultato 300, che inserisce in una nuova riga con
<structfield>class</structfield><literal> = 1</literal>. Quindi entrambe le transazioni fanno il commit.
Nessuno dei comportamenti indesiderati elencati si è presentato, ma si otterrà
un risultato che non potrebbe essere successo in nessun ordine serialmente. 
Se A è stata eseguita prima di B, B avrebbe calcolato la somma 330, non 300, 
e similmente l'altro ordine sarebbe risultato in una somma diversa di quella calcolata da A.
   </para>

   <para>
Per garantire vera serializzazione matematica, è necessario per un sistema di   
database assicurare il <firstterm>predicate locking</firstterm>, che significa che 
una transazione non può inserire o modificare una riga che potrebbe corrispondere
a una condizione <literal>WHERE</literal> di una query in un'altra transazione
concorrente. Per esempio, una volta che la transazione A ha eseguito la query 
<literal>SELECT ... WHERE class = 1</literal>, un sistema di <firstterm>predicate locking</firstterm>
eviterebbe che la transzione B inserisse qualsiasi nuova riga con class 1 finchè
A ha fatto commit.
     <footnote>
      <para>
Essenzialmente, un sistema di <firstterm>predicate locking</firstterm> previene 
letture fantasma restringendo cosa viene scritto, mentre MVCC le previene restringendo cosa
viene letto.
      </para>
     </footnote>
Tale sistema di locking è complesso da implementare
e estremamente costoso in esecuzione, dato che ogni sessione deve
fare attenzione ai dettagli di ogni query eseguita da ogni transazione concorrente.
E questa grande spesa è per la maggior parte inutile, dato che in pratica
la maggior parte della applicazioni non fanno il tipo di cose che potrebbero generare problemi.
(Certamente l'esempio sopra è abbastanza forzato ed è improbabile che rappresenti 
software reale). Per queste ragioni, 
<productname>PostgreSQL</productname> non implementa il predicate locking.
   </para>

   <para>
In casi dove la possibilità di esecuzione non-serializzabile è realmente
un azzardo, è possibile prevenire i problemi con un uso appropriato di 
lock esplicito. Maggiori dettagli appaiono nelle sezioni seguenti.
   </para>
  </sect3>
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
   <title>Lock esplicito</title>

   <indexterm>
    <primary>lock</primary>
   </indexterm>

   <para>
<productname>PostgreSQL</productname> fornisce varie modalità di lock
per controllare accessi concorrenti ai dati nelle tabelle. Queste modalità possono
essere usate per fare dei lock controllate dall'applicazione in situazioni dove
<acronym>MVCC</acronym> non fornisce ilcomportamento desiderato. Inoltre, 
la maggior parte dei comandi <productname>PostgreSQL</productname> acquisiscono 
automaticamente lock delle modalità appropriate per assicurare che tabelle 
a cui si fa riferimento non siano cancellate o modificate in modi incompatibili mentre
il comando è in esecuzione. (Per esempio,  <command>TRUNCATE</command> non può essere eseguito  
concorrentemente ad altre operazioni sulla stessa tabella in maniera sicura, e così ottiene
un lock esclusivo sulla tabella per assicurarlo).
   </para>

   <para>
Per esaminare un elenco dei lock attualmente presenti in un server database,
usare la vista di sistema <link linkend="view-pg-locks"><structname>pg_locks</structname></link>.
Per maggiori informazioni sul monitoraggio dello stato del sottosistema di gestione 
dei lock, si veda <xref linkend="monitoring"/>.
   </para>

  <sect2 id="locking-tables">
   <title>Table-Level Locks</title>

   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>

   <para>
L'elenco sottostante mostra le modalità di lock disponibili a i contesti in cui 
sono usati automaticamente da 
<productname>PostgreSQL</productname>.  È anche possibile ottenere uno qualsiasi di questi lock 
esplicitamente col comando <xref linkend="sql-lock"/>.
Ricordare che tutte queste modalità di lock sono lock a livello di tabella, 
anche se il nome contiene la parola <quote>row</quote>; i nomi
delle modalità di lock sono storici.
In qualche modo i nomi rispecchiano l'utilizzo tipico di ogni modalità di lock -
ma la semantica è sempre la stessa. L'unica vera differenza 
tra una modalità di lock e un'altra è l'insieme di modalità di lock con le quali 
ognuna va in conflitto (si veda <xref linkend="table-lock-compatibility"/>).
Due transazioni non possono ottenere lock di modalità che vanno in conflitto
sulla stessa tabella nello stesso momento. (Comunque, una transazione non va mai in conflitto 
con sè stessa. Per esempio, potrebbe ottenere
un lock <literal>ACCESS EXCLUSIVE</literal> e più tardi un lock 
<literal>ACCESS SHARE</literal> sulla stessa tabella). Modalità di lock che non vanno 
in conflitto possono essere trattenute concorrentemente da molte transazioni. Notare  
in particolare che alcune modalità di lock vanno in conflitto con sè stesse (per esempio,  
un lock <literal>ACCESS EXCLUSIVE</literal> non può essere trattenuto da più di una transazione alla volta)
mentre gli altri non vanno in conflitto con sè stessi (per esempio, 
un lock <literal>ACCESS SHARE</literal> può essere trattenuto da molteplici transazioni).
   </para>

     <variablelist>
      <title>Modalità di lock a livello di tabella</title>
      <varlistentry>
       <term>
        <literal>ACCESS SHARE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto solamente con la modalità di lock <literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
Il comando <command>SELECT</command> acquisisce un lock di questo tipo sulle tabelle    
referenziate. In generale, qualsiasi query che <emphasis>legge</emphasis> una tabella
e non la modifica acquisirà questo tipo di lock.    
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ROW SHARE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità di lock <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
I comandi <command>SELECT FOR UPDATE</command> e <command>SELECT FOR SHARE</command>
acquisiscono un lock di questo tipo sulla tabella/e richieste (in aggiunta a 
dei lock <literal>ACCESS SHARE</literal> su qualsiasi altra tabella 
che è referenziata ma non selezionata <option>FOR UPDATE/FOR SHARE</option>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ROW EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
VA in conflitto con le modalità <literal>SHARE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
I comandi <command>UPDATE</command>,
<command>DELETE</command>, e <command>INSERT</command>
acquisiscono questa modalità di lock sulla tabella desiderata (in aggiunta a 
dei lock <literal>ACCESS SHARE</literal> su qualsiasi altra tabella referenziata).
In generale, questa modalità di lock sarà acquisita da qualsiasi comando 
che <emphasis>modifica i dati</emphasis> in una tabella.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE UPDATE EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
VA in conflitto con le modalità di lock <literal>SHARE UPDATE EXCLUSIVE</literal>,
<literal>SHARE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e 
<literal>ACCESS EXCLUSIVE</literal>.
Questa modalità protegge una tabella rispetto 
a cambiamenti di schema concorrenti e al <command>VACUUM</command>.
        </para>

        <para>
Acquisito da <command>VACUUM</command> (senza <option>FULL</option>),
<command>ANALYZE</command> e <command>CREATE INDEX CONCURRENTLY</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità <literal>ROW EXCLUSIVE</literal>,
<literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
Questa modalità protegge una tabella rispetto a cambiamenti di dato concorrente.
        </para>

        <para>
Acquisito da <command>CREATE INDEX</command>
(senza <option>CONCURRENTLY</option>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE ROW EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità <literal>ROW EXCLUSIVE</literal>,
<literal>SHARE UPDATE EXCLUSIVE</literal>,
<literal>SHARE</literal>, <literal>SHARE ROW
EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
        </para>

        <para>
Acquisito da <command>CREATE TRIGGER</command>,
<command>CREATE RULE</command> (ad eccezione di regole <literal>ON SELECT</literal>)
ed in alcuni casi <command>ALTER TABLE</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con le modalità <literal>ROW SHARE</literal>, <literal>ROW
EXCLUSIVE</literal>, <literal>SHARE UPDATE
EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>.
Questa modalità permette solo lock  <literal>ACCESS SHARE</literal> concorrenti,
per es., con una transazione che possiede questo tipo di lock  
possono procedere in parallelo solo le letture dalla tabella.
        </para>

        <para>
Questa modalità di lock non viene acquisita automaticamente su tabelle utente da
nessun comando <productname>PostgreSQL</productname>. Comunque viene acquisita
su certi cataloghi di sistema in alcune operazioni.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ACCESS EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
Va in conflitto con lock di tutti i tipi (<literal>ACCESS
SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
EXCLUSIVE</literal>, <literal>SHARE UPDATE
EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> e
<literal>ACCESS EXCLUSIVE</literal>).
Questa modalità garantisce che chi possiede il lock 
sia l'unica transazione che ha accesso alla tabella in qualsiasi modo.
        </para>

        <para>
         Acquired by the <command>DROP TABLE</command>,
Acquisito dai comandi <command>DROP TABLE</command>,
<command>TRUNCATE</command>, <command>REINDEX</command>,
<command>CLUSTER</command> e <command>VACUUM FULL</command>, 
così come la maggior parte delle varianti di <command>ALTER TABLE</command>.
Questa, inoltre, è la moda predefinita per le istruzioni <command>LOCK TABLE</command>
che non specificano una modalità esplicitamente.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
      <para>
Solamente un lock <literal>ACCESS EXCLUSIVE</literal> blocca un'istruzione 
<command>SELECT</command> (senza <option>FOR UPDATE/SHARE</option>)
      </para>
     </tip>

    <para>
        <note>
            TODO
        </note>
    </para>
   <para>
    Once acquired, a lock is normally held till end of transaction.  But if a
    lock is acquired after establishing a savepoint, the lock is released
    immediately if the savepoint is rolled back to.  This is consistent with
    the principle that <command>ROLLBACK</command> cancels all effects of the
    commands since the savepoint.  The same holds for locks acquired within a
    <application>PL/pgSQL</application> exception block: an error escape from the block
    releases locks acquired within it.
   </para>



    <table tocentry="1" id="table-lock-compatibility">
     <titlei>Modalità di lock che vanno in conflitto</title>
     <tgroup cols="9">
      <colspec colnum="2" colname="lockst"/>
      <colspec colnum="9" colname="lockend"/>
      <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
      <thead>
       <row>
        <entry morerows="1">Modalità di lock richiesta</entry>
        <entry spanname="lockreq">Modalità di lock corrente</entry>
       </row>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry>ROW SHARE</entry>
        <entry>ROW EXCLUSIVE</entry>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry>SHARE</entry>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry>EXCLUSIVE</entry>
        <entry>ACCESS EXCLUSIVE</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ACCESS EXCLUSIVE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-rows">
    <title>Lock a livello di riga</title>

    <para>
In aggiunta ai lock a livello di tabella, ci sono lock a livello di riga, che 
possono essere lock esclusivi o condivisi. Un lock esclusivo 
su una specifica riga viene automaticamente acquisito quando la riga viene aggiornata
o cancellata. Il lock è conservato fino a che la transazione fa un commit o un rollback, 
esattamente come lock a livello di tabella. Lock a livello di riga 
non hanno effetto sull'interrogazione dei dati; bloccano solo <emphasis>scritture sulla stessa riga</emphasis>.
    </para>

    <para>
Per ottenere un lock di riga esclusivo su una riga senza modificare effettivamente la riga,
selezionare la riga con <command>SELECT FOR
UPDATE</command>.  Notare che una volta che il lock di riga viene acquisito,  
la transazione può aggiornare la riga molte volte senza
paura di conflitti.
    </para>

    <para>
Per acquisire un lock di riga condiviso, selezionare la riga con  
<command>SELECT FOR SHARE</command>. Un lock condiviso non previene il fatto
che altre transazioni possano acquisire lo stesso lock condiviso. Comunque,
nessuna dtransazione ha il permesso di aggiornare, cancellare, o ottenere un lock esclusivo su una
riga sulla quale qualsiasi altra transazione mantiene un lock condiviso. Qualsiasi tentativo
di farlo si bloccherà finchè il lock non viene rilasciato.
    </para>

    <para>
<productname>PostgreSQL</productname> non ricorda nessuna informazione
sulle righe modificate in memoria, così non c'è un limite per il numero 
di righe con lock contemporanee. Comunque, fare il lock di una riga 
potrebbe causare una scrittura su disco, per es., <command>SELECT FOR
UPDATE</command> modifica le righe selezionate per contrassegnarle come sottoposte a lock, 
e quindi risulterà in scritture su disco.
    </para>

    <para>
In aggiunta a lock di tabella e riga, vengono usati locki condivisi/esclusivi a livello di pagina
per controllare gli accessi in lettura/scrittura alle pagine della tabella nel buffer condiviso.
Questi lock sono rilasciati immediatamente dopo che una riga viene "fetched" o 
aggiornata. Gli sviluppatori di applicazioni normalmente non devono preoccuparsi dei lock 
di pagina, ma sono menzionati qui per completezza.
    </para>

   </sect2>

   <sect2 id="locking-deadlocks">
    <title>Deadlock</title>

    <indexterm zone="locking-deadlocks">
     <primary>deadlock</primary>
    </indexterm>

    <para>
L'uso di lock espliciti può incrementare la probabilità di  
<firstterm>deadlock</firstterm>, in cui due (o più) transazioni 
mantengono entrambe lock che gli altri vogliono. Per esempio, se la transazione 1
acquisisce un lock esclusivo sulla tabella A e quindi prova ad acquisire 
un lock esclusivo sulla tabella B, mentre la transazione 2 ha già
eseguito un lock esclusivo sulla tabella B e adesso vuole un lock esclusivo sulla
tabella A, allora nessuna delle due può procedere.
<productname>PostgreSQL</productname> riconosce automaticamente 
situazioni di deadlock e le risolve annullando una delle transazioni coinvolte,
permettendo all'altra/e di completarsi.
(È difficile predirre esattamente quale transazione sarà annullata
e quindi non si dovrebbe farci affidamento).
    </para>

    <para>
Notare che i deadlock possono avvenire anche come risultato di lock di riga
(e così, possono accadere anche se non viene usato un lock esplicito).
Considerare il caso in cui due transazioni concorrenti 
modificano una tabella. La prima transazione esegue:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</screen>

Questo acquisisce un lock di riga sulla riga con il numero di account specificato.
Quindi, la seconda transazione esegue:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</screen>

La prima istruzione <command>UPDATE</command> ottiene con successo
un lock di riga sulla riga specificata, e così riesce ad aggiornare con successo quella riga.
Comunque, la seconda istruzione <command>UPDATE</command>
scopre che la riga che sta tentando di aggiornare è già stata sottoposta a lock, 
e quindi aspetta che la transazione che aveva acquisito il lock sia completa.
La transazione due aspetta quindi che la transazione uno dia completata prima di 
continuare l'esecuzione. Ora, la transazione uno esegue:

<screen>
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</screen>

La transazione uno tenta di ottenere un lock di riga sulla riga specificata,
ma non può: la transazione due possiede già quel lock.
Così aspetta che la transazione due sia completa. Così,
la transazione uno è bloccata sulla transazione due, e la transazione due
è bloccata sulla transazione uno: una condizione di deadlock.
<productname>PostgreSQL</productname> si accorge di questa situazione 
e annulla una delle transazioni.
    </para>

    <para>
     The best defense against deadlocks is generally to avoid them by
     being certain that all applications using a database acquire
     locks on multiple objects in a consistent order. In the example
     above, if both transactions
     had updated the rows in the same order, no deadlock would have
     occurred. One should also ensure that the first lock acquired on
     an object in a transaction is the most restrictive mode that will be
     needed for that object.  If it is not feasible to verify this in
     advance, then deadlocks can be handled on-the-fly by retrying
     transactions that abort due to deadlocks.
    </para>

    <para>
     So long as no deadlock situation is detected, a transaction seeking
     either a table-level or row-level lock will wait indefinitely for
     conflicting locks to be released.  This means it is a bad idea for
     applications to hold transactions open for long periods of time
     (e.g., while waiting for user input).
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Advisory Locks</title>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> provides a means for
     creating locks that have application-defined meanings.  These are
     called <firstterm>advisory locks</firstterm>, because the system does not
     enforce their use &mdash; it is up to the application to use them
     correctly.  Advisory locks can be useful for locking strategies
     that are an awkward fit for the MVCC model.  Once acquired, an
     advisory lock is held until explicitly released or the session ends.
     Unlike standard locks, advisory locks do not
     honor transaction semantics: a lock acquired during a
     transaction that is later rolled back will still be held following the
     rollback, and likewise an unlock is effective even if the calling
     transaction fails later.  The same lock can be acquired multiple times by
     its owning process: for each lock request there must be a corresponding
     unlock request before the lock is actually released.  (If a session
     already holds a given lock, additional requests will always succeed, even
     if other sessions are awaiting the lock.)  Like all locks in
     <productname>PostgreSQL</productname>, a complete list of advisory
     locks currently held by any session can be found in the
     <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
     system view.
    </para>

    <para>
     Advisory locks are allocated out of a shared memory pool whose size
     is defined by the configuration variables
     <xref linkend="guc-max-locks-per-transaction"/> and
     <xref linkend="guc-max-connections"/>.
     Care must be taken not to exhaust this
     memory or the server will be unable to grant any locks at all.
     This imposes an upper limit on the number of advisory locks
     grantable by the server, typically in the tens to hundreds of thousands
     depending on how the server is configured.
    </para>

    <para>
     A common use of advisory locks is to emulate pessimistic locking
     strategies typical of so called <quote>flat file</quote> data management
     systems.
     While a flag stored in a table could be used for the same purpose,
     advisory locks are faster, avoid MVCC bloat, and are automatically
     cleaned up by the server at the end of the session.
     In certain cases using this advisory locking method, especially in queries
     involving explicit ordering and <literal>LIMIT</literal> clauses, care must be
     taken to control the locks acquired because of the order in which SQL
     expressions are evaluated.  For example:
<screen>
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</screen>
     In the above queries, the second form is dangerous because the
     <literal>LIMIT</literal> is not guaranteed to be applied before the locking
     function is executed.  This might cause some locks to be acquired
     that the application was not expecting, and hence would fail to release
     (until it ends the session).
     From the point of view of the application, such locks
     would be dangling, although still viewable in
     <structname>pg_locks</structname>.
    </para>

    <para>
     The functions provided to manipulate advisory locks are described in
     <xref linkend="functions-advisory-locks"/>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
   <title>Data Consistency Checks at the Application Level</title>

   <para>
    Because readers in <productname>PostgreSQL</productname>
    do not lock data, regardless of
    transaction isolation level, data read by one transaction can be
    overwritten by another concurrent transaction. In other words,
    if a row is returned by <command>SELECT</command> it doesn't mean that
    the row is still current at the instant it is returned (i.e., sometime
    after the current query began).  The row might have been modified or
    deleted by an already-committed transaction that committed after
    the <command>SELECT</command> started.
    Even if the row is still valid <quote>now</quote>, it could be changed or
    deleted
    before the current transaction does a commit or rollback.
   </para>

   <para>
    Another way to think about it is that each
    transaction sees a snapshot of the database contents, and concurrently
    executing transactions might very well see different snapshots.  So the
    whole concept of <quote>now</quote> is somewhat ill-defined anyway.
    This is not normally
    a big problem if the client applications are isolated from each other,
    but if the clients can communicate via channels outside the database
    then serious confusion might ensue.
   </para>

   <para>
    To ensure the current validity of a row and protect it against
    concurrent updates one must use <command>SELECT FOR UPDATE</command>,
    <command>SELECT FOR SHARE</command>, or an appropriate <command>LOCK
    TABLE</command> statement.  (<command>SELECT FOR UPDATE</command>
    and <command>SELECT FOR SHARE</command> lock just the
    returned rows against concurrent updates, while <command>LOCK
    TABLE</command> locks the whole table.)  This should be taken into
    account when porting applications to
    <productname>PostgreSQL</productname> from other environments.
   </para>

   <para>
    Global validity checks require extra thought under <acronym>MVCC</acronym>.
    For example, a banking application might wish to check that the sum of
    all credits in one table equals the sum of debits in another table,
    when both tables are being actively updated.  Comparing the results of two
    successive <literal>SELECT sum(...)</literal> commands will not work reliably in
    Read Committed mode, since the second query will likely include the results
    of transactions not counted by the first.  Doing the two sums in a
    single serializable transaction will give an accurate picture of only the
    effects of transactions that committed before the serializable transaction
    started &mdash; but one might legitimately wonder whether the answer is still
    relevant by the time it is delivered.  If the serializable transaction
    itself applied some changes before trying to make the consistency check,
    the usefulness of the check becomes even more debatable, since now it
    includes some but not all post-transaction-start changes.  In such cases
    a careful person might wish to lock all tables needed for the check,
    in order to get an indisputable picture of current reality.  A
    <literal>SHARE</literal> mode (or higher) lock guarantees that there are no
    uncommitted changes in the locked table, other than those of the current
    transaction.
   </para>

   <para>
    Note also that if one is relying on explicit locking to prevent concurrent
    changes, one should either use Read Committed mode, or in Serializable
    mode be careful to obtain
    locks before performing queries.  A lock obtained by a
    serializable transaction guarantees that no other transactions modifying
    the table are still running, but if the snapshot seen by the
    transaction predates obtaining the lock, it might predate some now-committed
    changes in the table.  A serializable transaction's snapshot is actually
    frozen at the start of its first query or data-modification command
    (<literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or <literal>DELETE</literal>), so
    it is possible to obtain locks explicitly before the snapshot is
    frozen.
   </para>
  </sect1>

  <sect1 id="locking-indexes">
   <title>Locking and Indexes</title>

   <indexterm zone="locking-indexes">
    <primary>index</primary>
    <secondary>locks</secondary>
   </indexterm>

   <para>
    Though <productname>PostgreSQL</productname>
    provides nonblocking read/write access to table
    data, nonblocking read/write access is not currently offered for every
    index access method implemented
    in <productname>PostgreSQL</productname>.
    The various index types are handled as follows:

    <variablelist>
     <varlistentry>
      <term>
       B-tree and <acronym>gist</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted.  These index types provide
        the highest concurrency without deadlock conditions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Hash indexes
      </term>
      <listitem>
       <para>
        Share/exclusive hash-bucket-level locks are used for read/write
        access.  Locks are released after the whole bucket is processed.
        Bucket-level locks provide better concurrency than index-level
        ones, but deadlock is possible since the locks are held longer
        than one index operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <acronym>gin</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted. But note that insertion of a
        gin-indexed value usually produces several index key insertions
        per row, so gin might do substantial work for a single value's
        insertion.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Currently, B-tree indexes offer the best performance for concurrent
    applications; since they also have more features than hash
    indexes, they are the recommended index type for concurrent
    applications that need to index scalar data. When dealing with
    non-scalar data, B-trees are not useful, and gist or gin indexes should
    be used instead.
   </para>
  </sect1>
 </chapter>

<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

 <chapter id="mvcc">
  <title>Controllo concorrente</title>

  <indexterm>
   <primary>concorrenza</primary>
  </indexterm>

  <para>
Questo capitolo descrive il comportamento del sistema di database
<productname>PostgreSQL</productname> quando due o più
sessioni provano ad accedere agli stessi dati contemporaneamente. Gli obiettivi
in questa situazione sono di permettere un accesso efficiente per tutte le sessioni
mentre si mantiene una severa integrità dei dati. Ogni sviluppatore
di applicazioni database dovrebbe essere familiare con gli argomenti trattati
in questo capitolo.
  </para>

  <sect1 id="mvcc-intro">
   <title>Introduzione</title>

   <indexterm>
    <primary>MVCC</primary>
   </indexterm>

   <para>
<productname>PostgreSQL</productname> fornisce agli sviluppatori un ricco insieme di strumenti
per gestire l'accesso concorrente ai dati. Internamente, 
la consistenza dei dati è mantenuta usando un modello multiversione
(Multiversion Concurrency Control, <acronym>MVCC</acronym>).
Questo significa che mentre una transazione interroga un database, vede
un'istantanea dei dati (una <firstterm>versione del database</firstterm>)
come era poco prima, senza curarsi dello stato attuale dei dati sottostanti.
Questo protegge una transazione dal vedere dati inconsistenti che 
potrebbero essere causati da (altre) transazioni di update concorrenti sulle stesse
righe di dati, fornendo un  <firstterm>isolamento di transazione</firstterm>
per ogni sessione di database. <acronym>MVCC</acronym>, evitando
le metodologie di lock esplicite dei sustemi di database tradizionali,
minimizano i lock in modo da permettere performance elevate in
sistemi multiutente.
   </para>

   <para>
Il vantaggio principale dell'uso del modello di controllo concorrente <acronym>MVCC</acronym> 
piuttosto che i meccanismi di lock è che nell'<acronym>MVCC</acronym>
i lock acquisiti per interrogare dati (lettura), non vanno in conflitto 
con i lock acquisiti per scrivere dati, e così 
la lettura non blocca mai la scrittura e la scrittura non blocca mai la lettura.
   </para>

   <para>
Funzionalità di locking a livello di riga e tabella sono comunque disponibili 
in <productname>PostgreSQL</productname> per applicazioni che non si adattano
facilmente al comportamento <acronym>MVCC</acronym>. Comunque, un uso appropriato
di <acronym>MVCC</acronym> generalmente risulterà in performance migliori 
rispetto ai lock. Inoltre, i lock consultivi prevedono un meccanismo 
per l'acquisizione dei lock che non sono legati
a una singola transazione.
   </para>
  </sect1>

  <sect1 id="transaction-iso">
   <title>Isolamento transazionale</title>

   <indexterm>
    <primary>isolamento transazionale</primary>
   </indexterm>

   <para>
Lo standard <acronym>SQL</acronym> definisce quattro livelli di 
isolamento transazionale in termini di tre fenomeni che devono essere
preventivati tra transazioni concorrenti. Questi fenomeni indesiderati sono:

    <variablelist>
     <varlistentry>
      <term>
       lettura sporca
       <indexterm><primary>lettura sporca</primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione legge i dati scritti da una transazione concorrente che non ha fatto un commit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lettura non ripetibile
       <indexterm><primary>lettura non ripetibile </primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione legge di nuovo dati che ha letto precedentemente e scopre che i 
dati sono stati modificati da un'altra transazione (che ha eseguito un commit dopo la 
lettura iniziale).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lettura fantasma
       <indexterm><primary>lettura fantasma</primary></indexterm>
      </term>
     <listitem>
      <para>
Una transazione esegue di nuovo una query che restituisce un insieme di righe che soddisfa
una condizione di ricerca e scopre che l'insieme di righe che soddisfano la condizione 
è cambiata a causa di un'altra transazione che ha eseguito un commit di recente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <indexterm>
     <primary>livello di isolamento transazionale</primary>

    </indexterm>
I quattro livelli di isolamento transazionale e i comportamenti corrispondenti
sono descritti in <xref linkend="mvcc-isolevel-table"/>.
   </para>

    <table tocentry="1" id="mvcc-isolevel-table">
     <title>Livelli di isolamento di transazione <acronym>SQL</acronym></title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>
         Livello di isolamento
        </entry>
        <entry>
         Lettura sporca
        </entry>
        <entry>
         Lettura non ripetibile
        </entry>
        <entry>
         Lettura fantasma
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         Lettura che non ha fatto commit
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Lettura che ha fatto commit
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Lettura ripetibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Possibile
        </entry>
       </row>

       <row>
        <entry>
         Serializzabile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
        <entry>
         Non possibile
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
In <productname>PostgreSQL</productname>, è possibile richiedere uno qualsiasi 
dei quattro livelli standard di isolamento di transazione. Ma internalmente, ci sono 
solo due distinti livelli di isolamento, che corrispondono ai livelli Read
Committed e Serializable. Quando si sceglie il livello Read Uncommitted 
in realtà si otterrà Read Committed, e quando si sceglie 
Repeatable Read in realtà si otterrà Serializable, così il livello di isolamento effettivo
potrebbe essere più stretto di quello scelto. Questo è permesso dallo standard SQL:
i quattro livelli di isolamento definiscono solo quali fenomeni 
non devono accadere, non definiscono quali fenomeni devono accadere.
La ragione per la quale <productname>PostgreSQL</productname>
fornisce solo due livelli di isolamento è che questo è l'unico modo sensato
per gestire i livelli di isolamento standard nell'architettura 
di controllo concorrente. Il comportamento dei livelli di isolamento 
è spiegato in dettaglio nelle sottosezioni seguenti.
   </para>

   <para>
Per impostare il livello di isolamento transazionale di una transazione, usare 
il comando <xref linkend="sql-set-transaction"/>.
   </para>

  <sect2 id="xact-read-committed">
   <title>Livello di isolamento  Read Committed </title>

   <indexterm>
    <primary>livello di isolamento transazionale</primary>
    <secondary>read committed</secondary>
   </indexterm>

   <para>
<firstterm>Read Committed</firstterm> è il livello di isolamento predefinito
in <productname>PostgreSQL</productname>. Quando una transazione usa 
questo livello di isolamento, una query <command>SELECT</command> 
(senza clausola <literal>FOR UPDATE/SHARE</literal>) vede solo i dati 
che sono stati sottoposti a commit prima che query iniziasse; essa non vede mai nè 
i dati non sottoposti a commit nè i cambiamenti sottoposti a commit da transazioni  
concorrenti durante l'esecuzione
della query.  In effetti, una query <command>SELECT</command> vede un'istantanea
del database nell'istante in cui è partita.
Ad ogni modo,  <command>SELECT</command> vede gli effetti
di update precedenti eseguite all'interno della propria transazione, 
anche se non sono ancora stati sottoposti a commit. Notare inoltre che due 
comandi <command>SELECT</command> possono vedere dati differenti, anche 
se sono all'interno di una singola transazione, se altre transazioni 
eseguono cambiamenti durante l'esecuzione della prima <command>SELECT</command>.
   </para>

   <para>
I comandi <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
FOR UPDATE</command>, e <command>SELECT FOR SHARE</command> 
si comportano allo stesso modo di <command>SELECT</command>
che sono state sottoposte a commit dopo il momento di inizio del comando. In ogni caso, tale
riga potrebbe essere già stata aggiornata (o cancellata, o sottoposta a lock) da un'altra
    another concurrent transaction by the time it is found.  In this case, the
transazione concorrente nel momento che viene trovata. In questo caso, 
    would-be updater will wait for the first updating transaction to commit or
    roll back (if it is still in progress).  If the first updater rolls back,
    then its effects are negated and the second updater can proceed with
    updating the originally found row.  If the first updater commits, the
    second updater will ignore the row if the first updater deleted it,
    otherwise it will attempt to apply its operation to the updated version of
    the row.  The search condition of the command (the <literal>WHERE</literal> clause) is
    re-evaluated to see if the updated version of the row still matches the
    search condition.  If so, the second updater proceeds with its operation
    using the updated version of the row.  In the case of
    <command>SELECT FOR UPDATE</command> and <command>SELECT FOR
    SHARE</command>, this means it is the updated version of the row that is
    locked and returned to the client.
   </para>
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->

   <para>
A causa della regola sopra, è possibile, per un comando di aggiornamento, vedere 
un'istantanea inconsistene: può vedere gli effetti di comandi di aggiornamento
concorrenti sulle stesse righe che sta tentando di aggiornare, ma non vede 
gli effetti di quei comandi sulle altre righe nel database.
Questo comportamento rende la modalità Read Committed inadatta a comandi che 
coinvolgono condizioni di ricerca complesse; in ogni caso, va bene per casi più semplici.
Per esempio, considerare l'aggiornamento di saldi bancari con transazioni tipo:

<screen>
BEgin;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
</screen>

Se due di quelle transazioni provano a cambiare concorrentemente il saldo dell'account 
12345, chiaramente si vorrà che la seconda transazione cominci con la versione 
aggiornata della riga di account. Dato che ogni comando incluisce solamente su una riga 
predetermiata, lasciargli vedere la versione aggiornata della riga non crea 
nessun problema di inconsistenza.
   </para>

   <para>
Un utilizzo più complesso può produrre risultati non desiderati in modalità
Read Committed. Per esempio, considerare un comando <command>DELETE</command>
che opera su dati che sono stati sia aggiunti che rimossi dai suoi 
criteri di restrizione da un altro comando, per es., sia
<literal>website</literal> una tabella  con due righe con
<literal>website.hits</literal> uguale a <literal>9</literal> e
<literal>10</literal>:

<screen>
BEgin;
UPDATE website SET hits = hits + 1;
-- eseguito da un'altra sessione:  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

<command>DELETE</command> non avrà effetti dato che 
c'è una riga <literal>website.hits = 10</literal> prima e dopo 
l'<command>UPDATE</command>. Questo accade perchè 
il valore di riga precedentemente aggiornato <literal>9</literal> viene saltato, e quando
l'<command>UPDATE</command> è completo e <command>DELETE</command>
ottiene un lock, il nuovo valore di riga non è più <literal>10</literal> ma
<literal>11</literal>, che non corrisponde più ai criteri di ricerca.
   </para>

   <para>
Dato che la modalità Read Committed comincia ogni comando con una nuova istantanea
che include tutte le transazioni sottoposte a commit fino a quell'istante,
i comandi successivi nella stessa transazione vedranno gli effetti 
della transazione concorrente sottoposta a commit in ogni caso. Il punto della questione 
è se un <emphasis>singolo</emphasis> comando ha o meno una visione assolutamente consistente del database.
   </para>

   <para>
L'isolamento transazionale parziale fornito dalla modalità Read Committed
è adeguato per molte applicazioni, e questa modalità è veloce e semplice da usare;
comunque, non è sufficiente per tutti i casi. Le applicazioni che 
fanno query e aggiornamenti complessi potrebbero richiedere una visione consistente del database
più rigorosa che quella fornita dalla modalità Read Committed.
   </para>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Livello di isolamento serializzabile</title>

   <indexterm>
    <primary>livello di isolamento transazionale</primary>
    <secondary>serializzabile</secondary>
   </indexterm>

   <para>
Il livello di isolamento <firstterm>Serializable</firstterm> fornisce l'isolamento
transazionale più rigido. Questo livello emula l'esecuzione di transazioni seriali,
come se le transazioni fossero state eseguite una dopo l'altra, in maniera seriale,
invece che concorrentemente. Comunque, applicazioni che usano questo livello devono 
essere preparate a ritentare le transazioni dopo fallimenti della serializzazione.
   </para>

   <para>
Quando una transazione usa il livello serializzabile,
una query <command>SELECT</command> vede i dati sottoposti a commit prima che la transazione sia iniziata;
non vede mai nè dati non sottoposti a commit nè cambiamenti
sottoposti a commit durante l'esecuzione di transazione 
da parte di transazioni concorrenti. (Comunque, 
la query vede gli effetti di aggiornamenti precedenti
eseguiti all'interno della propria transazione, anche se non sono ancora state 
sottoposte a commit). Questo è diverso dal Read Committed nel quale 
una query in una transazione serializzabile 
vede un'istantanea all'inizio della  <emphasis>transazione</emphasis>,
non all'inizio della quey corrente all'interno della transazione. Così,
comandi <command>SELECT</command> successivi all'interno di una <emphasis>singola</emphasis>
transazione vedono gli stessi dati, per es., non vedono cambiamenti fatti 
da altre transazioni che sono stati sottoposti a commit dopo che le proprie transazioni sono partite.
(Questo comportamento può essere ideale per applicazioni di riportistica).
   </para>

   <para>
I comandi <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
FOR UPDATE</command>, e <command>SELECT FOR SHARE</command> 
si comportano come <command>SELECT</command>
in termini di ricerca di righe: trovano solo righe che sono state sottoposte a commit
dal momento di inizio della transazione. Comunque, quella riga
potrebbe essere già stata aggiornata (o cancellata, o sottoposta a lock) da
un'altra transazione concorrente, nel momento in cui è stata trovata. In questo caso,
la transazione serializzabile aspetterà che la prima transazione esegua un commit o un
rool back (se è ancora in corso). Se la prima transazione esegue un rollback, 
allora i suoi effetti sono negati e la transazione serializzabile può procedere
con l'aggiornamento della riga trovata originariamente. Ma se la prima transazione esegue un commit
(ed effettivamente aggiorna o cancella la riga, non esegue semplicemente un lock)
allora la transazione serializzabile sarà sottoposta a rollback con il messaggio

<screen>
ERROR:  could not serialize access due to concurrent update
</screen>

dato che una transazione serializabile non può modificare i eseguire lock su righe 
cambiate da altre transzioni dopo che la transazione serializzabile è iniziata.
   </para>

   <para>
Quando l'applicazione riceve questo messaggio di errore, dovrebbe 
annullare la transazione corrente e riprovare l'intera transazione dall'inizio.
La seconda volta, la transazione vedrà il cambiamento sottoposto a commit precedentemente
come parte della sua visione iniziale del database,
così non c'è conflitto logico nell'usare la nuova versione della riga 
come punto di partenza per la nuova transazione.
   </para>

   <para>
Notare che solo transazioni di aggiornamento potrebbero necessitare di essere riprovate; 
transazioni a sola lettura non avranno mai conflitti di serializzazione.
   </para>

   <para>
La modalità Serializable fornisce una garanzia rigorosa che ogni 
transazione abbia una visione completamente consistente del database. Comunque,
l'applicazione dev'essere preparata a ritentare le transazioni quando aggiornamenti concorrenti
rendono impossibile l'illusione di esecuzione seriale.
Dato che il costo di rifare transazioni complesse può essere significativo,
la modalità Serializable è raccomandata solo quando transazioni di aggiornamento contengono
logiche sufficientemente complesse che potrebbero fornire risposte sbagliate in modalità
Read Committed. Di solito, la modalità Serializable è necessaria quando 
una transazione esegue diversi comandi successivi che devono avere
visioni identiche del database.
   </para>

<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
   <sect3 id="mvcc-serializability">
    <title>Serializable Isolation versus True Serializability</title>

   <indexterm>
    <primary>serializability</primary>
   </indexterm>

   <indexterm>
    <primary>predicate locking</primary>
   </indexterm>

<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->
   <para>
Il significato intuitivo (e la definiziona matematica) di 
esecuzione <quote>serializzabile</quote> è che qualsiasi due transazioni che hanno 
effettuato un commit con successo appariranno come se fossero state eseguite in maniera strettamente
seriale, una dopo l'altra - sebbene quale appaia come eseguita prima potrebbe
non  essere prevedibile in anticipo. È importante rendersi conto che vietare  
i comportamenti indesiderati elencati nella <xref linkend="mvcc-isolevel-table"/>
non è sufficiente a garantire una vera serializzazione, e infatti 
la modalità Serializable di <productname>PostgreSQL</productname> <emphasis>non
garantisce l'esecuzione serializzabile in questo senso</emphasis>. Come esempio,
considerare una tabella <structname>mytab</structname>, contenente inizialmente: 
<screen>
 class | value 
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200
</screen>
Supporre che la transazione serializzabile A calcola:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 1;
</screen>
e poi inserisce il risultato (30) come <structfield>valore</structfield> in una 
nuova riga con <structfield>class</structfield><literal> = 2</literal>. Concorrentemente, la transazione
serializzabile B calcola:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 2;
</screen>
e ottiene il risultato 300, che inserisce in una nuova riga con
<structfield>class</structfield><literal> = 1</literal>. Quindi entrambe le transazioni fanno il commit.
Nessuno dei comportamenti indesiderati elencati si è presentato, ma si otterrà
un risultato che non potrebbe essere successo in nessun ordine serialmente. 
Se A è stata eseguita prima di B, B avrebbe calcolato la somma 330, non 300, 
e similmente l'altro ordine sarebbe risultato in una somma diversa di quella calcolata da A.
   </para>

   <para>
Per garantire vera serializzazione matematica, è necessario per un sistema di   
database assicurare il <firstterm>predicate locking</firstterm>, che significa che 
una transazione non può inserire o modificare una riga che potrebbe corrispondere
a una condizione <literal>WHERE</literal> di una query in un'altra transazione
concorrente. Per esempio, una volta che la transazione A ha eseguito la query 
<literal>SELECT ... WHERE class = 1</literal>, un sistema di <firstterm>predicate locking</firstterm>
eviterebbe che la transzione B inserisse qualsiasi nuova riga con class 1 finchè
A ha fatto commit.
     <footnote>
      <para>
Essenzialmente, un sistema di <firstterm>predicate locking</firstterm> previene 
letture fantasma restringendo cosa viene scritto, mentre MVCC le previene restringendo cosa
viene letto.
      </para>
     </footnote>
Tale sistema di locking è complesso da implementare
e estremamente costoso in esecuzione, dato che ogni sessione deve
fare attenzione ai dettagli di ogni query eseguita da ogni transazione concorrente.
E questa grande spesa è per la maggior parte inutile, dato che in pratica
la maggior parte della applicazioni non fanno il tipo di cose che potrebbero generare problemi.
(Certamente l'esempio sopra è abbastanza forzato ed è improbabile che rappresenti 
software reale). Per queste ragioni, 
<productname>PostgreSQL</productname> non implementa il predicate locking.
   </para>

   <para>
In casi dove la possibilità di esecuzione non-serializzabile è realmente
un azzardo, è possibile prevenire i problemi con un uso appropriato di 
lock esplicito. Maggiori dettagli appaiono nelle sezioni seguenti.
   </para>
  </sect3>
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
   <title>Lock esplicito</title>

   <indexterm>
    <primary>lock</primary>
   </indexterm>

   <para>
<productname>PostgreSQL</productname> fornisce varie modalità di lock
per controllare accessi concorrenti ai dati nelle tabelle. Queste modalità possono
essere usate per fare dei lock controllate dall'applicazione in situazioni dove
<acronym>MVCC</acronym> non fornisce ilcomportamento desiderato. Inoltre, 
la maggior parte dei comandi <productname>PostgreSQL</productname> acquisiscono 
automaticamente lock delle modalità appropriate per assicurare che tabelle 
a cui si fa riferimento non siano cancellate o modificate in modi incompatibili mentre
il comando è in esecuzione. (Per esempio,  <command>TRUNCATE</command> non può essere eseguito  
concorrentemente ad altre operazioni sulla stessa tabella in maniera sicura, e così ottiene
un lock esclusivo sulla tabella per assicurarlo).
   </para>

   <para>
    To examine a list of the currently outstanding locks in a database
    server, use the
    <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
    system view. For more information on monitoring the status of the lock
    manager subsystem, refer to <xref linkend="monitoring"/>.
   </para>

  <sect2 id="locking-tables">
   <title>Table-Level Locks</title>

   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>

   <para>
    The list below shows the available lock modes and the contexts in
    which they are used automatically by
    <productname>PostgreSQL</productname>.  You can also acquire any
    of these locks explicitly with the command <xref
    linkend="sql-lock"/>.
    Remember that all of these lock modes are table-level locks,
    even if the name contains the word
    <quote>row</quote>; the names of the lock modes are historical.
    To some extent the names reflect the typical usage of each lock
    mode &mdash; but the semantics are all the same.  The only real difference
    between one lock mode and another is the set of lock modes with
    which each conflicts (see <xref linkend="table-lock-compatibility"/>).
    Two transactions cannot hold locks of conflicting
    modes on the same table at the same time.  (However, a transaction
    never conflicts with itself.  For example, it might acquire
    <literal>ACCESS EXCLUSIVE</literal> lock and later acquire
    <literal>ACCESS SHARE</literal> lock on the same table.)  Non-conflicting
    lock modes can be held concurrently by many transactions.  Notice in
    particular that some lock modes are self-conflicting (for example,
    an <literal>ACCESS EXCLUSIVE</literal> lock cannot be held by more than one
    transaction at a time) while others are not self-conflicting (for example,
    an <literal>ACCESS SHARE</literal> lock can be held by multiple transactions).
   </para>

     <variablelist>
      <title>Table-level lock modes</title>
      <varlistentry>
       <term>
        <literal>ACCESS SHARE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>ACCESS EXCLUSIVE</literal> lock
         mode only.
        </para>

        <para>
         The <command>SELECT</command> command acquires a lock of this mode on
         referenced tables.  In general, any query that only <emphasis>reads</emphasis> a table
         and does not modify it will acquire this lock mode.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ROW SHARE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>EXCLUSIVE</literal> and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
        </para>

        <para>
         The <command>SELECT FOR UPDATE</command> and
         <command>SELECT FOR SHARE</command> commands acquire a
         lock of this mode on the target table(s) (in addition to
         <literal>ACCESS SHARE</literal> locks on any other tables
         that are referenced but not selected
         <option>FOR UPDATE/FOR SHARE</option>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ROW EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
        </para>

        <para>
         The commands <command>UPDATE</command>,
         <command>DELETE</command>, and <command>INSERT</command>
         acquire this lock mode on the target table (in addition to
         <literal>ACCESS SHARE</literal> locks on any other referenced
         tables).  In general, this lock mode will be acquired by any
         command that <emphasis>modifies data</emphasis> in a table.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE UPDATE EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>SHARE UPDATE EXCLUSIVE</literal>,
         <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode protects a table against
         concurrent schema changes and <command>VACUUM</command> runs.
        </para>

        <para>
         Acquired by <command>VACUUM</command> (without <option>FULL</option>),
         <command>ANALYZE</command>, and <command>CREATE INDEX CONCURRENTLY</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode protects a table against concurrent data changes.
        </para>

        <para>
         Acquired by <command>CREATE INDEX</command>
         (without <option>CONCURRENTLY</option>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>SHARE ROW EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>,
         <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
        </para>

        <para>
         Acquired by <command>CREATE TRIGGER</command>,
         <command>CREATE RULE</command> (except for <literal>ON SELECT</literal>
         rules) and in some cases <command>ALTER TABLE</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with the <literal>ROW SHARE</literal>, <literal>ROW
         EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode allows only concurrent <literal>ACCESS SHARE</literal> locks,
         i.e., only reads from the table can proceed in parallel with a
         transaction holding this lock mode.
        </para>

        <para>
         This lock mode is not automatically acquired on user tables by any
         <productname>PostgreSQL</productname> command.  However it is
         acquired on certain system catalogs in some operations.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>ACCESS EXCLUSIVE</literal>
       </term>
       <listitem>
        <para>
         Conflicts with locks of all modes (<literal>ACCESS
         SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
         EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal>).
         This mode guarantees that the
         holder is the only transaction accessing the table in any way.
        </para>

        <para>
         Acquired by the <command>DROP TABLE</command>,
         <command>TRUNCATE</command>, <command>REINDEX</command>,
         <command>CLUSTER</command>, and <command>VACUUM FULL</command>
         commands, as well as most variants of <command>ALTER TABLE</command>.
         This is also the default lock mode for <command>LOCK TABLE</command>
         statements that do not specify a mode explicitly.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
      <para>
       Only an <literal>ACCESS EXCLUSIVE</literal> lock blocks a
       <command>SELECT</command> (without <option>FOR UPDATE/SHARE</option>)
       statement.
      </para>
     </tip>

   <para>
    Once acquired, a lock is normally held till end of transaction.  But if a
    lock is acquired after establishing a savepoint, the lock is released
    immediately if the savepoint is rolled back to.  This is consistent with
    the principle that <command>ROLLBACK</command> cancels all effects of the
    commands since the savepoint.  The same holds for locks acquired within a
    <application>PL/pgSQL</application> exception block: an error escape from the block
    releases locks acquired within it.
   </para>



    <table tocentry="1" id="table-lock-compatibility">
     <title> Conflicting lock modes</title>
     <tgroup cols="9">
      <colspec colnum="2" colname="lockst"/>
      <colspec colnum="9" colname="lockend"/>
      <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
      <thead>
       <row>
        <entry morerows="1">Requested Lock Mode</entry>
        <entry spanname="lockreq">Current Lock Mode</entry>
       </row>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry>ROW SHARE</entry>
        <entry>ROW EXCLUSIVE</entry>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry>SHARE</entry>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry>EXCLUSIVE</entry>
        <entry>ACCESS EXCLUSIVE</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ACCESS EXCLUSIVE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-rows">
    <title>Row-Level Locks</title>

    <para>
     In addition to table-level locks, there are row-level locks, which
     can be exclusive or shared locks.  An exclusive row-level lock on a
     specific row is automatically acquired when the row is updated or
     deleted.  The lock is held until the transaction commits or rolls
     back, just like table-level locks.  Row-level locks do
     not affect data querying; they block only <emphasis>writers to the same
     row</emphasis>.
    </para>

    <para>
     To acquire an exclusive row-level lock on a row without actually
     modifying the row, select the row with <command>SELECT FOR
     UPDATE</command>.  Note that once the row-level lock is acquired,
     the transaction can update the row multiple times without
     fear of conflicts.
    </para>

    <para>
     To acquire a shared row-level lock on a row, select the row with
     <command>SELECT FOR SHARE</command>.  A shared lock does not prevent
     other transactions from acquiring the same shared lock.  However,
     no transaction is allowed to update, delete, or exclusively lock a
     row on which any other transaction holds a shared lock.  Any attempt
     to do so will block until the shared lock(s) have been released.
    </para>

    <para>
     <productname>PostgreSQL</productname> doesn't remember any
     information about modified rows in memory, so there is no limit on
     the number of rows locked at one time.  However, locking a row
     might cause a disk write, e.g., <command>SELECT FOR
     UPDATE</command> modifies selected rows to mark them locked, and so
     will result in disk writes.
    </para>

    <para>
     In addition to table and row locks, page-level share/exclusive locks are
     used to control read/write access to table pages in the shared buffer
     pool.  These locks are released immediately after a row is fetched or
     updated.  Application developers normally need not be concerned with
     page-level locks, but they are mentioned here for completeness.
    </para>

   </sect2>

   <sect2 id="locking-deadlocks">
    <title>Deadlocks</title>

    <indexterm zone="locking-deadlocks">
     <primary>deadlock</primary>
    </indexterm>

    <para>
     The use of explicit locking can increase the likelihood of
     <firstterm>deadlocks</firstterm>, wherein two (or more) transactions each
     hold locks that the other wants.  For example, if transaction 1
     acquires an exclusive lock on table A and then tries to acquire
     an exclusive lock on table B, while transaction 2 has already
     exclusive-locked table B and now wants an exclusive lock on table
     A, then neither one can proceed.
     <productname>PostgreSQL</productname> automatically detects
     deadlock situations and resolves them by aborting one of the
     transactions involved, allowing the other(s) to complete.
     (Exactly which transaction will be aborted is difficult to
     predict and should not be relied upon.)
    </para>

    <para>
     Note that deadlocks can also occur as the result of row-level
     locks (and thus, they can occur even if explicit locking is not
     used). Consider the case in which two concurrent
     transactions modify a table. The first transaction executes:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</screen>

     This acquires a row-level lock on the row with the specified
     account number. Then, the second transaction executes:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</screen>

     The first <command>UPDATE</command> statement successfully
     acquires a row-level lock on the specified row, so it succeeds in
     updating that row. However, the second <command>UPDATE</command>
     statement finds that the row it is attempting to update has
     already been locked, so it waits for the transaction that
     acquired the lock to complete. Transaction two is now waiting on
     transaction one to complete before it continues execution. Now,
     transaction one executes:

<screen>
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</screen>

     Transaction one attempts to acquire a row-level lock on the
     specified row, but it cannot: transaction two already holds such
     a lock. So it waits for transaction two to complete. Thus,
     transaction one is blocked on transaction two, and transaction
     two is blocked on transaction one: a deadlock
     condition. <productname>PostgreSQL</productname> will detect this
     situation and abort one of the transactions.
    </para>

    <para>
     The best defense against deadlocks is generally to avoid them by
     being certain that all applications using a database acquire
     locks on multiple objects in a consistent order. In the example
     above, if both transactions
     had updated the rows in the same order, no deadlock would have
     occurred. One should also ensure that the first lock acquired on
     an object in a transaction is the most restrictive mode that will be
     needed for that object.  If it is not feasible to verify this in
     advance, then deadlocks can be handled on-the-fly by retrying
     transactions that abort due to deadlocks.
    </para>

    <para>
     So long as no deadlock situation is detected, a transaction seeking
     either a table-level or row-level lock will wait indefinitely for
     conflicting locks to be released.  This means it is a bad idea for
     applications to hold transactions open for long periods of time
     (e.g., while waiting for user input).
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Advisory Locks</title>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> provides a means for
     creating locks that have application-defined meanings.  These are
     called <firstterm>advisory locks</firstterm>, because the system does not
     enforce their use &mdash; it is up to the application to use them
     correctly.  Advisory locks can be useful for locking strategies
     that are an awkward fit for the MVCC model.  Once acquired, an
     advisory lock is held until explicitly released or the session ends.
     Unlike standard locks, advisory locks do not
     honor transaction semantics: a lock acquired during a
     transaction that is later rolled back will still be held following the
     rollback, and likewise an unlock is effective even if the calling
     transaction fails later.  The same lock can be acquired multiple times by
     its owning process: for each lock request there must be a corresponding
     unlock request before the lock is actually released.  (If a session
     already holds a given lock, additional requests will always succeed, even
     if other sessions are awaiting the lock.)  Like all locks in
     <productname>PostgreSQL</productname>, a complete list of advisory
     locks currently held by any session can be found in the
     <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
     system view.
    </para>

    <para>
     Advisory locks are allocated out of a shared memory pool whose size
     is defined by the configuration variables
     <xref linkend="guc-max-locks-per-transaction"/> and
     <xref linkend="guc-max-connections"/>.
     Care must be taken not to exhaust this
     memory or the server will be unable to grant any locks at all.
     This imposes an upper limit on the number of advisory locks
     grantable by the server, typically in the tens to hundreds of thousands
     depending on how the server is configured.
    </para>

    <para>
     A common use of advisory locks is to emulate pessimistic locking
     strategies typical of so called <quote>flat file</quote> data management
     systems.
     While a flag stored in a table could be used for the same purpose,
     advisory locks are faster, avoid MVCC bloat, and are automatically
     cleaned up by the server at the end of the session.
     In certain cases using this advisory locking method, especially in queries
     involving explicit ordering and <literal>LIMIT</literal> clauses, care must be
     taken to control the locks acquired because of the order in which SQL
     expressions are evaluated.  For example:
<screen>
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</screen>
     In the above queries, the second form is dangerous because the
     <literal>LIMIT</literal> is not guaranteed to be applied before the locking
     function is executed.  This might cause some locks to be acquired
     that the application was not expecting, and hence would fail to release
     (until it ends the session).
     From the point of view of the application, such locks
     would be dangling, although still viewable in
     <structname>pg_locks</structname>.
    </para>

    <para>
     The functions provided to manipulate advisory locks are described in
     <xref linkend="functions-advisory-locks"/>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
   <title>Data Consistency Checks at the Application Level</title>

   <para>
    Because readers in <productname>PostgreSQL</productname>
    do not lock data, regardless of
    transaction isolation level, data read by one transaction can be
    overwritten by another concurrent transaction. In other words,
    if a row is returned by <command>SELECT</command> it doesn't mean that
    the row is still current at the instant it is returned (i.e., sometime
    after the current query began).  The row might have been modified or
    deleted by an already-committed transaction that committed after
    the <command>SELECT</command> started.
    Even if the row is still valid <quote>now</quote>, it could be changed or
    deleted
    before the current transaction does a commit or rollback.
   </para>

   <para>
    Another way to think about it is that each
    transaction sees a snapshot of the database contents, and concurrently
    executing transactions might very well see different snapshots.  So the
    whole concept of <quote>now</quote> is somewhat ill-defined anyway.
    This is not normally
    a big problem if the client applications are isolated from each other,
    but if the clients can communicate via channels outside the database
    then serious confusion might ensue.
   </para>

   <para>
    To ensure the current validity of a row and protect it against
    concurrent updates one must use <command>SELECT FOR UPDATE</command>,
    <command>SELECT FOR SHARE</command>, or an appropriate <command>LOCK
    TABLE</command> statement.  (<command>SELECT FOR UPDATE</command>
    and <command>SELECT FOR SHARE</command> lock just the
    returned rows against concurrent updates, while <command>LOCK
    TABLE</command> locks the whole table.)  This should be taken into
    account when porting applications to
    <productname>PostgreSQL</productname> from other environments.
   </para>

   <para>
    Global validity checks require extra thought under <acronym>MVCC</acronym>.
    For example, a banking application might wish to check that the sum of
    all credits in one table equals the sum of debits in another table,
    when both tables are being actively updated.  Comparing the results of two
    successive <literal>SELECT sum(...)</literal> commands will not work reliably in
    Read Committed mode, since the second query will likely include the results
    of transactions not counted by the first.  Doing the two sums in a
    single serializable transaction will give an accurate picture of only the
    effects of transactions that committed before the serializable transaction
    started &mdash; but one might legitimately wonder whether the answer is still
    relevant by the time it is delivered.  If the serializable transaction
    itself applied some changes before trying to make the consistency check,
    the usefulness of the check becomes even more debatable, since now it
    includes some but not all post-transaction-start changes.  In such cases
    a careful person might wish to lock all tables needed for the check,
    in order to get an indisputable picture of current reality.  A
    <literal>SHARE</literal> mode (or higher) lock guarantees that there are no
    uncommitted changes in the locked table, other than those of the current
    transaction.
   </para>

   <para>
    Note also that if one is relying on explicit locking to prevent concurrent
    changes, one should either use Read Committed mode, or in Serializable
    mode be careful to obtain
    locks before performing queries.  A lock obtained by a
    serializable transaction guarantees that no other transactions modifying
    the table are still running, but if the snapshot seen by the
    transaction predates obtaining the lock, it might predate some now-committed
    changes in the table.  A serializable transaction's snapshot is actually
    frozen at the start of its first query or data-modification command
    (<literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or <literal>DELETE</literal>), so
    it is possible to obtain locks explicitly before the snapshot is
    frozen.
   </para>
  </sect1>

  <sect1 id="locking-indexes">
   <title>Locking and Indexes</title>

   <indexterm zone="locking-indexes">
    <primary>index</primary>
    <secondary>locks</secondary>
   </indexterm>

   <para>
    Though <productname>PostgreSQL</productname>
    provides nonblocking read/write access to table
    data, nonblocking read/write access is not currently offered for every
    index access method implemented
    in <productname>PostgreSQL</productname>.
    The various index types are handled as follows:

    <variablelist>
     <varlistentry>
      <term>
       B-tree and <acronym>gist</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted.  These index types provide
        the highest concurrency without deadlock conditions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Hash indexes
      </term>
      <listitem>
       <para>
        Share/exclusive hash-bucket-level locks are used for read/write
        access.  Locks are released after the whole bucket is processed.
        Bucket-level locks provide better concurrency than index-level
        ones, but deadlock is possible since the locks are held longer
        than one index operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <acronym>gin</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted. But note that insertion of a
        gin-indexed value usually produces several index key insertions
        per row, so gin might do substantial work for a single value's
        insertion.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Currently, B-tree indexes offer the best performance for concurrent
    applications; since they also have more features than hash
    indexes, they are the recommended index type for concurrent
    applications that need to index scalar data. When dealing with
    non-scalar data, B-trees are not useful, and gist or gin indexes should
    be used instead.
   </para>
  </sect1>
 </chapter>

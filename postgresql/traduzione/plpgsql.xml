<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="plpgsql">
  <title><application>PL/pgSQL</application> - Linguaggio procedurale <acronym>SQL</acronym></title>

 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
  <title>Panoramica</title>

 <para>
<application>PL/pgSQL</application> è un linguaggio procedurale 
caricabile nel sistema di database  <productname>PostgreSQL</productname>.
Gli obiettivi del design di <application>PL/pgSQL</application> erano di creare 
un linguaggio caricabile che

    <itemizedlist>
     <listitem>
      <para>
potesse essere usato per creare funzioni e procedure trigger,
      </para>
     </listitem>
     <listitem>
      <para>
aggiungesse strutture di controllo al lingiaggio <acronym>SQL</acronym>,
      </para>
     </listitem>
     <listitem>
      <para>
potesse svolgere calcoli complessi,

      </para>
     </listitem>
     <listitem>
      <para>
ereditasse tutti i tipi, le funzioni e gli operatori definiti dall'utente,
      </para>
     </listitem>
     <listitem>
      <para>
potesse essere definito per essere trusted dal server,
      </para>
     </listitem>
     <listitem>
      <para>
fosse facile da usare.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
Funzioni create con  <application>PL/pgSQL</application> possono essere 
usate ovunque possano essere usate funzioni incorporate.
Per esempio, è possibile creare 
funzioni di calcolo condizionale complesse e successivamente 
usarle per definire operatori o usarle in espressioni di indice.
   </para>

   <para>
In <productname>PostgreSQL</productname> 9.0 e successivi,
<application>PL/pgSQL</application> è installato in maniera predefinita.
Comunque è ancora un modulo caricabile, per questo amministratori particolarmente attenti alla sicurezza
potrebbero decidere di rimuoverlo.
   </para>

  <sect2 id="plpgsql-advantages">
   <title>Vantaggi dell'utilizzo di <application>PL/pgSQL</application></title>

    <para>
<acronym>SQL</acronym> è il linguaggio che <productname>PostgreSQL</productname>
e la maggior parte degli altri database relazioni usano come linguaggio di interrogazione. È
portabile e facile da imparare. Ma ogni istruzione <acronym>SQL</acronym>
dev'essere eseguita individualmente dal server database.
    </para>

    <para>
Questo significa che l'applicazione client deve mandare ogni query al server database,
aspettare che sia elaborata, ricevere ed elaborare il risultato,
eseguire alcuni calcoli, quindi mandare ulteriori 
query al server. Tutto questo genera comunicazione tra processi 
e genererà anche overhead di rete se il client
è su una macchina differente rispetto al server database.
    </para>

    <para>
Con <application>PL/pgSQL</application> si può raggruppare un blocco di
calcolo e una serie di query <emphasis>all'interno</emphasis>
del server database, avendo quindi la potenza di un linguaggio procedurale
e la facilità d'uso dell'SQL, ma con considerevole risparmio
di overhead di comunicazione client/server.
    </para>
    <itemizedlist>

     <listitem><para>
Sono eliminati i giri aggiuntivi tra il client e il server
     </para></listitem>

     <listitem><para> 
I risultati intermedi non necessari al client non devono essere 
smistati o trasferiti tra il server e il client
     </para></listitem>

     <listitem><para> 
Possono essere evitati molteplici stadi di parsing delle query
     </para></listitem>

    </itemizedlist>
<para> Questo risulta in un incremento di prestazioni considerevole 
se confrontato con un'applicazione che non usa funzioni immagazzinate.
    </para>

    <para>
Inoltre, con <application>PL/pgSQL</application> si possono usare
tutti i tipi di dato, gli operatori e le funzioni di SQL.
    </para>
  </sect2>

  <sect2 id="plpgsql-args-results">
   <title>Argomenti supportati e tipi di dato risultanti</title>

    <para>
Le funzioni scritte in <application>PL/pgSQL</application> possono accettare 
come argomenti qualsiasi tipo scalare o array supportato dal server,
e possono restituire un risultato di qualsiasi di quei tipi. Possono anche 
accettare o restituire qualsiasi tipo composto (tipo riga) specificato dal nome.
È inoltre possibile dichiarare una funzione <application>PL/pgSQL</application>
che restituisce un <type>record</type>, che significa che il risultato
è un tipo riga le cui colonne sono determinate dalle specifiche nella 
query chiamante, come discusso in <xref linkend="queries-tablefunctions"/>.
    </para>

    <para>
Le funzioni <application>PL/pgSQL</application> possono essere dichiarate per accettare un numero variabile di argomenti
usando <literal>VARIADIC</literal>. Questo funziona esattamente
allo stesso modo delle funzioni SQL, come discusso in 
<xref linkend="xfunc-sql-variadic-functions"/>.
    </para>

    <para>
Le funzioni <application>PL/pgSQL</application> possono inoltre essere dichiarate per accettare 
e restituire tipo polimorfi
<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>
e <type>anyenum</type>.  Gli effettivi tipi di dato gestiti da una funzione polimorfa
possono variare da chiamata a chiamata, come discusso in  <xref linkend="extend-types-polymorphic"/>.
Un esempio è mostrato in <xref linkend="plpgsql-declaration-parameters"/>.
    </para>

    <para>
Funzioni  <application>PL/pgSQL</application> possono anche essere dichiarate per restituire
un <quote>insieme</quote> (o tabella) di qualsiasi tipo di dato che può essere restituito
come singola istanza. Tale funzione genera il suo output eseguendo 
<command>RETURN NEXT</command> per ogni elemento desiderato dell'insieme risultato,
o usando <command>RETURN QUERY</command> per mostrare in output il risultato della valutazione
della query.
    </para>

    <para>
Infine, una funzione <application>PL/pgSQL</application> può essere dichiarata per restituire
<type>void</type> se non ha valori di ritorno utili.
    </para>

    <para>
Funzioni <application>PL/pgSQL</application> possono anche essere dichiarate con
parametri di output al posto di una dichiarazione esplicita del tipo di ritorno.
Questo non aggiunge nessuna capacità fondamentale al linguaggio, ma 
spesso è conveniente, specialmente per restituire molteplici valori.
La notazione <literal>RETURNS TABLE</literal> può essere usata al posto di 
<literal>RETURNS SETOF</literal>.
    </para>

    <para>
Esempi specifici appaiono in 
<xref linkend="plpgsql-declaration-parameters"/> e
<xref linkend="plpgsql-statements-returning"/>.
    </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
  <title>Struttura di <application>PL/pgSQL</application></title>

  <para>
<application>PL/pgSQL</application> è un linguaggio strutturato a blocchi.
Il testo completo della definizione di una funzione deve essere un
<firstterm>blocco</firstterm>. Un blocco è definito come:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
Ogni dichiarazione e ogni istruzione all'interno di un blocco è terminata da 
un punto e virgola. Un blocco che appare all'interno di un altro blocco deve
avere un punto e virgola dopo <literal>END</literal>, come mostrato sopra;
comunque l'<literal>END</literal> finale che conclude il corpo di una
funzione non richiede un punto e virgola.
    </para>

    <tip>
     <para>
Un errore comunque è di scrivere un punto e virgola immediatamente dopo 
<literal>BEGIN</literal>. Questo non è corretto e causerà un errore di sintassi.
     </para>
    </tip>

    <para>
Una  <replaceable>label</replaceable> è necessaria solo se si vuole 
identificare il blocco per usarlo 
in un'istruzione <literal>EXIT</literal>, o per qualificare i nomi delle variabili
dichiarate nel blocco. Se un'etichetta viene fornita dopo 
<literal>END</literal>, deve corrispondere all'ettichetta all'inizio del blocco.
    </para>

    <para>
Tutte le parole chiave sono insensibili al case.
Gli identificatori sono implicitamente convertiti in minuscolo
a meno che non siano tra doppi apici, esattamente come nei comandi SQL comuni.
    </para>

    <para>
I commenti in <application>PL/pgSQL</application>  funzionano allo stesso modo del comune
SQL. Un trattino doppio (<literal>--</literal>) comincia un commento 
che si estende fino alla fine della linea. Un <literal>/*</literal>  comincia un blocco di commento 
che si estende fino all'occorrenza corispondente di
<literal>*/</literal>. I blocchi commenti possono essere nidificati.
    </para>

    <para>
     Any statement in the statement section of a block
     can be a <firstterm>subblock</firstterm>.  Subblocks can be used for
     logical grouping or to localize variables to a small group
     of statements.  Variables declared in a subblock mask any
     similarly-named variables of outer blocks for the duration
     of the subblock; but you can access the outer variables anyway
     if you qualify their names with their block's label. For example:
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEgin
    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
    quantity := 50;
    --
    -- Create a subblock
    --
    DECLARE
        quantity integer := 80;
    BEgin
        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <note>
     <para>
Attualmente c'è un <quote>blocco esterno</quote> nascosto che racchiude il corpo 
di qualsiasi funzione <application>PL/pgSQL</application>. Questo blocco fornisce le dichiarazioni
dei parametri di funzione (se presenti), così come alcune variabili speciali 
tipo <literal>FOUND</literal> (si veda 
<xref linkend="plpgsql-statements-diagnostics"/>). Il blocco esterno è 
etichettato con il nome della funzione, quindi i parametri e le variabili speciali 
possono essere qualificate con il nome della funzione.
     </para>
    </note>

    <para>
È importante non confondere l'uso di 
<command>BEGIN</command>/<command>END</command> per raggruppare istruzioni in 
<application>PL/pgSQL</application> con i comandi SQL chiamati similmente
per il controllo 
delle transazioni. <command>BEgin</command>/<command>END</command> di <application>PL/pgSQL</application>
sono solo per raggruppamento; essi non cominciano o finiscono una transazione.
Funzioni e procedure trigger sono eseguite sempre all'interno di una transazione
definita da una query esterna - non possono cominciare o fare il commit di quella
transzione, dato che non ci sarebbe contesto per loro in cui essere eseguite.
Comunque, un blocco che contiene una clausola <literal>EXCEPTION</literal> effettivamente
forma una sottotransazione di cui si può fare il rollback senza coinvolgere
la transazione esterna. Per maggiori informazioni su questo si veda <xref
linkend="plpgsql-error-trapping"/>.
    </para>
  </sect1>

  <sect1 id="plpgsql-declarations">
    <title>Dichiarazioni</title>

    <para>
Tutte le variabili usate in un blocco devono essere dichiarate nella sezione 
delle dichiarazioni del blocco.
(Le uniche eccezioni sono che la variabile loop di un ciclo <literal>FOR</literal>
che itera su un intervallo di valori interi è automaticamente dichiarata come una variabile intera,
come anche la variabile loop di un ciclo <literal>FOR</literal>
che itera sul risultato di un cursore viene automaticamente dichiarata come una 
variabile record).
    </para>

    <para>
Le variabili <application>PL/pgSQL</application> possono avere qualsiasi tipo di dato SQL, tipo 
<type>integer</type>, <type>varchar</type> e 
<type>char</type>.
    </para>

    <para>
Ecco alcuni esempi di dichiarazione di variabili:
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    <para>
La sintassi generale di una dichiarazione di variabile è:
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> NOT NULL </optional> <optional> { DEFAULT | := } <replaceable>expression</replaceable> </optional>;
</synopsis>
La clausola <literal>DEFAULT</literal>, se fornita, specifica il valore iniziale assegnato 
alla variabile quando viene specificato il blocco. Se la clausola  <literal>DEFAULT</literal> 
non è fornita allora la variabile è inizializzata al valore 
<acronym>SQL</acronym> null.
L'opzione <literal>CONSTANT</literal> evita che la variabile possa essere assegnata,
così quel valore rimarrà costante per tutta la durata del blocco.
Se è specificato <literal>NOT NULL</literal>, un'assegnazione di un valore null
risulterà in un errore durante l'esecuzione. 
Tutte le variabili dichiarate come <literal>NOT NULL</literal>
devono avere un valore non null di default specificato.
     </para>

     <para>
Il valore di default di una variabile è valutato e assegnato alla variabile 
ogni volta che il blocco è iniziato (non solo una volta per chiamata di funzione).
Quindi, per esempio, assegnare <literal>now()</literal> a una variabile di tipo 
<type>timestamp</type> fa sì che la variabile avrà l'orario della chiamata di fuzione corrente,
non l'orario in cui la funzione è stata precompilata.
     </para>

     <para>
      Examples:
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plpgsql-declaration-parameters">
     <title>Dichiarazione di parametri di funzione</title>

     <para>
I parametri passati alle funzioni sono chiamati con gli identificatori 
<literal>$1</literal>, <literal>$2</literal>,
ecc. Opzionalmente, possono essere dichiarati degli alias per 
<literal>$<replaceable>n</replaceable></literal>
nomi di parametri per aumentare la leggibilità. Sia l'alias che l'identificatore 
numerico possono quindi essere usati per riferirsi al valore del parametro.
     </para>

     <para>
Ci sono due modi di creare un alias. Il modo preferito è di dare un nome
al parametro nel comando <command>CREATE FUNCTION</command>,
per esempio:
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
L'altro modo, che era l'unico disponibile prima di 
<productname>PostgreSQL</productname> 8.0, è di dichiarare esplicitamente 
un alias, usando la sintassi di dichiarazione

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

Lo stesso esempio in questo stile somiglia a:
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEgin
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
     <para>
Questi due esempi non sono perfettamente equivalenti. Nel primo caso,
<literal>subtotal</literal> potrebbe essere riferito come 
<literal>sales_tax.subtotal</literal>, ma nel secondo caso non potrebbe.
(Dato che abbiamo attaccato un'etichetta al blocco interno, <literal>subtotal</literal> potrebbe
essere qualificato con quell'etichetta, invece).
     </para>
    </note>

     <para>
Altri esempi:
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEgin
    -- alcuni calcoli usando v_string e index
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEgin
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
Quando una funzione <application>PL/pgSQL</application> è dichiarata 
con parametri di output, ai parametri di output sono dati 
<literal>$<replaceable>n</replaceable></literal> nomi e opzionalmente alias
nello stesso modo dei normali parametri di input. Un parametro di output 
è effettivamente una variabile che parte NULL;
dovrebbe essere assegnata durante l'esecuzione della funzione.
Il valore finale del parametro è cosa viene restituito. Per esempio, 
l'esempio delle sales_tax potrebbe anche essere fatto in questo modo:

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEgin
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Notare che si è omesso <literal>RETURNS real</literal> - potevamo includerlo, 
ma sarebbe stato ridondante.
     </para>

     <para>
I parametri di output sono utili quando si restituiscono molteplivi valori.
Un esempio banale è:

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEgin
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Come discusso in  <xref linkend="xfunc-output-parameters"/>, questo crea 
effettivamente un tipo record anonimo per i risultati della funzione.
Se viene specificata una clausola  <literal>RETURNS</literal>, deve essere specificato 
<literal>RETURNS record</literal>.
     </para>

     <para>
Un altro modo di dichiarare una funzione <application>PL/pgSQL</application>
è con <literal>RETURNS TABLE</literal>, per esempio:

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEgin
    RETURN QUERY SELECT quantity, quantity * price FROM sales
                 WHERE itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Questo è esattamente equivalente a dichiarare uno o più parametri <literal>OUT</literal>
e specificare <literal>RETURNS SETOF
<replaceable>sometype</replaceable></literal>.
     </para>

     <para>
Quando il tipo di ritorno di una funzione <application>PL/pgSQL</application>
viene dichiarata come un tipo polimorfico  (<type>anyelement</type>,
<type>anyarray</type>, <type>anynonarray</type>, or <type>anyenum</type>),
viene creato un parametro speciale <literal>$0</literal>
Il suo tipo di dato è effettivamente il tipo di ritorno della funzione,
come dedotto fagli effettivi tipi di input (si veda <xref
linkend="extend-types-polymorphic"/>).
Questo permette alla funzione di accedere il suo effettivo tipo di ritorno
come mostrato in <xref linkend="plpgsql-declaration-type"/>. 
<literal>$0</literal> viene inizializzato a null e può essere modificato dalla
funzione, così può essere usato per tenere il valore di ritorno se lo si desidera,
anche se non è richiesto. È possibile dare un alias a <literal>$0</literal>.
Per esempio, questa funzione funziona su qualsiasi tipo di dato 
che ha un operatore <literal>+</literal>:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEgin
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
Lo stesso effetto può essere ottenuto dichiarando uno o più parametri come 
tipi polimorfici. In questo caso il parametro speciale
<literal>$0</literal> non viene usato; i parametri di output
stessi servono allo stesso scopo. PEr esempio:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEgin
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</literal></title>

<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>

   <para>
La sintassi di <literal>ALIAS</literal> è più generale rispetto a come suggerito nella
sezione precedente: è possibile dichiarare un alias per qualsiasi variabile, non solo
parametri di funzione. L'uso pratico principale per questo è di assegnare
un nome diverso per variabili con nomi predeterminati, tipo 
<varname>NEW</varname> o <varname>OLD</varname> all'interno
di una procedura trigger.
   </para>

   <para>
Esempi:
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>

   <para>
Dato che <literal>ALIAS</literal> crea due modi differenti per nominare lo stesso oggetto,
l'uso incontrollato può confondere. È meglio usarlo solo
per lo scopo di sovrascrivere nomi predeterminati.
   </para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
   <title>Copiare tipi</title>

<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   <para>
<literal>%TYPE</literal> fornisce il tipo di dato di una variabile o
una colonna di tabella. È possibile usarlo per dichiarare variabili che conterranno
valori di database. Per esempio, diciamo che si ha una colonna chiamata 
<literal>user_id</literal> nella tabella <literal>users</literal>.
Per dichiarare una variabile con lo stesso tipo di dato di 
<literal>users.user_id</literal> scrivere:

<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <para>
Usando <literal>%TYPE</literal> non si ha bisogno di conoscere il tipo di dato 
della struttura a cui ci si riferisce, e più importante, 
se il tipo di dato dell'elemento riferito in futuro cambia (per esempio:
si cambia il tipo di <literal>user_id</literal>
da <type>integer</type> a <type>real</type>), non ci sarà bisogno di 
cambiare la definizione di funzione.
   </para>

   <para>
<literal>%TYPE</literal> è particolarmente utile in funzioni polimorfiche,
dato che i tipi di dato necessari per le variabili interne possono 
cambiare da una chiamata alla successiva. Variabili appropriate possono essere
create applicando <literal>%TYPE</literal> agli argomenti della funzione 
o agli argomenti del risultato.
   </para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
     <title>Tipi riga</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

   <para>
Una variabile di un tipo composto viene chiamata variabile <firstterm>row</firstterm>
(o variabile <firstterm>tipo riga</firstterm>). Tale variabile 
può contenere una riga intera del risultato di una query <command>SELECT</command> o <command>FOR</command>,
a patto che l'insieme delle colonne della query corrisponda al tipo dichiarato della
variabile.
Si accede ai campi individuali del valore della riga 
usando la solita notazione con il punto, per esempio
<literal>rowvar.field</literal>.
   </para>

   <para>
Una variabile riga può essere dichiarata per avere lo stesso tipo delle righe 
di una tabella o vista esistente, usando la notazione
<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
o può essere dichiarata fornendo un nome di tipo composto.
(Dato che ogni tabella ha un tipo composto associato dello stesso nome,
attualmente in <productname>PostgreSQL</productname> non importa se si scrive 
<literal>%ROWTYPE</literal> o no. Ma la forma con 
<literal>%ROWTYPE</literal> è più portabile).
   </para>

   <para>
I parametri di una funzione possono essere
tipi composti (righe di tabella complete). In tal caso, l'identificatore
corrispondente <literal>$<replaceable>n</replaceable></literal> sarà una variabile riga, e i campi possono 
essere selezionati da essa, per esempio <literal>$1.user_id</literal>.
   </para>

   <para>
Solo le colonne definite dall'utente di una riga di tabella sono accessibili in 
una variabile di tipo riga, non l'OID o altre colonne di sistema (dato che
la riga poteva provenire da una vista). I campi del tipo riga ereditano 
la dimensione e la precisione dei campi della tabella per i tipi di dato come
<type>char(<replaceable>n</replaceable>)</type>.
   </para>

   <para>
Ecco un esempio dell'utilizzo di tipi composti. <structname>table1</structname>
e <structname>table2</structname> sono tabelle esistenti aventi almeno i campi 
menzionati:

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEgin
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
   <title>Tipi record</title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <para>
Le variabili record sono simili alle variabili di tipo riga, ma non hanno 
strutture predefinite. Esse si preoccupano dell'effettiva struttura della 
riga a cui sono assegnate durante un comando  <command>SELECT</command> o <command>FOR</command>. La sottostruttura 
di una variabile record può cambiare ogni volta che viene assegnata.
Una conseguenza di questo è che finchè una variabile record non è assegnata, 
non ha sottostrutture, e qualsiasi tentativo di accedere ad un campo
in essa genera un errore in fase di esecuzione.
   </para>

   <para>
Notare che <literal>RECORD</literal> non è un vero tipo di dato, solo un segnaposto.
Ci si dovrebbe rendere conto che quando una funzione <application>PL/pgSQL</application>
viene dichiarata per ritornare un tipo <type>record</type>, non è esattamente lo stesso concetto di
una variabile record, anche se tale funzuione potrebbe 
usare una variabile recordo per contenere il suo risultato. In emtrambi i casi la struttura effettiva della riga
è sconosciuta quando viene scritta la funzione, ma per una funzione 
che ritorna <type>record</type> l'effettiva struttura viene determinata quando viene fatto il parsing della
query chiamante, mentre una variabile record può cambiare la sua struttura di riga al volo. 
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
  <title>Espressioni</title>

    <para>
Tutte le espressioni usate in istruzioni <application>PL/pgSQL</application>
sono elaborate usando l'esecutore <acronym>SQL</acronym> principale 
del server. Per esempio, quando si scrive 
un'istruzione <application>PL/pgSQL</application> tipo
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
<application>PL/pgSQL</application> valuterà l'espressione fornendo una query 
tipo
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
al motore SQL principale. Mentre forma il comando <command>SELECT</command>,
qualsiasi occorrenza di nomi di bariabile <application>PL/pgSQL</application>
viene sostituita da parametri, come discusso in dettaglio in 
<xref linkend="plpgsql-var-subst"/>.
Questo permette al pianificatore di query per la <command>SELECT</command> di
essere preparata sono una volta e quindi riusata per 
successive valutazioni con valori diversi delle variabili. Così, quello 
che realmente accade al primo utilizzo di una espressione è essenzialmente un comando 
<command>PREPARE</command>. Per esempio, se si sono dichiarate
due variabili intere <literal>x</literal> e <literal>y</literal>, e si scrive
<programlisting>
IF x &lt; y THEN ...
</programlisting>
Quello che succede dietro le quinte è equivalente a 
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
quindi questa istruzione preparata viene eseguita (<command>EXECUTE</command>) per ogni
esecuzione dell'istruzione <command>IF</command>, con i valori correnti
delle variabili <application>PL/pgSQL</application> forniti come 
valori dei parametri.
Il piano di query preparato in questo modo viene salvato per la durata della connessione al database,
come descritto in 
<xref linkend="plpgsql-plan-caching"/>. Normalmente, questi dettagli non sono 
importanti per un utente <application>PL/pgSQL</application>, ma 
sono utili da sapere quando si tenta di diagnosticare un problema.
    </para>
  </sect1>

  <sect1 id="plpgsql-statements">
  <title>Istruzioni di base</title>

   <para>
In questa sezione e nelle seguenti, descriveremo tutti i tipi di istruzione
che sono implicitamente compresi da 
<application>PL/pgSQL</application>.
Qualsiasi cosa non riconosciuta come uno si questi tipi di istruzione è supposta 
essere un comando SQL ed è spedita al motore principale del database per essere eseguita,
come descritto in <xref linkend="plpgsql-statements-sql-noresult"/>
e <xref linkend="plpgsql-statements-sql-onerow"/>.
   </para>

   <sect2 id="plpgsql-statements-assignment">
    <title>Assegnazione</title>

    <para>
Un'assegnazione di un valore a una variabile <application>PL/pgSQL</application>
è scritta come:
<synopsis>
<replaceable>variable</replaceable> := <replaceable>expression</replaceable>;
</synopsis>
     As explained previously, the expression in such a statement is evaluated
     by means of an SQL <command>SELECT</command> command sent to the main
     database engine.  The expression must yield a single value (possibly
     a row value, if the variable is a row or record variable).  The target
     variable can be a simple variable (optionally qualified with a block
     name), a field of a row or record variable, or an element of an array
     that is a simple variable or field.
    </para>

    <para>
Se il tipo di dato risultante dell'espressione non corrisponde al tipo di dato 
della variabile, o la variabile ha una dimensione/precisione specifica
(tipo <type>char(20)</type>), il valore del risultato sarà implicitamente
convertito dall'interprete <application>PL/pgSQL</application> usando 
la funzione output del tipo del risultato e 
la funzione input del tipo della variabile. Si noti che questo risulta in potenziali 
errori in fase di esecuzione generati dalla funzioni di input, se la forma della stringa
del valore del risultato non è accettabile per la funzione di input.
    </para>

    <para>
Esempi:
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
    <title>Eseguire un comando senza risultato</title>

    <para>
Per qualsiasi comando SQL che non restituisce righe, per 
esempio <command>INSERT</command> senza una clausola <literal>RETURNING</literal>, 
è possibile eseguire il comando all'interno di una funzione  <application>PL/pgSQL</application>
semplicemente scrivendo il comando.
    </para>

    <para>
Qualsiasi nome di variabile <application>PL/pgSQL</application> che appare
nel testo del comando viene trattato come parametro, e quindi il valore corrente
della variabile viene fornito come il valore del parametro in fase
di esecuzione. Questo è esattamente come l'elaborazione descritta precedentemente
per le espressioni; per i dettagli si veda <xref linkend="plpgsql-var-subst"/>.
    </para>

    <para>
Quando si esegue un comando SQL in questo modo,
<application>PL/pgSQL</application> pianifica il comando solo una volta 
e riusa il piano per successive esecuzioni, fino alla fine della 
connessione al database. Le implicazioni di questo sono discusse
in dettaglio in <xref linkend="plpgsql-plan-caching"/>.
    </para>

    <para>
A volte è utile valutare un'espressione i una query <command>SELECT</command>
ma scartare il risultato, per esempio quando si chiama una funzione
che ha effetti collaterali ma non un risultato utile. Per fare questo
in <application>PL/pgSQL</application>, usare l'istruzione 
<command>PERFORM</command>:

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

Questo esegue  <replaceable>query</replaceable> e scarta il risultato.
Scrivere la <replaceable>query</replaceable> allo stesso modo di come
si scriverebbe un comando SQL <command>SELECT</command>, ma sostituire la parola 
chiave iniziale <command>SELECT</command> con <command>PERFORM</command>.
Le variabili <application>PL/pgSQL</application> saranno
sostituiti nella query esattamente come per i comandi che non restituiscono risultati,
e il piano viene sottoposto a cache nello stesso modo. Inoltre, la variabile speciale 
<literal>FOUND</literal> viene impostata a true se la query ha prodotto almeno 
una riga, o false se non ha prodotto righe (si veda 
<xref linkend="plpgsql-statements-diagnostics"/>).
    </para>

    <note>
     <para>
Ci si potrebbe aspettare che scrivere direttamente <command>SELECT</command>
avrebbe questo risultato, ma al momento l'unico modo accettato 
per farlo è 
<command>PERFORM</command>. Un comando SQL che può restituire righe, 
tipo un <command>SELECT</command>, sarà rifiutato come errore
finchè non ha una clausola <literal>INTO</literal> come discusso nella prossima sezione.
     </para>
    </note>

    <para>
     An example:
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
    <title>Eseguire una query con un risultato di una singola riga</title>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
Il risultato di una comando SQL che genera una singola riga (possibilmente di molteplici colonne)
può essere assegnato a una variabile record, tipo riga, o elenco di variabili scalari.
Questo viene fatto scrivendo il comando SQL di base e aggiungendo una 
clausola <literal>INTO</literal>. Per esempio,

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

dove <replaceable>target</replaceable> può essere una variabile record, una variabile riga,
o un elenco separato da virgole di variabili semplici e 
campi record/riga.
Le variabili <application>PL/pgSQL</application> saranno sostituite 
nel resto della query, e il piano viene sottoposto a cache,
esattamente come descritto sopra per comandi che non ritornano righe.
Questo funziona per <command>SELECT</command>,
<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> con 
<literal>RETURNING</literal>, e comandi di utilità che restituiscono risultati insieme di righe
(come <command>EXPLAIN</command>).
Ad eccezione della clausola <literal>INTO</literal>, il comando SQL è lo stesso  
di come sarebbe scritto fuori da <application>PL/pgSQL</application>.
    </para>

   <tip>
    <para>
Si noti che questa interpretazione di <command>SELECT</command> con <literal>INTO</literal>
è abbastanza diversa dal normale comando <command>SELECT INTO</command> 
di <productname>PostgreSQL</productname>, in cui il target di <literal>INTO</literal>
e una tabella creata ex-novo. Se si vuole creare una tabella dal risultato di una
<command>SELECT</command> all'interno di una funzione <application>PL/pgSQL</application>,
usare la sintassi
<command>CREATE TABLE ... AS SELECT</command>.
    </para>
   </tip>

    <para>
Se una riga o un elenco di variabili è usato come target, le colonne risultanti della query 
devono corrispondere esattamente alla struttura del target come numero e tipi di dato,
altrimenti si genera un errore in fase di esecuzione. 
Quando una variabile record è il target, essa automaticamente configura sè stessa 
al tipo riga delle colonne del risultato della query.
    </para>

    <para>
La clausola <literal>INTO</literal> può apparire quasi ovunque nel comando   
SQL. Di norma è scritta o appena prima o appena dopo    
l'elenco di <replaceable>select_expressions</replaceable> in un comando 
<command>SELECT</command>, o alla fine del comando per altri tipi di comando. 
Si raccomanda di seguire questa convenzione nel caso 
che il parser di <application>PL/pgSQL</application> diventi 
più rigido in versioni future.
    </para>

    <para>
Se <literal>STRICT</literal> non è specificato nella clausola <literal>INTO</literal>,
allora <replaceable>target</replaceable> sarà impostato alla prima 
riga restituita dalla query, o a null se la query non ha restituito righe.
(Notare che <quote>la prima riga</quote> non è
ben definita a meno che non si sia usato <literal>ORDER BY</literal>). Ogni riga risultante 
dopo la prima viene scartata.
Si può controllare la variabile speciale <literal>FOUND</literal> (si veda 
<xref linkend="plpgsql-statements-diagnostics"/>) per
determinare se una riga è stata restituita:

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

Se l'opzione <literal>STRICT</literal> è specificata, la query deve
ritornare esattamente una riga o sarà riportato un errore al momento dell'esecuzione, 
o <literal>NO_DATA_FOUND</literal> (nessusa riga) o <literal>TOO_MANY_ROWS</literal>
(più di una riga). Si può usare un blocco eccezione se si desidera intercettare 
l'errore, per esempio:

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
L'esecuzione con successo di un comando con <literal>STRICT</literal> 
imposta sempre <literal>FOUND</literal> a true. 
    </para>

    <para>
Per <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> con 
<literal>RETURNING</literal>, <application>PL/pgSQL</application> riporta un errore
per più di una riga restituita, anche quando 
<literal>STRICT</literal> non è specificato. Questo perchè non c'è un opzione tipo  
la <literal>ORDER BY</literal> con la quale determinare  
quali righe coinvolte dovrebbero essere restituite.
    </para>

    <note>
     <para>
L'opzione <literal>STRICT</literal> corrisponde al comportamento di  
del comando Oracle PL/SQL <command>SELECT INTO</command> e relative istruzioni.
     </para>
    </note>

    <para>
Per gestire casi dove si ha bisogno di elaborare moltpeplici righe risultanti da una query SQL,
si veda <xref linkend="plpgsql-records-iterating"/>.
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
    <title>Eseguire comandi dinamici</title>

    <para>
Spesso si vorrà generare comandi dinamici all'interno delle funzioni
<application>PL/pgSQL</application>, cioè, comandi 
che coinvolgeranno differenti tabelle o diversi tipi di dato ogni volta che sono 
vengono eseguiti. I normali tentativi di  <application>PL/pgSQL</application> 
di sottoporre a cache i piani per i comandi (come discusso in
<xref linkend="plpgsql-plan-caching"/>) non funzioneranno in queste
situazioni. Per gestire questa sorta di problemi, è disponibile 
l'istruzione <command>EXECUTE</command>:

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

dove <replaceable>command-string</replaceable>  è un'espressione
che genera una stringa (di tipo <type>text</type>) contenente il comando  
che deve essere eseguito. L'opzionale <replaceable>target</replaceable>
è una variabile record, una variabile riga, o un elenco separato da virgole di 
semplici variabili e campi di riga/record, nei quali i risultati del 
comando saranno salavti. Le espressioni <literal>USING</literal> opzionali  
forniscono valori da essere inseriti nel comando.
    </para>

    <para>
     No substitution of <application>PL/pgSQL</application> variables is done on the
     computed command string.  Any required variable values must be inserted
     in the command string as it is constructed; or you can use parameters
     as described below.
    </para>

    <para>
Inoltre, il piano non viene sottoposto a cache per comandi eseguiti attraverso
<command>EXECUTE</command>. Invece, il comando 
viene preparato ogni volta che l'istruzione è eseguita. Così la stringa comando 
può essere creata dinamicamente all'interno della funzione per eseguire azioni 
su diverse tabelle e colonne.
    </para>

    <para>
La clausola <literal>INTO</literal> specifica dove dovrebbero essere assegnati 
i risultati di un comando SQL che restituisce righe. Se viene fornita  una riga
o elenco variabile, deve corrispondere esattamente la struttura 
dei risultati della query (quando è usata una 
variabile record, essa configurerà automaticamente sè stessa per corrispondere  
la struttura del risultato). Se vengono restituite molteplici righe, 
solo la prima sarà assegnata alla variabile <literal>INTO</literal>.
Se non sono restituite righe, alla variabile/i NULL viene assegnato NULL.
Se non è specificata la clausola <literal>INTO</literal>,
i risultati della query vengono scartati.
    </para>

    <para>
Se viene fornita l'opzione <literal>STRICT</literal>, viene riportato un errore  
finchè la query esattamente una riga.
    </para>

    <para>
La stringa del comando può usare valori parametro, che sono referenziati 
nel comando come <literal>$1</literal>, <literal>$2</literal>, ecc.
Questi simboli si riferiscono a valori forniti nella clausola  <literal>USING</literal>
Questo metodo spesso è preferibile per inserire valori di dati 
nella stringa comando come testo: elimina overhead in fase di esecuzione convertendo
i valori a testo e viceversa, ed è molto meno soggetta a attacchi di tipo SQL.injection
dato che non c'è necessità di effettuare il quoting o l'escaping.
Un esempio è:
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    <para>
Notare che i simboli parametro possono essere usati solo per valori di dati -
se si vogliono usare nomi di tabelle o colonne determinati dinamicamente,
si devono inserire testualmente nella stringa comando.
Per esempio, se la precedente query necessitava di essere fatta su una tabella 
selezionata dinamicamente, si potrebbe fare così:
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || tabname::regclass
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
Un'altra restrizione sui simboli parametro è che funzionano solo in comandi
<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, e
<command>DELETE</command>. In altri tipi di  istruzione
(chiamate genericamente istruzioni d'ulitità), si devono inserire 
i valori testualmente anche se sono solamente valori di dati.
    </para>

    <para>
     An <command>EXECUTE</command> with a simple constant command string and some 
     <literal>USING</literal> parameters, as in the first example above, is
     functionally equivalent to just writing the command directly in
     <application>PL/pgSQL</application> and allowing replacement of
     <application>PL/pgSQL</application> variables to happen automatically.
     The important difference is that <command>EXECUTE</command> will re-plan
     the command on each execution, generating a plan that is specific
     to the current parameter values; whereas
     <application>PL/pgSQL</application> normally creates a generic plan
     and caches it for re-use.  In situations where the best plan depends
     strongly on the parameter values, <command>EXECUTE</command> can be
     significantly faster; while when the plan is not sensitive to parameter
     values, re-planning will be a waste.
    </para>

    <para>
<command>SELECT INTO</command> attualmente non è supportato all'interno di 
<command>EXECUTE</command>; invece, eseguire un semplice comando <command>SELECT</command>
e specificare <literal>INTO</literal> come parte dell'<command>EXECUTE</command>
stesso.
    </para>

   <note>
    <para>
L'istruzione <command>EXECUTE</command> di <application>PL/pgSQL</application>
non è correlata con la funzione SQL 
<xref linkend="sql-execute"/> supportata
dal server <productname>PostgreSQL</productname>. La funzione <command>EXECUTE</command>
del server non può essere usata direttamente all'interno di funzioni
<application>PL/pgSQL</application> (e non è necessaria). 
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
   <title>Quotare valori in query dinamiche</title>

    <indexterm>
     <primary>quote_ident</primary>
     <secondary>uso in PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
     <secondary>uso in PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>uso in PL/PgSQL</secondary>
    </indexterm>

    <para>
Quando si lavora con comandi dinamici spesso di dovrà gestire l'escape di 
apici singoli. Il metodo raccomandato per quotare testo fisso nel corpo di una funziona 
è il quoting con dollari. (Se si ha codice datato che non usa  
la quotazione con dollari, si prega di riferirsi alla panoramica 
in <xref linkend="plpgsql-quote-tips"/>, che può far risprmiare qualche sforzo  
quando si traduce tale codice a uno schema più ragionevole).
    </para>

    <para>
Valori dinamici che devono essere iseriti nella query costruita  
richiedono una gestione attenta dato che potrebbero contenere 
caratteri apice.
Un esempio (quato assume che si stia usando la quotazione con dollari per l'intera
funzione, così gli apici non necessitano di essere raddoppiati):
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

    <para>
Questo esempio dimostra l'utilizzo delle funzioni 
<function>quote_ident</function> e
<function>quote_literal</function> (si veda <xref
linkend="functions-string"/>). Per sicurezza, espressioni contenenti identificatori 
di colonna o tabella dovrebbero essere passati attraverso
<function>quote_ident</function>  prima dell'inserimento in una query dinamica.
Espressioni contenenti valori che dovrebbero essere stringhe letterali nel comando 
costruito dovrebbero essere passate attraverso <function>quote_literal</function>.
Queste funzioni eseguono i passi appropriati a restituire il testo in input  
racchiuso rispettivamente tra apici doppi o singoli, con qualsiasi carattere speciale incluso
sottoposto a appropriatamente a  escape.
    </para>

    <para>
Dato che <function>quote_literal</function> è etichettata come 
<literal>STRICT</literal>, restituirà sempre null quando chiamata con un argomento null.
Nell'esempio sopra, se <literal>newvalue</literal> o 
<literal>keyvalue</literal> erano null, l'intera stringa di query dinamica diventerebbe null, 
generando un errore da <command>EXECUTE</command>.
È possibile evitare questo problema usando la funzione <function>quote_nullable</function>,
che lavora allo stesso modi di <function>quote_literal</function> ad accezione che 
quando chiamata con un argomento null restituisce la stringa <literal>NULL</literal>.
Per esempio,
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
Se si stanno trattando valori che potrebbero essere null, si dovrebbe di solito
usare <function>quote_nullable</function> al posto di <function>quote_literal</function>.
    </para>

    <para>
Come al solito, dev'essere posta attenzione che i valori null in una query
non portino a risultati non voluti. 
Per esempio la clausola <literal>WHERE</literal>
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
non avrà mai successo se <literal>keyvalue</literal> è null, dato che
il risultato di usare l'operatore uguale <literal>=</literal> con un operando null
è sempre null. Se si desidera che null funzioni come un valore chiave normale,
si dovrà riscrivere il sopra come
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
(Al momento, <literal>IS NOT DISTINCT FROM</literal> viene gestito molto meno
efficientemente di <literal>=</literal>, quindi non farlo a meno che non si debba.
Si veda <xref linkend="functions-comparison"/> per 
maggiori informazioni sui null e <literal>IS DISTINCT</literal>).
    </para>

    <para>
Notare che la quitazione con dollari è utile solo per quotare testo fisso.
Sarebbe una cattiva idea provare a scrivere questo esempio come:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     because it would break if the contents of <literal>newvalue</literal>
     happened to contain <literal>$$</literal>.  The same objection would
     apply to any other dollar-quoting delimiter you might pick.
     So, to safely quote text that is not known in advance, you
     <emphasis>must</emphasis> use <function>quote_literal</function>,
     <function>quote_nullable</function>, or <function>quote_ident</function>, as appropriate.
    </para>
   </example>

    <para>
Un esempio più vasto di comando dinamico e 
<command>EXECUTE</command> si trova in <xref
linkend="plpgsql-porting-ex2"/>, che costruisce ed esegue un comando
<command>CREATE FUNCTION</command> per definire una nuova funzione.
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
    <title>Ottenere lo stato del risultato</title>

    <para>
Ci sono diversi modi di determinare l'effetto di un comando. Il primo metodo 
è di usare il comando <command>GET DIAGNOSTICS</command>,
che ha la forma:

<synopsis>
GET DIAGNOSTICS <replaceable>variable</replaceable> = <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

Questo comando permettere il recupero di indicatori dello stato del sistema. Ogni
<replaceable>item</replaceable> è una parola chiave che identifica il valore di uno stato
da assegnare alla specifica variabile (che dovrebbe essere del giusto tipo per
riceverlo). Gli elementi di stato attualmente disponibili sono <varname>ROW_COUNT</varname>, 
il numero di righe elaborate dall'ultimo comando <acronym>SQL</acronym> 
mandato al motore <acronym>SQL</acronym>, e <varname>RESULT_OID</varname>,
l'OID dell'ultima riga inserita dal più recente
comando <acronym>SQL</acronym>. Notare che <varname>RESULT_OID</varname>
è utile solo dopo un comando <command>INSERT</command> in una tabella contenente
OID.
    </para>

    <para>
Un esempio:
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>

    <para>
Il secondo metodo per determinare gli effetti di un comando è di controllare 
la variabile speciale chiamata <literal>FOUND</literal>, che è di tipo
<type>boolean</type>.  <literal>FOUND</literal> all'inizio è
false all'interno di ogni chiamata di funzione <application>PL/pgSQL</application>.
È impostata da ognuno dei seguenti tipi di istruzione:

         <itemizedlist>
          <listitem>
           <para>
Un'istruzione <command>SELECT INTO</command> imposta 
<literal>FOUND</literal> a true se una riga viene assegnata, 
false se non viene restituita nessuna riga.
           </para>
          </listitem>
          <listitem>
           <para>
Un'istruzione <command>PERFORM</command> imposta <literal>FOUND</literal>
a true se produce (e scarta) una o più righe, false se non vengono prodotte righe.
           </para>
          </listitem>
          <listitem>
           <para>
Le istruzioni <command>UPDATE</command>, <command>INSERT</command>, e <command>DELETE</command>
impostano <literal>FOUND</literal> a true se almeno una riga è coinvolta, 
false se nessuna riga è interessata.
           </para>
          </listitem>
          <listitem>
           <para>
Un'istruzione <command>FETCH</command> imposta <literal>FOUND</literal>
a true se restituisce una riga, false se non viene restituita nessuna riga.
           </para>
          </listitem>
          <listitem>
           <para>
Un'istruzione <command>MOVE</command> imposta <literal>FOUND</literal> a true
se riposiziona con successo il cursore, altrimenti false.
           </para>
          </listitem>

          <listitem>
           <para>
Un'istruzione <command>FOR</command> imposta <literal>FOUND</literal> a true
se itera una o più volte, altrimenti false. Questo si applica a tutte le quattro varianti di 
dell'istruzione <command>FOR</command> (cicli <command>FOR</command> di interi, 
cicli <command>FOR</command> di insiemi di record, cicli <command>FOR</command> di
insiemi di record dinamici e cicli <command>FOR</command> di cursori).
<literal>FOUND</literal> è impostato in questo modo quando 
il ciclo <command>FOR</command> esiste; all'interno dell'esecuzione del loop,
<literal>FOUND</literal> non viene modificato dall'istruzione 
<command>FOR</command>, sebbene potrebbe essere cambiato dall'esecuzione
di altre istruzioni all'interno del corpo del ciclo.
           </para>
          </listitem>
          <listitem>
           <para>
Le istruzioni <command>RETURN QUERY</command> e <command>RETURN QUERY
EXECUTE</command> impostano <literal>FOUND</literal>
a true se la query restituisce almeno una riga, false se non viene restituita nessuna riga.
           </para>
          </listitem>
         </itemizedlist>

Altre istruzioni <application>PL/pgSQL</application> non camnbiano
lo stato di <literal>FOUND</literal>.
Notare in particolare che <command>EXECUTE</command> cambia l'output
di <command>GET DIAGNOSTICS</command>, ma non cambia 
<literal>FOUND</literal>.
    </para>

    <para>
<literal>FOUND</literal> è una variabile locale all'interno di ogni 
funzione <application>PL/pgSQL</application>; qualsiasi cambiamento di essa
interessa solo la funzione corrente.
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
    <title>Non fare assolutamente niente</title>

    <para>
A volte è utile un'istruzione "segnaposto" che non faccia niente.
Per esempio, potrebbe indicare che un anello della catena if/then/else
è deliberatamente vuoto. Per questo scopo, usare l'istruzione
<command>NULL</command>:

<synopsis>
NULL;
</synopsis>
    </para>

    <para>
Per esempio, i seguenti due frammenti di codice sono equivalenti:
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- ignorare l'errore
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- ignorare l'errore
END;
</programlisting>
Quale sia preferibile è una questione di gusti.
    </para>

    <note>
     <para>
In  PL/SQL di Oracle, elenchi di istruzione vuoti non sono permessi, e quindi 
le istruzioni <command>NULL</command> sono <emphasis>richieste</emphasis> per situazioni
come questa. <application>PL/pgSQL</application> invece permette di non scrivere niente.
     </para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
   <title>Strutture di controllo</title>

   <para>
Le strutture di controllo sono probabilmente la parte più utile (e
importante) di <application>PL/pgSQL</application>. Con le
strutture di controllo di <application>PL/pgSQL</application>,
è possibile manipolare i dati di <productname>PostgreSQL</productname>
in modo molto flessibile e potente.
   </para>

   <sect2 id="plpgsql-statements-returning">
    <title>Ritorno da una funzione</title>

    <para>
Ci sono due comandi disponibili che permettono di restituire dati 
da una funzione: <command>RETURN</command> e <command>RETURN
NEXT</command>.
    </para>

    <sect3>
     <title><command>RETURN</command></title>

<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <para>
<command>RETURN</command> con un'espressione termina la funzione
e ritorna il valore di 
<replaceable>expression</replaceable> al chiamante. Questa forma è usata 
per funzioni <application>PL/pgSQL</application> che non restituiscono un
insieme.
     </para>

     <para>
Quando si restituisce un tipo scalare, può essere usata qualsiasi espressione. 
Il risultato dell'espressione sarà automaticamente convertito al tipo di 
ritorno della funzione come descritto per le assegnazioni. Per restituire un valore
composto (riga), si deve scrivere una variabile record o riga
come <replaceable>expression</replaceable>.
     </para>

     <para>
Se si dichiara la funzione con parametri di output, scrivere solo
<command>RETURN</command> senza espressione. Saranno restituiti i 
valori attuali dei parametri di 
output. 
     </para>

     <para>
Se si dichiara la funzione per ritornare <type>void</type>, un'istruzione
<command>RETURN</command> può essere usata per uscire dalla funzione
in anticipo; ma non scrivere un espressione dopo 
<command>RETURN</command>.
     </para>

     <para>
Il valore di ritorno di una funzione non può essere lasciato indefinito. Se
il controllo raggiunge la fine del blocco superiore della funzione
senza incontrare un'istruzione <command>RETURN</command>, viene generato un errore
in fase di esecuzione. Questa restrizione comunque non si applica a funzioni
con parametri di output e funzioni che restituiscono <type>void</type>.
In quei casi un'istruzione <command>RETURN</command> viene eseguita automaticamente 
quando il blocco superiore finisce.
     </para>
    </sect3>

    <sect3>
     <title><command>RETURN NEXT</command> e <command>RETURN QUERY</command></title>
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/PgSQL</secondary>
    </indexterm>
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/PgSQL</secondary>
    </indexterm>

<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     <para>
Quando una funzione <application>PL/pgSQL</application> viene dichiarata per restituire
<literal>SETOF <replaceable>sometype</replaceable></literal>, la procedura
da seguire e leggermente diversa. In quel caso, gli elementi individuali 
da restituire sono specificati da una sequenza di comandi <command>RETURN
NEXT</command> o <command>RETURN QUERY</command>, e 
quindi un comando <command>RETURN</command> finale senza argomenti
viene usato epr indicare che la funzione ha terminato l'esecuzione.
<command>RETURN NEXT</command> può essere usato sia con tipi di dato scalari che composti;
con un tipo di risultato composto, sarà restituita un'intera <quote>table</quote>.
<command>RETURN QUERY</command> aggiunge i risultati dell'esecuzione di una query
all'insieme dei risultati della funzione. <command>RETURN
NEXT</command> e <command>RETURN QUERY</command> possono essere liberamente
interscambiati in una singola funzione che ritorna un insieme, nel qual caso 
i loro risultati saranno concatenati.
     </para>

     <para>
<command>RETURN NEXT</command> e <command>RETURN
QUERY</command> in realtà non ritornano dalla funzione -
semplicemente aggiungono zero o più righe al risultato di una funzione.
L'esecuzione quindi continua con la prossima istruzione nella funzione 
<application>PL/pgSQL</application>. Come vengono eseguiti successivi
comandi <command>RETURN NEXT</command> o <command>RETURN
QUERY</command>, l'insieme risultato è formato.
Un <command>RETURN</command> finale, che non dovrebbe avere argomenti,
causa che il controllo esca dalla funzione (o è possibile
lasciare che il controllo raggiunga la fine della funzione).
     </para>

     <para>
<command>RETURN QUERY</command> ha una variante 
<command>RETURN QUERY EXECUTE</command>, che specifica che la query sia 
eseguita dinamicamente. Espressioni di parametro possono essere inserite 
nella stringa calcolata della query attraverso <literal>USING</literal>,
nello stesso modo del comando <command>EXECUTE</command>.
     </para>

     <para>
Se si è dichiarata la funzione senza parametri di output, scrivere
solo <command>RETURN NEXT</command>  senza espressione. Ad ogni esecuzione,  
i valori correnti della variabile/i parametro di output saranno salvati 
per l'eventuale ritorno come riga del risultato.
Si noti che si deve dichiarare la funzione in modo che ritorni  
<literal>SETOF record</literal> quando ci sono molteplici parametri di output, 
o <literal>SETOF <replaceable>sometype</replaceable></literal>
quando c'è sono un parametro di output di tipo
<replaceable>sometype</replaceable>, per creare una funzione che restituisce un insieme 
con parametri di output.
     </para>

     <para>
Ecco un esempio di una funzione che usa  <command>RETURN
NEXT</command>:

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION getAllFoo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEgin
    FOR r IN SELECT * FROM foo
    WHERE fooid &gt; 0
    LOOP
        -- qui è possibile fare elaborazioni
        RETURN NEXT r; -- restituisce la riga corrente della SELECT
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE 'plpgsql' ;

SELECT * FROM getallfoo();
</programlisting>
     </para>

     <note>
      <para>
L'implementazione corrente di <command>RETURN NEXT</command>
e <command>RETURN QUERY</command> salva l'intero insieme dei risultati  
prima di ritornare dalla funzione, come discusso sopra. Questo significa
che se una funzione <application>PL/pgSQL</application> produce un insieme di risultati molto grande,
le prestazioni potrebbero risentirne: i dati saranno scritti su disco
per evitare l'esaurimento della memoria, ma la funzione 
stessa non ritornerà finchè l'intero insieme dei risultati sia
stato generato. Una versione futura di <application>PL/pgSQL</application> potrebbe
permettere agli utenti di definire funzioni che ritornano insiemi 
che non hanno questa limitazione. Attualmente, il punto in cui i dati 
cominciano ad essere scritti su disco è controllato dalla variabile di configurazione 
<xref linkend="guc-work-mem"/>.
Gli amministratori che hanno memoria sufficiente per immagazzinare 
in memoria grandi insiemi di risultati dovrebbero considerare 
l'incremento di questo parametro.
      </para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-conditionals">
    <title>Condizioni</title>

    <para>
Le istruzioni <command>IF</command> e <command>CASE</command> ti permettono 
di eseguire comandi alternativi in base a certe condizioni.
<application>PL/pgSQL</application> ha tre forme di <command>IF</command>:
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE</literal></para>
     </listitem>
    </itemizedlist>

    e due forme di <command>CASE</command>:
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
Le istruzioni <literal>IF-THEN</literal> sono la forma più semplice di 
<literal>IF</literal>. Le istruzioni tra 
<literal>THEN</literal> e <literal>END IF</literal> saranno
eseguite se la condizione è true.  Altrimenti, vengono 
saltate.
       </para>

       <para>
Esempio:
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
Le istruzioni <literal>IF-THEN-ELSE</literal> si aggiungono a 
<literal>IF-THEN</literal> permettendo di specificare un insieme di istruzioni
alternative che dovrebbero essere eseguite se la condizione 
non è true. (Notare che questo include i casi dove la condizione è valutata
essere NULL).
       </para>

       <para>
Esempi:
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <para>
A volte ci sono più di due sole alternative. 
<literal>IF-THEN-ELSIF</literal> fornisce un metodo conveniente 
di controllare a turno diverse alternative. 
Le condizioni  <literal>IF</literal> sono testate successivamente
finchè la prima che è true viene trovata. Quindi 
l'istruzione/i associate sono eseguite, dopo le quali il controllo
passa alla prossima istruzione dopo <literal>END IF</literal>.
(Ogni successiva condizione <literal>IF</literal> <emphasis>non</emphasis> è testata).
Se nessuna delle condizioni <literal>IF</literal> è true,
allora viene eseguito il blocco <literal>ELSE</literal> (se presente). 
       </para>

       <para>
Ecco un esempio:

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- hmm, l'unica altra possibilità è che il numero sia null
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <para>
La parola chiave <literal>ELSIF</literal> può essere scritta anche
<literal>ELSEIF</literal>.
       </para>

       <para>
Un modo alternativo di svolgere lo stesso compito è di annidare le  istruzioni
<literal>IF-THEN-ELSE</literal>, come nell'esempio seguente:

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <para>
Comunque, questo metodo richiede la scrittura di un corrispondente <literal>END IF</literal>
per ogni <literal>IF</literal>, quindi è molto più scomodo rispetto ad usare
<literal>ELSIF</literal> quando ci sono molte alternative.
       </para>
     </sect3>

     <sect3>
      <title><literal>CASE</literal> semplice</title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
La forma semplice di <command>CASE</command> fornisce l'esecuzione condizionale 
basata sull'uguaglianza di operandi. La <replaceable>search-expression</replaceable>
viene valutata (una volta) e successivamente confrontata con ogni
<replaceable>expression</replaceable> nelle clausole <literal>WHEN</literal>.
Se viene trovata una corrispondenza, allora le corrispondenti 
istruzioni <replaceable>statements</replaceable> sono eseguite, e quindi il controllo
passa all'istruzione successiva dopo <literal>END CASE</literal>.  (Successive 
espressioni <literal>WHEN</literal> non sono valutate). Se non viene trovata nessuna corrispondenza,
vengono eseguite le istruzioni <replaceable>statements</replaceable> <literal>ELSE</literal>;
ma se <literal>ELSE</literal> non è presente, allora viene generata un'eccezione  
<literal>CASE_NOT_FOUND</literal>.
      </para>

      <para>
Ecco un semplice esempio:

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
      <title><literal>CASE</literal> cercato</title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
La forma cercata di <command>CASE</command> fornisce l'esecuzione condizionale
basata sulla verità di espressioni Booleane. Ogni <replaceable>boolean-expression</replaceable>
della clausola <literal>WHEN</literal> viene valutata a turno,
finchè non ne viene trovata una che risulta <literal>true</literal>. Quindi 
le corrispondenti istruzioni <replaceable>statements</replaceable> vengono eseguite, e
poi il controllo passa alla successiva istruzione dopo <literal>END CASE</literal>.
(Successive espressioni <literal>WHEN</literal> non sono valutate).
Se non vengono trovati risultati true, allora vengono eseguite 
le istruzioni <replaceable>statements</replaceable>
<literal>ELSE</literal>;
ma se  <literal>ELSE</literal> non è presente, allora viene generata un'eccezione
<literal>CASE_NOT_FOUND</literal>.
      </para>

      <para>
Ecco un esempio:

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

      <para>
Questa forma di <command>CASE</command> è completamente equivalente a 
<literal>IF-THEN-ELSIF</literal>, ad eccezione della regola per cui raggiungere 
una clausola <literal>ELSE</literal> omessa genera un errore invece di non fare niente.
      </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
    <title>Cicli semplici</title>

    <indexterm zone="plpgsql-control-structures-loops">
     <primary>ciclo</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
Con le istruzioni <literal>LOOP</literal>, <literal>EXIT</literal>,
<literal>CONTINUE</literal>, <literal>WHILE</literal> e <literal>FOR</literal>,
è possibile fare in modo che la funzione <application>PL/pgSQL</application>
ripeta una serie di comandi.
    </para>

    <sect3>
     <title><literal>LOOP</literal></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <para>
<literal>LOOP</literal> definisce un ciclo incondizionato che viene ripetuto 
indefinitzmente finchè terminato da un'istruzione <literal>EXIT</literal> o
<command>RETURN</command>. L'etichetta <replaceable>label</replaceable> opzionale
può essere usata dalle istruzioni <literal>EXIT</literal> e 
<literal>CONTINUE</literal> all'interno di cicli annidati per specificare 
a quale ciclo si riferiscono quelle istruzioni.
     </para>
    </sect3>

     <sect3>
      <title><literal>EXIT</literal></title>

     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
Se nessuna <replaceable>label</replaceable> è fornita, il ciclo 
più interno viene terminato e l'istruzione seguente <literal>END
LOOP</literal> viene eseguita. Se <replaceable>label</replaceable> 
è fornita, deve essere l'etichetta del ciclo annidato o del blocco corrente o esterno.
Quindi il ciclo nominato o il blocco viene terminato 
e il controllo continua con l'istruzione dopo la <literal>END</literal>
corrispondente del ciclo/blocco.
       </para>

       <para>
Se <literal>WHEN</literal> è specificato, l'uscita dal ciclo avviene solo se 
<replaceable>boolean-expression</replaceable> è true. Altrimenti, il controllo passa 
all'istruzione dopo <literal>EXIT</literal>.
       </para>

       <para>
<literal>EXIT</literal> può essere usato con tutti i tipi di ciclo; non è limitato all'utilizzo 
con cicli incondizionali. 
       </para>

       <para>
Quando usato con un blocco
<literal>BEGIN</literal>, <literal>EXIT</literal> passa il controllo
alla successiva istruzione dopo la fine del blocco. 
Notare che una etichetta deve essere usata per questo scopo; una 
<literal>EXIT</literal> senza etichetta non è mai considerata corrispondente a
un blocco <literal>BEGIN</literal>. (Questo è un cambiamento rispetto 
alle versioni precedenti la 8.4 di <productname>PostgreSQL</productname>, che
avrebbero permesso a una <literal>EXIT</literal> senza etichetta di corrispondere a un
blocco <literal>BEGIN</literal>).
       </para>

       <para>
Esempi:
<programlisting>
LOOP
    -- alcuni calcoli
    IF count &gt; 0 THEN
        EXIT;  -- esce dal ciclo
    END IF;
END LOOP;

LOOP
    -- alcuni calcoli
    EXIT WHEN count &gt; 0;  -- stesso risultato dell'esempio precedente
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- alcuni calcoli
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- causa l'uscita dal blocco BEGIN
    END IF;
    -- i calcoli qui saranno saltati quando stocks &gt; 100000
END;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</literal></title>

     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
Se non viene fornita nessuna <replaceable>label</replaceable>, la successiva iterazione 
del ciclo più interno è iniziata. Cioè, tutte le istruzioni restanti
nel corpo del ciclo sono saltate, e il controllo ritorna all'espressione 
di controllo del ciclo (se presente) per determinare se
un'altra iterazione del loop è necessaria.
Se <replaceable>label</replaceable> è presente, specifica  
l'etichetta del ciclo la cui esecuzione sarà continuata.
       </para>

       <para>
Se <literal>WHEN</literal> è specificata, la successiva iterazione del ciclo 
è cominciata solo se <replaceable>boolean-expression</replaceable> è
true. Altrimenti, il controllo passa all'istruzione dopo 
<literal>CONTINUE</literal>.
       </para>

       <para>
<literal>CONTINUE</literal> puù essere usato con tutti i tipi di ciclo; non è 
limitato all'uso con cicli incondizionali.
       </para>

       <para>
Esempi:
<programlisting>
LOOP
    -- alcuni calcoli
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- alcuni calcoli per count IN [50 .. 100]
END LOOP;
</programlisting>
       </para>
     </sect3>


     <sect3>
      <title><literal>WHILE</literal></title>

     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
L'istruzione <literal>WHILE</literal> ripete una sequenza di istruzioni
finchè l'espressione <replaceable>boolean-expression</replaceable>
risulta true. L'espressione è controllata appena prima 
ogni ingresso nel corpo del ciclo.
       </para>

       <para>
Per esempio:
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- alcuni calcoli qui
END LOOP;

WHILE NOT done LOOP
    -- alcuni calcoli qui
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
      <title><literal>FOR</literal> (variante intera)</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
Questa forma di <literal>FOR</literal> crea un ciclo che itera su un intervallo
di valori interi. La variabile 
<replaceable>name</replaceable> viene definita automaticamente come 
tipo  <type>integer</type> ed esiste solo all'interno del ciclo (qualsiasi 
definizione esistente del nome della variabile viene ignorata all'interno del ciclo).
Le due espressioni che forniscono il limite inferiore e superiore dell'intervallo
sono calcolate una volta quando si entra nel ciclo. 
Se la clausola <literal>BY</literal> non è specificata, il passo di iterazione è
1, altrimenti è il valore specificato nella clausola <literal>BY</literal>,
che di nuovo viene clcolato una volta all'ingresso del ciclo.
Se <literal>REVERSE</literal> è specificato allora il valore dell'incremento è 
sottratto, invece che aggiunto, dopo ogni iterazione.
       </para>

       <para>
Alcuni esempi di cicli <literal>FOR</literal> di interi:
<programlisting>
FOR i IN 1..10 LOOP
    -- i assumerà i valori 1,2,3,4,5,6,7,8,9,10 all'interno del ciclo
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- i assumerà i valori 10,9,8,7,6,5,4,3,2,1 all'interno del ciclo
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- i assumerà i valori 10,8,6,4,2 all'interno del ciclo
END LOOP;
</programlisting>
       </para>

       <para>
Se il limite inferiore è maggiore del limite superiore (o minore di,
nel caso di <literal>REVERSE</literal>), il corpo del ciclo non 
viene eseguito. Non viene generato errore.
       </para>

       <para>
Se una etichetta <replaceable>label</replaceable> viene assegnata al ciclo 
<literal>FOR</literal> allora ci si può riferire alla variabile ciclo di interi 
con un nome qualificato, usando quell'etichetta
<replaceable>label</replaceable>.
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
    <title>Cicli attraverso i risultati di una query</title>

    <para>
Usando un tipo diverso di ciclo <literal>FOR</literal>, è possibile iterare attraverso
i risultati di una query e manipolare quei dati 
di conseguenza. La sintassi è:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
Il <replaceable>target</replaceable> è una variabile record, variabile riga, o 
elenco separato da virgole di variabili scalari.
Il <replaceable>target</replaceable> successivamemente è assegnato ad ogni riga 
risultante dalla  <replaceable>query</replaceable> e il corpo del ciclo viene 
eseguito per ogni riga. Ecco un esempio:
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    PERFORM cs_log('Refreshing materialized views...');

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- Adesso "mviews" ha un record da cs_materialized_views

        PERFORM cs_log('Refreshing materialized view '
                   || quote_ident(mviews.mv_name) || ' ...');
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);
        EXECUTE 'INSERT INTO '
                   || quote_ident(mviews.mv_name) || ' '
                   || mviews.mv_query;
    END LOOP;

    PERFORM cs_log('Done refreshing materialized views.');
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

Se il ciclo è terminato da un'istruzione <literal>EXIT</literal>, l'ultimo
valore assegnato della riga è comunque accessibile dopo il ciclo.

    </para>

    <para>
La <replaceable>query</replaceable> usata in questo tipo di istruzione <literal>FOR</literal>
può essere qualsiasi comando SQL che ritorna righe al chiamante:
<command>SELECT</command> è il caso più comune, 
ma si possono usare anche <command>INSERT</command>, <command>UPDATE</command>, o
<command>DELETE</command> con una clausola <literal>RETURNING</literal>. 
Funzioneranno anche alcuni comandi di utilità
tipo <command>EXPLAIN</command>. 
    </para>

    <para>
Le variabili <application>PL/pgSQL</application> sono sostituiti nel testo della query,
e il piano della query è sottoposto a cache per un possibile riutilizzo, come discusso in
dettaglio in <xref linkend="plpgsql-var-subst"/> e
<xref linkend="plpgsql-plan-caching"/>.
    </para>

    <para>
L'istruzione <literal>FOR-IN-EXECUTE</literal> rappresenta un altro modo di iterare 
le righe:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
Questo è simile alla forma precedente, ad eccezione che la query sorgente 
viene specificata come una espressione stringa, che è calcolata e ripianificata 
ad ogni voce del ciclo <literal>FOR</literal>. Questo permette al programmatore di 
scegliere la velocità di una query prepianificata o la flessibilità di una query dinamica, 
proprio come con una normale istruzione  <command>EXECUTE</command>.
Come con <command>EXECUTE</command>, i valori dei parametri possono essere inseriti 
nel comando dinamico con <literal>USING</literal>.
    </para>

    <para>
Un altro modo di specificare la query i cui risultati dovrebbero essere iterati
è di dichiararla come cursore. Questo è descritto in
<xref linkend="plpgsql-cursor-for-loop"/>.
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
    <title>Trapping Errors</title>

    <indexterm>
     <primary>eccezioni</primary>
     <secondary>in PL/PgSQL</secondary>
    </indexterm>

    <para>
In maniera predefinitia, qualsiasi errore accada in una funzione <application>PL/pgSQL</application>
annulla l'esecuzione della funzione, ed effettivamente anche la transazione circostante. 
È possibile intrappolare gli errori e ripristinarli usando un blocco <command>BEGIN</command> 
con una clausola <literal>EXCEPTION</literal>. La sintassi è una  estensione 
della sintassi normale di un blocco <command>BEGIN</command>:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>

    <para>
Se non si verificano errori, questa forma di blocco semplicemente esegue tutte le
istruzioni <replaceable>statements</replaceable>, e quindi il controllo passa
alla successiva istruzione dopo <literal>END</literal>. Ma se un errore
accade all'interno di <replaceable>statements</replaceable>, l'ulteriore elaborazione
di istruzioni <replaceable>statements</replaceable> viene abbandonata,
e il controllo passa all'elenco <literal>EXCEPTION</literal>.
L'elenco viene cercato per la prima <replaceable>condition</replaceable>
corrispondente all'errore accaduto. Se viene trovata una corrispondenza, 
vengono eseguite le corrispondenti istruzioni <replaceable>handler_statements</replaceable>,
e quindi il controllo passa alla successiva istruzione dopo 
<literal>END</literal>. Se non vengono trovate corrispondenze, l'errore si propaga  
sebbene la clausola <literal>EXCEPTION</literal> non ci fosse stata:
l'errore può essere catturato da un blocco con <literal>EXCEPTION</literal>,
o se non ce ne sono esso annulla l'elaborazione della funzione.
    </para>

    <para>
I nomi delle condizioni <replaceable>condition</replaceable> possono essere 
qualsiasi di quelli mostrati in <xref linkend="errcodes-appendix"/>. Un nome di categoria
corrisponde a qualsiasi errore all'interno della sua categoria. Il nome della condizione speciale
<literal>OTHERS</literal> corrisponde ad ogni tipo di errore ad eccezione di 
<literal>QUERY_CANCELED</literal>.  (È possibile, ma spesso imprudente,
intercettare <literal>QUERY_CANCELED</literal> dal nome). I nomi delle condizioni non 
sono sensibili al case. Inoltre, una condizione di errore può essere specificata
dal codice <literal>SQLSTATE</literal>; per esempio, questi sono equivalenti:
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

    <para>
Se succede un nuovo errore all'interno delle istruzioni 
<replaceable>handler_statements</replaceable>, non può essere catturato 
da questa clausola <literal>EXCEPTION</literal>, ma viene propagato al di fuori.
Una clausola <literal>EXCEPTION</literal> circostante potrebbe intercettarlo.
    </para>

    <para>
Quando un errore è catturato da una clausola <literal>EXCEPTION</literal>,
le variabili locali della funzione <application>PL/pgSQL</application>
rimangono come erano quando l'errore è accaduto, ma tutti i cambiamenti
allo stato persistente del database all'interno del blocco sono sottoposti a rollback.
Come esempio, considerare questo frammento:

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEgin
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

Quando il controllo raggiunge l'assegnazione a <literal>y</literal>, fallirà
con un errore <literal>division_by_zero</literal>. Questo sarà catturato dalla 
clausola <literal>EXCEPTION</literal>. Il valore restituito nell'istruzione 
<command>RETURN</command> sarà il valore incrementato di
<literal>x</literal>, ma gli effetti del comando <command>UPDATE</command> saranno stati
sottoposti a rollback. Il comando <command>INSERT</command> precedente il blocco 
non è sottoposto a rollback, comunque, quindi il risultato finale è che il database
contiene <literal>Tom Jones</literal> e  non <literal>Joe Jones</literal>.

    </para>

    <tip>
     <para>
Un blocco contenente una clausola <literal>EXCEPTION</literal> è significativamente 
più costoso da entrare e uscire rispetto a un blocco senza. Per questo,
non usare <literal>EXCEPTION</literal> senza bisogno.
     </para>
    </tip>

    <para>
All'interno di un gestore di eccezione, la variabile <varname>SQLSTATE</varname>
contiene il codice dell'errore che corrisponde all'eccezione che è
stata generata (si veda <xref
linkend="errcodes-table"/> per un elenco dei possibili codici di errore).
La variabile <varname>SQLERRM</varname> contiene il messaggio di errore 
associato con l'eccezione. Queste variabili sono 
indefinite all'esterno del gestore di eccezione.
    </para>

    <example id="plpgsql-upsert-example">
    <title>Eccezioni con <command>UPDATE</command>/<command>INSERT</command></title>
    <para>

Questo esempio usa la gestione delle eccezioni per eseguire o una 
<command>UPDATE</command> o una <command>INSERT</command>, come appropriato:

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEgin
    LOOP
        -- prima prova ad aggiornare la chiave 
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- non trovata, quindi prova ad inserire la chiave
        -- se qualcun altro inserisce la stessa chiave concorrentemente,
        -- potremmo ottenere un fallimento unique-key
        BEgin
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- non fa niente, e cicla per provare di nuovo l'UPDATE
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

    </para>
    </example>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
   <title>Cursori</title>

   <indexterm zone="plpgsql-cursors">
    <primary>cursore</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   <para>
Piuttosto che eseguire l'intera query tutta insieme, è possibile impostare un 
<firstterm>cursore</firstterm> che incapsula la query, e quindi legge 
il risultato della query un po' di righe alla volta. Un aragione per fare questo è
di evitare l'eccedere di memoria quando il risultato contiene un gran numero di 
righe. (Comunque, gli utenti di <application>PL/pgSQL</application>  normalmente non devo preoccuparsi
di questo, dato che i cicli <literal>FOR</literal> internamente usano automaticamente un cursore
per evitare problemi di memoria). Un utilizzo più interessante e di 
restituire un riferimento a un cursore che una funzione ha creato, permettendo 
al chiamante di leggere le righe. Questo fornisce un modo efficiente di restituire 
grandi insiemi di righe da funzioni.
   </para>

   <sect2 id="plpgsql-cursor-declarations">
    <title>Dichiarare variabili cursore</title>

    <para>
Tutto l'accesso ai cursori in <application>PL/pgSQL</application> avviene attraverso
variabili cursore, che sono sempre del tipo 
<type>refcursor</type>. Un modo di creare una variabile cursore 
e semplicemente dichiararla come variabile del tipo <type>refcursor</type>.
Un altro modo è di usare la sintassi di dichiarazione di cursore, 
che in generale è:
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
(<literal>FOR</literal> può essere sostituito da <literal>IS</literal> per 
compatibilità <productname>Oracle</productname>).
Sei viene specificato <literal>SCROLL</literal>, il cursore sarà capace di
scorrere all'indietro; se è specificato <literal>NO SCROLL</literal>, saranno rifiutate   
ricerche all'indietro; se non appare nessuna delle due specifiche, dipenderà dalla query 
se saranno permesse ricerche all'indietro. 
<replaceable>arguments</replaceable>, se specificato, è un elenco
separato da virgole di coppie <literal><replaceable>name</replaceable>
<replaceable>datatype</replaceable></literal> che definisce i nomi da essere 
sostituiti da valori dei parametri nella data query. I valori effettivi
da sostituire per questi nomi saranno specificati più tardi,
quando il cursore è aperto.
    </para>
    <para>
Alcuni esempi:
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
Tutte e tre queste variabili hanno il tipo di dato <type>refcursor</type>,
ma la prima può essere usata con qualsiasi query, mentre la seconda ha
una query completamente specificata già <firstterm>legata</firstterm> ad essa, e l'ultima
ha una query parametrizzata legata. (<literal>key</literal> sarà 
sostituita da un valore di parametro intero quando il cursore è aperto).
La variabile <literal>curs1</literal>
è detta essere <firstterm>non legata</firstterm> dato che non è legata a  nessuna 
query particolare.
    </para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
    <title>Aprire cursori</title>

    <para>
Prima che un cursore possa essere usato per recuperare righe, deve essere
<firstterm>aperto</firstterm>. (Questa è l'azione equivalente al comando SQL
<command>DECLARE CURSOR</command>). <application>PL/pgSQL</application> ha 
tre forme di istruzione <command>OPEN</command>, due delle quali usano variabili cursore
non legate mentre la terza usa una variabile cursore legata.
    </para>

    <note>
     <para>
Variabili di cursore legate possono anche essere usate senza aprire esplicitamente il cursore,
attraverso l'istruzione <command>FOR</command> descritta in
<xref linkend="plpgsql-cursor-for-loop"/>.
     </para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

       <para>
La variabile cursore è aperta ed è fornita la specifica query da eseguire.
Il cursore non può essere già aperto, e deve essere stato
dichiarato come una variabile cursore non legata (cioè, come semplice
variabile <type>refcursor</type>). La query deve essere una 
<command>SELECT</command>, o qualcos'altro che restituisce righe
(tipo <command>EXPLAIN</command>). La query
viene trattata allo stesso modo di altri comandi SQL in 
<application>PL/pgSQL</application>: i nomi delle variabili <application>PL/pgSQL</application>
sono sostituiti, e il piano della query viene sottoposto a cache per 
il possibile riuso. Quando una variabile <application>PL/pgSQL</application>
è sostituita nella query cursore, il valore che è sostituito 
è quello che era al momento della <command>OPEN</command>;
cambiamenti successivi alla variabile non avranno effetti sul comportamento
del cursore.
Le opzioni <literal>SCROLL</literal> e <literal>NO SCROLL</literal>
hanno gli stessi significati come per un cursore legato.
       </para>

       <para>
Un esempio:
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

         <para>
La variabile cursore è aperta è viene fornita la speifica query da eseguire.
Il cursore non può essere già aperto, e deve essere stato dichiarato come una variabile
dichiarata come un cursore non legato (cioè, come una semplice variabile
<type>refcursor</type>). La query è specificata come una espressione stringa,
nello stesso modo del comando <command>EXECUTE</command>.
Come al solito, questo dà flessibilità e così il piano della query può variare
da un'esecuzione ad un'altra (si veda <xref linkend="plpgsql-plan-caching"/>),
e significa anche che la sostituzione di variabili non viene fatta sulla stringa comando.
Come con <command>EXECUTE</command>, i valori dei parametri 
possono essere inseriti nel comando dinamico con <literal>USING</literal>.
Le opzioni <literal>SCROLL</literal> e <literal>NO SCROLL</literal>
hanno gli stessi significati come per un cursore legato.
         </para>

       <para>
Un esempio:
<programlisting>
OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)
                                        || ' WHERE col1 = $1' USING keyvalue;
</programlisting>
In questo esempio, il nome della tabella è inserito nella query testualmente,
così l'uso di <function>quote_ident()</function> è raccomandato per proteggersi contro 
le SQL injection. Il valore di confronto per <literal>col1</literal> è inserito 
attraverso un parametro <literal>USING</literal>, così non ha bisogno di quotazione.
       </para>
     </sect3>

    <sect3>
     <title>Aprire una cursore legato</title>

<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <replaceable>argument_values</replaceable> ) </optional>;
</synopsis>

         <para>
Questa forma di <command>OPEN</command> è usata per aprire una variabile 
cursore la cui query era legata ad esso quando fu dichiarato. Il cursore   
non può essere già aperto. Un elenco di espressioni argomento effettive 
deve apparire se e solo se il cursore è stato dichiarato per prendere argomenti.
Questi valori saranno sostituiti nella query. 
Il piano della query per un cursore legato è sempre considerato sottoponibile a cache;
non c'è un equivalente di <command>EXECUTE</command> in questo caso.
Notare che <literal>SCROLL</literal> e 
<literal>NO SCROLL</literal> non possono essere specificate, dato che il comportamento  
dello scorrimento del cursore era già stato determinato.
         </para>

         <para>
Notare che dato che la sostituzione di variabili è fatta sulla query del cursore legato,
ci sono due modi di passare valori al cursore:
o con un argomento esplicito a <command>OPEN</command>, o
implicitamente facendo riferimento a una variabile <application>PL/pgSQL</application>
nella query. Comunque, solo le variabili dichiarate prima che il cursore legato 
fosse dichiarato saranno sostituite in essa. In entrambi i casi 
il valore da essere passato è determinato al momento della
<command>OPEN</command>.
         </para>

    <para>
     Esempi:
<programlisting>
OPEN curs2;
OPEN curs3(42);
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
    <title>Usare i cursori</title>

    <para>
Una volta che un cursore è stato aperto, può essere manipolato con
le istruzioni descritte qui.
    </para>

    <para>
Queste manipolazioni non devono avvenire nella stessa funzione che 
ha aperto il cursore all'inizio. È possibile restituire un valore <type>refcursor</type>
da una funzione e lasciare operare il chiamante sul cursore.
(Internamente, un valore <type>refcursor</type> è semplicemenete in nome della stringa
di un portale così chiamato contenente la query attiva per il cursore. Questo nome
può essere passato in giro, assegnato ad altre variabili <type>refcursor</type>,
e così via, senza disturbare il portale).
    </para>

    <para>
Tutti i portali sono implicitamente chiusi alla fine della transazione. Quindi
un valore <type>refcursor</type> è usabile per riferirsi a un cursore aperto 
solo fino alla fine della transazione.
    </para>

    <sect3>
     <title><literal>FETCH</literal></title>

<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

    <para>
<command>FETCH</command> ottiene la riga successiva dal cursore
in un obiettivo, che potrebbe eserre una variabile riga, una variabile record, 
o un elenco separato da virgole di variabili semplici, esattamente come 
<command>SELECT INTO</command>. Se non c'è una riga seguente, l'obiettivo è
impostato a NULL. Come con <command>SELECT
INTO</command>, la variabile speciale <literal>FOUND</literal> può 
essere controllato per vedere se una riga è stata ottenuta o no.
    </para>

    <para>
La clausola <replaceable>direction</replaceable> può essere una qualsiasi delle varianti
permesse nel comando SQL <xref linkend="sql-fetch"/>
ad eccezione di quelle che possono ottenere 
più di una riga; vale a dire, può essere
<literal>NEXT</literal>,
<literal>PRIOR</literal>,
<literal>FIRST</literal>,
<literal>LAST</literal>,
<literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
<literal>RELATIVE</literal> <replaceable>count</replaceable>,
<literal>FORWARD</literal>, o
<literal>BACKWARD</literal>.
Omettere <replaceable>direction</replaceable> è lo stesso di 
specificare <literal>NEXT</literal>.
Valori di <replaceable>direction</replaceable> che richiedono il movimento
a ritroso probabilmente falliranno a meno che il cursore non fosse stato dichiarato o 
aperto con l'opzione <literal>SCROLL</literal>.
    </para>

    <para>
<replaceable>cursor</replaceable> deve essere il nome di una variabile <type>refcursor</type>
che si riferisce a un portale cursore aperto.
    </para>

    <para>
Esempi:
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>MOVE</literal></title>

<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

    <para>
<command>MOVE</command> riposiziona un cursore senza ottenere nessun dato.
<command>MOVE</command> funziona esattamente come il comando 
<command>FETCH</command>, ad eccezione che riposiziona solamente il cursore
e non restituisce la riga su cui si è mosso. Come con <command>SELECT
INTO</command>, la variabile speciale <literal>FOUND</literal> può
essere controllata per vedere se c'era una riga successiva su cui muoversi.
    </para>

    <para>
La clausola <replaceable>direction</replaceable> può essere qualsiasi delle varianti 
permesse nel comando SQL <xref linkend="sql-fetch"/>,
vale a dire
<literal>NEXT</literal>,
<literal>PRIOR</literal>,
<literal>FIRST</literal>,
<literal>LAST</literal>,
<literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
<literal>RELATIVE</literal> <replaceable>count</replaceable>,
<literal>ALL</literal>,
<literal>FORWARD</literal> <optional> <replaceable>count</replaceable> | <literal>ALL</literal> </optional>, o
<literal>BACKWARD</literal> <optional> <replaceable>count</replaceable> | <literal>ALL</literal> </optional>.
Omettere <replaceable>direction</replaceable> è lo stesso di specificare 
<literal>NEXT</literal>.
I valori di <replaceable>direction</replaceable> che richiedono il movimento all'indietro
probabilmente falliranno a meno che il cursorre non fosse stato dichiarato o aperto 
con l'opzione <literal>SCROLL</literal>.
    </para>

    <para>
Esempi:
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

       <para>
Quando un cursore è posizionato sulla riga di una tabella, quella riga può essere aggiornata
o cancellata usando il cursore per identificarla. Ci sono restrizioni
su cosa possa essere e la query del cursore (in particolare ,
no raggruppamenti) ed è meglio usare <literal>FOR UPDATE</literal> nel cursore.
Per maggiori informazioni si veda la pagina di riferimento
<xref linkend="sql-declare"/>.
       </para>

       <para>
Un esempio:
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>CLOSE</literal></title>

<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

       <para>
<command>CLOSE</command> chiude il portale sottostante un cursore aperto.
Questo può essere usato per rilasciare risorse prima della fine della transazione, 
o per liberare la variabile cursore per essere aperta di nuovo.
       </para>

       <para>
Un esempio:
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title>Cursori di ritorno</title>

       <para>
Le funzioni <application>PL/pgSQL</application> possono restituire cursori al chiamante.
Questo è utile per restituire molteplici righe o colonne, 
specialmente con insiemi di risultati molto grandi. Per fare ciò, la funzione
apre il cursore e restituisce il nome del cursore al chiamante (o semplicemente 
apre il cursore usando un nome di portale specificato da, o saputo in altro modo, 
al chiamante). Il chiamante può quindi recuperare righe dal cursore. Il cursore 
può essere chiuso dal chimante, o sarà chiuso automaticamente
quando la transazione si chiude.
       </para>

       <para>
Il nome del portale usato per un cursore può essere specificato dal programmatore
o generato automaticamente. Per specificare il nome di un portale, 
assegnare sempliciemente una stringa alla variabile <type>refcursor</type> prima 
si aprirla. Il valore della stringa della variabile <type>refcursor</type>
sarà usato da <command>OPEN</command> come nome del portale sottostante.
Comunque, se la variabile <type>refcursor</type> è null,
<command>OPEN</command> genera automaticamente un nome che non va in conflitto 
con nessun altro portale esistente, e lo assegna alla variabile 
<type>refcursor</type>.
       </para>

       <note>
        <para>
Una variabile cursore legata è inizializzata al valore della stringa
rappresentante il suo nome, così che il nome del portale è lo stesso del
nome della variabile cursore, a meno che il programmatore lo sovrascriva 
con un'assegnazione prima di aprire il cursore. Ma una variabile cursore non legata
è inizialmente null, così riceverà un nome unico generato automaticamente, 
a meno che sovrascritto.
        </para>
       </note>

       <para>
L'esempio seguente mostra un modo in cui il nome di un cursore possa essere fornito
dal chiamante:

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEgin
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEgin;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

       <para>
L'esempio seguente usa la generazione automatica del nome:

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEgin
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- need to be in a transaction to use cursors.
BEgin;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>

       <para>
L'esempio seguente mostra un modo di restituire molteplici cursori 
da una singola funzione:

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEgin
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- deve essere in una transazione per usare i cursori.
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
    <title>Looping Through a Cursor's Result</title>

    <para>
C'è una variante dell'istruzione <command>FOR</command> che permette
di iterare attraverso le righe ritornate da un cursore. La sintassi è:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <replaceable>argument_values</replaceable> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

La variabile cursore deve essere stata legata a qualche query quando è stata
dichiarata, e <emphasis>non può</emphasis> essere già aperta. L'istruzione
<command>FOR</command> apre automaticamente il cursore, e chiude di nuovo il cursore 
quando il ciclo termina. Un elenco dei valori degli argomenti effettivi 
deve apparire se e solo se il cursore fu dichiarato per prendere argomenti.
Questi valori saranno sostituiti nella query, esattamente nello stesso modo 
che durante una <command>OPEN</command>.
La variabile <replaceable>recordvar</replaceable> viene definita automaticamente
del tipo <type>record</type> ed esiste solo all'interno del ciclo (qualsiasi 
definizione esistente del nome della variabile viene ignorata all'interno del ciclo).
Ogni riga restituita dal cursore è successivamente assegnata a questa variabile record
e viene eseguito il corpo del ciclo.
    </para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
   <title>Errori e messaggi</title>

   <indexterm>
    <primary>RAISE</primary>
   </indexterm>

   <indexterm>
    <primary>riportare errori</primary>
    <secondary>in PL/PgSQL</secondary>
   </indexterm>

   <para>
Usare l'istruzione <command>RAISE</command> per riportare messaggi e 
sollevare errori.

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

L'opzione <replaceable class="parameter">level</replaceable> specifica
la gravità dell'errore. I livelli permessi sono <literal>DEBUG</literal>, 
<literal>LOG</literal>, <literal>INFO</literal>,
<literal>NOTICE</literal>, <literal>WARNING</literal>,
e <literal>EXCEPTION</literal>, con <literal>EXCEPTION</literal>
che è il predefinito.
<literal>EXCEPTION</literal> solleva un errore (che normalmente annulla la transazione
corrente); gli altri livelli generano solamente messaggi di diversi 
livelli di priorità.
Il fatto che i messaggi di una particolare priorità siano riportati al client, 
scritti sul log del server, o entrambi è controllato dalle variabili 
di configurazione 
<xref linkend="guc-log-min-messages"/> e
<xref linkend="guc-client-min-messages"/>. 
Si veda <xref linkend="runtime-config"/> per maggiori informazioni.
   </para>

   <para>
Dopo <replaceable class="parameter">level</replaceable>, se presente, 
è possibile scrivere  <replaceable class="parameter">format</replaceable>
(che deve essere una semplice stringa letterale,  non un'espressione). La stringa 
format specifica il testo del messaggio si errore da segnalare.
La stringa format può essere seguita 
da espressioni argomento opzionali da inserire nel messaggio.
All'interno della stringa format, <literal>%</literal> viene sostituita 
dalla rappresentazione in stringa del valore opzionale seguente. Scrivere
<literal>%%</literal> per emettere un <literal>%</literal> letterale.
   </para>

   <para>
In questo esempio, il valore di <literal>v_job_id</literal> sostituirà il 
<literal>%</literal> nella stringa:
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>

   <para>
È possibile allegare informazioni aggiuntive al resoconto dell'errore scriverndo
<literal>USING</literal> seguito da elementi <replaceable
class="parameter">option</replaceable> = <replaceable
class="parameter">expression</replaceable>.  
Le parole chiave 
<replaceable class="parameter">option</replaceable> permesse sono 
<literal>MESSAGE</literal>, <literal>DETAIL</literal>, <literal>HINT</literal>, e
<literal>ERRCODE</literal>, mentre ogni <replaceable
class="parameter">expression</replaceable> 
può essere qualsiasi espressione stringa.
<literal>MESSAGE</literal> imposta il testo del masseggio di errore (questa opzione
non può essere usata nella forma di <command>RAISE</command> che include una stringa format
prima di <literal>USING</literal>).
<literal>DETAIL</literal> fornisce un messaggio del dettaglio dell'errore, mentre
<literal>HINT</literal> fornisce un messaggio di suggerimento.
<literal>ERRCODE</literal> specifica il codice dell'errore da riportare (SQLSTATE),
o dal nome della condizione come mostrato in <xref linkend="errcodes-appendix"/>,
o direttamente come codice SQL di cinque caratteri.
   </para>

   <para>
Questo esempio annullerà la transazione con il dato messaggio di errore
e suggerimento:
<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user id';
</programlisting>
   </para>

   <para>
Questi due esempi mostrano modi equivalenti di impostare il SQLSTATE:
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

   <para>
C'è una secondo tipo di sintassi per <command>RAISE</command> in cui l'argomento principale
è il nome della condizione o SQLSTATE da riportare, per esempio:
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
In questa sintassi, <literal>USING</literal> può essere usato per indicare un messaggio d'errore, 
un dettaglio o un 
suggerimento personalizzato. Un altro modo di fare l'esempio precedente
è
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>

   <para>
Un'ulteriore variante è di scrivere <literal>RAISE USING</literal> o <literal>RAISE
<replaceable class="parameter">level</replaceable> USING</literal> e mettere
tutto il resto nell'elenco <literal>USING</literal>.
   </para>

   <para>
L'ultima variante di <command>RAISE</command> non ha parametri del tutto.
Quasta forma può essere usata solo all'interno della clausola <literal>EXCEPTION</literal>
di un blocco <literal>BEGIN</literal>;
esso causa che l'errore correntemente gestito sia lanciato di nuovo.
   </para>

   <note>
    <para>
Prima di <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> senza
parametri era interpretato come lanciare di nuovo l'errore dal blocco contenente
il gestore di eccezioni attivo. Così una clausola <literal>EXCEPTION</literal>
annidata all'interno di quel gestore potrebbe non catturarla, anche se
il <command>RAISE</command> era all'interno del blocco della clausa  <literal>EXCEPTION</literal>
annidata. Questo fu considerato anche essere sorprendentemente incompatibile con  
PL/SQL di Oracle.
    </para>
   </note>

   <para>
Se non è specificato nessun nome di condizione nè SQLSTATE in un comando  
<command>RAISE EXCEPTION</command>, come predefinito si usa 
<literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>). Se nessun messaggio di testo
viene specificato, il comportamento predefinito è di usare il nome della condizione o
SQLSTATE come messaggio di testo.
   </para>

   <note>
    <para>
Quando si specifica un codice di errore con un SQLSTATE, non si è limitati
a codici di errore predefiniti, ma si può selezionare qualsiasi
codice di errore che consiste di cinque cifre e/o lettere ASCII maiuscole, 
diverse da <literal>00000</literal>.  Si raccomanda di 
evitare di lanciare codici di errore che finiscano con tre zeri, dato che questi sono 
codici di categorie e possono essere intercettati solo intercettando l'intera
categoria.
    </para>
   </note>

 </sect1>

 <sect1 id="plpgsql-trigger">
  <title>Procedure Trigger</title>

  <indexterm zone="plpgsql-trigger">
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
  </indexterm>

  <para>
<application>PL/pgSQL</application> può essere usato per definire procedure 
trigger. Una procedura trigger viene creata con il comando 
<command>CREATE FUNCTION</command>, dichiarandola come  una funzione senza
argomenti e <type>trigger</type> come tipo di ritorno. Notare che   
la funzione deve essere dichiarata senza argomenti anche se si aspetta 
di ricevere argomenti specificati in <command>CREATE TRIGGER</command> -
gli argomenti del trigger sono passati via <varname>TG_ARGV</varname>, come descritto
sotto.
  </para>

  <para>
Quando una funzione <application>PL/pgSQL</application> è chiamata come trigger,
diverse variabili speciali sono create automaticamente nel blocco 
superiore. Esse sono:

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
Tipo di dato <type>RECORD</type>; variabile che tiene la nuova riga
del database per operazioni <command>INSERT</command>/<command>UPDATE</command> in 
trigger a livello di riga. Questa variabile è <symbol>NULL</symbol> in trigger a livello 
di istruzione e per operazioni <command>DELETE</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
Tipo di dato <type>RECORD</type>; variabile che tiene la vecchia riga del database
per operazioni <command>UPDATE</command>/<command>DELETE</command> in trigger a livello di 
riga. Questa variabile è <symbol>NULL</symbol> in trigger a livello di istruzione
e per operazioni <command>INSERT</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; variabile che contiene il nome del trigger attualmente attivato.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of either
Tipo di dato <type>text</type>; una stringa <literal>BEFORE</literal> o <literal>AFTER</literal>
a seconda della definizione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
Tipo di dato <type>text</type>; una stringa
<literal>ROW</literal> o <literal>STATEMENT</literal>
a seconda della definizione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of
Tipo di dato <type>text</type>; una stringa
<literal>INSERT</literal>, <literal>UPDATE</literal>,
<literal>DELETE</literal>, o <literal>TRUNCATE</literal>
che dice per quale operazione è stato attivato il trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
Tipo di dato  <type>oid</type>; l'ID dell'oggetto della tabella che ha causato 
l'invocazione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; il nome della tabella che ha causato l'invocazione del 
trigger. Questo ora è deprecato, e può sparire in una versione futura.
Usare invece <literal>TG_TABLE_NAME</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; il nome della tabella che ha causato 
l'invocazione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
Tipo di dato <type>name</type>; il nome dello schema della tabella che 
ha causato l'invocazione del trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
Tipo di dato <type>integer</type>; il numero di argomenti forniti alla procedura trigger 
nell'istruzione <command>CREATE TRIGGER</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
Tipo di dato <type>text</type>; gli argomenti 
dell'istruzione <command>CREATE TRIGGER</command>.
L'indice conta da 0. Gli indici invalidi 
(minori di 0 o maggiori di, o uguali, a <varname>tg_nargs</varname>)
risultano in un valore null.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
Una funzione trigger deve restituire o <symbol>NULL</symbol> o un valore record/riga
avente esattamente la struttura della tabelle per cui è stato attivato il trigger.
   </para>

   <para>
Trigger a livello di riga attivati prima (<literal>BEFORE</literal>) possono restituire null
per segnalare al gestore dei trigger di saltare il resto dell'operazione per questa riga.
(per es., i trigger successivi non vengono attivati, e 
le <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> non accadono
per questa riga). Se viene restituito un valore nonnull
allora l'operazione procede con quel valore della riga.
Restituire un valore rida diverso dal valore originale di
<varname>NEW</varname> altera la riga che sarà inserita o aggiornata.
Così, se la funzione trigger vuole che l'azione di trigger
riesca normalmente senza alterare il valore della riga, 
deve essere restituito <varname>NEW</varname> (o un valore ad esso equivalente).
Per modificare la riga da salvare, è possibile 
sostituire singoli valori direttamente in  <varname>NEW</varname> e restituire 
la <varname>NEW</varname> modificata, o costruire un record/riga completamente nuovo
da restituire. Nel caso di un trigger before 
su <command>DELETE</command>, il valore restituito non ha un effetto diretto,
ma deve essere non null per permettere all'azione trigger di
procedere. Notare che <varname>NEW</varname> è null nei trigger
<command>DELETE</command>, quindi restituirlo di solito non è sensato. 
Un'espressione utile nei trigger <command>DELETE</command>
potrebbe restituire <varname>OLD</varname>.
   </para>

   <para>
Il valore di ritorno di un trigger a livello di riga
attivato <literal>AFTER</literal> o un trigger a livello di instruzione
attivato <literal>BEFORE</literal> o <literal>AFTER</literal> è
sempre ignorato; potrebbe anch'esso essere null. Comunque, uno qualsiasi di questi tipi di 
trigger potrebbe ancora annullare l'intera operazione sollevando un errore.
   </para>

   <para>
<xref linkend="plpgsql-trigger-example"/> mostra un esempio di una procedura trigger
in <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-trigger-example">
    <title>Una procedura trigger <application>PL/pgSQL</application></title>

    <para>
Questo trigger di esempio assicura che ogni volta una riga venga inserita o aggiornata
nella tabella, il nome utente corrente e l'orario siano salvati nella riga.
E controlla che oil nome di un impiegato sua fornito e che il salario
sia un valore positivo.
    </para>

<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEgin
        -- Check that empname and salary are given
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- Who works for us when she must pay for it?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- Remember who changed the payroll when
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();
</programlisting>
   </example>

   <para>
Un altro modo di annotare i cambiamenti a una tabella implica la creazione di una nuova tabella
che salva una riga per ogni insert, update, o delete che accade. Questo approccio
può essere pensato come una revisione dei cambiamenti a una tabella.
<xref linkend="plpgsql-trigger-audit-example"/> mostra un esempio di una procedura trigger
di revisione in <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-trigger-audit-example">
    <title>Una procedura trigger <application>PL/pgSQL</application> per la revisione</title>

    <para>
Questo trigger di  esempio assicura che qualsiasi inserimento, aggiornamento o cancellazione di una riga
nella tabella <literal>emp</literal> sia registrata nella tabella <literal>emp_audit</literal>.
L'orario e il nome utente corrente sono salvati nella riga, insieme al 
tipo di operazione svolta.
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- Crea una riga un emp_audit per riflettere l'operazione eseguita su emp, 
        -- usa la variabile speciale TG_OP per portare a termine l'operazione.
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- il risultato viene ignorato dato che questo è un trigger AFTER
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();
</programlisting>
   </example>

   <para>
    One use of triggers is to maintain a summary table
    of another table. The resulting summary can be used in place of the
    original table for certain queries &mdash; often with vastly reduced run
    times.
    This technique is commonly used in Data Warehousing, where the tables
    of measured or observed data (called fact tables) might be extremely large.
    <xref linkend="plpgsql-trigger-summary-example"/> shows an example of a
    trigger procedure in <application>PL/pgSQL</application> that maintains
    a summary table for a fact table in a data warehouse.
   </para>


   <example id="plpgsql-trigger-summary-example">
    <title>A <application>PL/pgSQL</application> Trigger Procedure For Maintaining A Summary Table</title>

    <para>
     The schema detailed here is partly based on the <emphasis>Grocery Store
     </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis>
     by Ralph Kimball.
    </para>

<programlisting>
--
-- Main tables - time dimension and sales fact.
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- Summary table - sales by time.
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEgin

        -- Work out the increment/decrement amount(s).
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- forbid updates that change the time_key -
            -- (probably not too onerous, as DELETE + INSERT is how most
            -- changes will be made).
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- Insert or update the summary row with the new values.
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEgin
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- do nothing
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>

  </sect1>

  <sect1 id="plpgsql-implementation">
   <title><application>PL/pgSQL</application> Under the Hood</title>

   <para>
    This section discusses some implementation details that are
    frequently important for <application>PL/pgSQL</application> users to know.
   </para>

  <sect2 id="plpgsql-var-subst">
   <title>Variable Substitution</title>

   <para>
    SQL statements and expressions within a <application>PL/pgSQL</application> function
    can refer to variables and parameters of the function.  Behind the scenes,
    <application>PL/pgSQL</application> substitutes query parameters for such references.
    Parameters will only be substituted in places where a parameter or
    column reference is syntactically allowed.  As an extreme case, consider
    this example of poor programming style:
<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
    The first occurrence of <literal>foo</literal> must syntactically be a table
    name, so it will not be substituted, even if the function has a variable
    named <literal>foo</literal>.  The second occurrence must be the name of a
    column of the table, so it will not be substituted either.  Only the
    third occurrence is a candidate to be a reference to the function's
    variable.
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> versions before 9.0 would try
     to substitute the variable in all three cases, leading to syntax errors.
    </para>
   </note>

   <para>
    Since the names of variables are syntactically no different from the names
    of table columns, there can be ambiguity in statements that also refer to
    tables: is a given name meant to refer to a table column, or a variable?
    Let's change the previous example to
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    Here, <literal>dest</literal> and <literal>src</literal> must be table names, and
    <literal>col</literal> must be a column of <literal>dest</literal>, but <literal>foo</literal>
    and <literal>bar</literal> might reasonably be either variables of the function
    or columns of <literal>src</literal>.
   </para>

   <para>
    By default, <application>PL/pgSQL</application> will report an error if a name
    in a SQL statement could refer to either a variable or a table column.
    You can fix such a problem by renaming the variable or column,
    or by qualifying the ambiguous reference, or by telling
    <application>PL/pgSQL</application> which interpretation to prefer.
   </para>

   <para>
    The simplest solution is to rename the variable or column.
    A common coding rule is to use a
    different naming convention for <application>PL/pgSQL</application>
    variables than you use for column names.  For example,
    if you consistently name function variables
    <literal>v_<replaceable>something</replaceable></literal> while none of your
    column names start with <literal>v_</literal>, no conflicts will occur.
   </para>

   <para>
    Alternatively you can qualify ambiguous references to make them clear.
    In the above example, <literal>src.foo</literal> would be an unambiguous reference
    to the table column.  To create an unambiguous reference to a variable,
    declare it in a labeled block and use the block's label
    (see <xref linkend="plpgsql-structure"/>).  For example,
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEgin
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    Here <literal>block.foo</literal> means the variable even if there is a column
    <literal>foo</literal> in <literal>src</literal>.  Function parameters, as well as
    special variables such as <literal>FOUND</literal>, can be qualified by the
    function's name, because they are implicitly declared in an outer block
    labeled with the function's name.
   </para>

   <para>
    Sometimes it is impractical to fix all the ambiguous references in a
    large body of <application>PL/pgSQL</application> code.  In such cases you can
    specify that <application>PL/pgSQL</application> should resolve ambiguous references
    as the variable (which is compatible with <application>PL/pgSQL</application>'s
    behavior before <productname>PostgreSQL</productname> 9.0), or as the
    table column (which is compatible with some other systems such as
    <productname>Oracle</productname>).
   </para>

   <indexterm>
     <primary><varname>plpgsql.variable_conflict</varname> configuration parameter</primary>
   </indexterm>

   <para>
    To change this behavior on a system-wide basis, set the configuration
    parameter <literal>plpgsql.variable_conflict</literal> to one of
    <literal>error</literal>, <literal>use_variable</literal>, or
    <literal>use_column</literal> (where <literal>error</literal> is the factory default).
    This parameter affects subsequent compilations
    of statements in <application>PL/pgSQL</application> functions, but not statements
    already compiled in the current session.  To set the parameter before
    <application>PL/pgSQL</application> has been loaded, it is necessary to have added
    <quote><literal>plpgsql</literal></quote> to the <xref
    linkend="guc-custom-variable-classes"/> list in
    <filename>postgresql.conf</filename>.  Because changing this setting
    can cause unexpected changes in the behavior of <application>PL/pgSQL</application>
    functions, it can only be changed by a superuser.
   </para>

   <para>
    You can also set the behavior on a function-by-function basis, by
    inserting one of these special commands at the start of the function
    text:
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    These commands affect only the function they are written in, and override
    the setting of <literal>plpgsql.variable_conflict</literal>.  An example is
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEgin
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    In the <literal>UPDATE</literal> command, <literal>curtime</literal>, <literal>comment</literal>,
    and <literal>id</literal> will refer to the function's variable and parameters
    whether or not <literal>users</literal> has columns of those names.  Notice
    that we had to qualify the reference to <literal>users.id</literal> in the
    <literal>WHERE</literal> clause to make it refer to the table column.
    But we did not have to qualify the reference to <literal>comment</literal>
    as a target in the <literal>UPDATE</literal> list, because syntactically
    that must be a column of <literal>users</literal>.  We could write the same
    function without depending on the <literal>variable_conflict</literal> setting
    in this way:
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEgin
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    Variable substitution does not happen in the command string given
    to <command>EXECUTE</command> or one of its variants.  If you need to
    insert a varying value into such a command, do so as part of
    constructing the string value, or use <literal>USING</literal>, as illustrated in
    <xref linkend="plpgsql-statements-executing-dyn"/>.
   </para>

   <para>
    Variable substitution currently works only in <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> commands,
    because the main SQL engine allows query parameters only in these
    commands.  To use a non-constant name or value in other statement
    types (generically called utility statements), you must construct
    the utility statement as a string and <command>EXECUTE</command> it.
   </para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
   <title>Plan Caching</title>

   <para>
    The <application>PL/pgSQL</application> interpreter parses the function's source
    text and produces an internal binary instruction tree the first time the
    function is called (within each session).  The instruction tree
    fully translates the
    <application>PL/pgSQL</application> statement structure, but individual
    <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> commands
    used in the function are not translated immediately.
   </para>

   <para>
    As each expression and <acronym>SQL</acronym> command is first
    executed in the function, the <application>PL/pgSQL</application> interpreter
    creates a prepared execution plan (using the
    <acronym>SPI</acronym> manager's <function>SPI_prepare</function>
    and <function>SPI_saveplan</function>
    functions).<indexterm><primary>preparing a query</primary><secondary>in
    PL/pgSQL</secondary></indexterm> Subsequent visits to that expression or command
    reuse the prepared plan.  Thus, a function with conditional code
    that contains many statements for which execution plans might be
    required will only prepare and save those plans that are really
    used during the lifetime of the database connection.  This can
    substantially reduce the total amount of time required to parse
    and generate execution plans for the statements in a
    <application>PL/pgSQL</application> function. A disadvantage is that errors
    in a specific expression or command cannot be detected until that
    part of the function is reached in execution.  (Trivial syntax
    errors will be detected during the initial parsing pass, but
    anything deeper will not be detected until execution.)
   </para>

   <para>
    A saved plan will be re-planned automatically if there is any schema
    change to any table used in the query, or if any user-defined function
    used in the query is redefined.  This makes the re-use of prepared plans
    transparent in most cases, but there are corner cases where a stale plan
    might be re-used.  An example is that dropping and re-creating a
    user-defined operator won't affect already-cached plans; they'll continue
    to call the original operator's underlying function, if that has not been
    changed.  When necessary, the cache can be flushed by starting a fresh
    database session.
   </para>

   <para>
    Because <application>PL/pgSQL</application> saves execution plans
    in this way, SQL commands that appear directly in a
    <application>PL/pgSQL</application> function must refer to the
    same tables and columns on every execution; that is, you cannot use
    a parameter as the name of a table or column in an SQL command.  To get
    around this restriction, you can construct dynamic commands using
    the <application>PL/pgSQL</application> <command>EXECUTE</command>
    statement &mdash; at the price of constructing a new execution plan on
    every execution.
   </para>

   <para>
    Another important point is that the prepared plans are parameterized
    to allow the values of <application>PL/pgSQL</application> variables
    to change from one use to the next, as discussed in detail above.
    Sometimes this means that a plan is less efficient than it would be
    if generated for a specific variable value.  As an example, consider
<programlisting>
SELECT * INTO myrec FROM dictionary WHERE word LIKE search_term;
</programlisting>
    where <literal>search_term</literal> is a <application>PL/pgSQL</application>
    variable.  The cached plan for this query will never use an index on
    <structfield>word</structfield>, since the planner cannot assume that the
    <literal>LIKE</literal> pattern will be left-anchored at run time.  To use
    an index the query must be planned with a specific constant
    <literal>LIKE</literal> pattern provided.  This is another situation where
    <command>EXECUTE</command> can be used to force a new plan to be
    generated for each execution.
   </para>

    <para>
     The mutable nature of record variables presents another problem in this
     connection.  When fields of a record variable are used in
     expressions or statements, the data types of the fields must not
     change from one call of the function to the next, since each
     expression will be planned using the data type that is present
     when the expression is first reached.  <command>EXECUTE</command> can be
     used to get around this problem when necessary.
    </para>

    <para>
     If the same function is used as a trigger for more than one table,
     <application>PL/pgSQL</application> prepares and caches plans
     independently for each such table &mdash; that is, there is a cache
     for each trigger function and table combination, not just for each
     function.  This alleviates some of the problems with varying
     data types; for instance, a trigger function will be able to work
     successfully with a column named <literal>key</literal> even if it happens
     to have different types in different tables.
    </para>

    <para>
     Likewise, functions having polymorphic argument types have a separate
     plan cache for each combination of actual argument types they have been
     invoked for, so that data type differences do not cause unexpected
     failures.
    </para>

   <para>
    Plan caching can sometimes have surprising effects on the interpretation
    of time-sensitive values.  For example there
    is a difference between what these two functions do:

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEgin
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     and:

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEgin
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <para>
     In the case of <function>logfunc1</function>, the
     <productname>PostgreSQL</productname> main parser knows when
     preparing the plan for the <command>INSERT</command> that the
     string <literal>'now'</literal> should be interpreted as
     <type>timestamp</type>, because the target column of
     <classname>logtable</classname> is of that type. Thus,
     <literal>'now'</literal> will be converted to a constant when the
     <command>INSERT</command> is planned, and then used in all
     invocations of <function>logfunc1</function> during the lifetime
     of the session. Needless to say, this isn't what the programmer
     wanted.
    </para>

    <para>
     In the case of <function>logfunc2</function>, the
     <productname>PostgreSQL</productname> main parser does not know
     what type <literal>'now'</literal> should become and therefore
     it returns a data value of type <type>text</type> containing the string
     <literal>now</literal>. During the ensuing assignment
     to the local variable <varname>curtime</varname>, the
     <application>PL/pgSQL</application> interpreter casts this
     string to the <type>timestamp</type> type by calling the
     <function>text_out</function> and <function>timestamp_in</function>
     functions for the conversion.  So, the computed time stamp is updated
     on each execution as the programmer expects.
    </para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
  <title>Tips for Developing in <application>PL/pgSQL</application></title>

   <para>
    One good way to develop in
    <application>PL/pgSQL</application> is to use the text editor of your
    choice to create your functions, and in another window, use
    <application>psql</application> to load and test those functions.
    If you are doing it this way, it
    is a good idea to write the function using <command>CREATE OR
    REPLACE FUNCTION</command>. That way you can just reload the file to update
    the function definition.  For example:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    While running <application>psql</application>, you can load or reload such
    a function definition file with:
<programlisting>
\i filename.sql
</programlisting>
    and then immediately issue SQL commands to test the function.
   </para>

   <para>
    Another good way to develop in <application>PL/pgSQL</application> is with a
    GUI database access tool that facilitates development in a
    procedural language. One example of such a tool is
    <application>pgAdmin</application>, although others exist. These tools often
    provide convenient features such as escaping single quotes and
    making it easier to recreate and debug functions.
   </para>

  <sect2 id="plpgsql-quote-tips">
   <title>Handling of Quotation Marks</title>

   <para>
    The code of a <application>PL/pgSQL</application> function is specified in
    <command>CREATE FUNCTION</command> as a string literal.  If you
    write the string literal in the ordinary way with surrounding
    single quotes, then any single quotes inside the function body
    must be doubled; likewise any backslashes must be doubled (assuming
    escape string syntax is used).
    Doubling quotes is at best tedious, and in more complicated cases
    the code can become downright incomprehensible, because you can
    easily find yourself needing half a dozen or more adjacent quote marks.
    It's recommended that you instead write the function body as a
    <quote>dollar-quoted</quote> string literal (see <xref
    linkend="sql-syntax-dollar-quoting"/>).  In the dollar-quoting
    approach, you never double any quote marks, but instead take care to
    choose a different dollar-quoting delimiter for each level of
    nesting you need.  For example, you might write the <command>CREATE
    FUNCTION</command> command as:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    Within this, you might use quote marks for simple literal strings in
    SQL commands and <literal>$$</literal> to delimit fragments of SQL commands
    that you are assembling as strings.  If you need to quote text that
    includes <literal>$$</literal>, you could use <literal>$Q$</literal>, and so on.
   </para>

   <para>
    The following chart shows what you have to do when writing quote
    marks without dollar quoting.  It might be useful when translating
    pre-dollar quoting code into something more comprehensible.
  </para>

  <variablelist>
   <varlistentry>
    <term>1 quotation mark</term>
    <listitem>
     <para>
      To begin and end the function body, for example:
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      Anywhere within a single-quoted function body, quote marks
      <emphasis>must</emphasis> appear in pairs.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>2 quotation marks</term>
    <listitem>
     <para>
      For string literals inside the function body, for example:
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      In the dollar-quoting approach, you'd just write:
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      which is exactly what the <application>PL/pgSQL</application> parser would see
      in either case.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>4 quotation marks</term>
    <listitem>
     <para>
      When you need a single quotation mark in a string constant inside the
      function body, for example:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      The value actually appended to <literal>a_output</literal> would be:
      <literal> AND name LIKE 'foobar' AND xyz</literal>.
     </para>
     <para>
      In the dollar-quoting approach, you'd write:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      being careful that any dollar-quote delimiters around this are not
      just <literal>$$</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>6 quotation marks</term>
    <listitem>
     <para>
      When a single quotation mark in a string inside the function body is
      adjacent to the end of that string constant, for example:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      The value appended to <literal>a_output</literal> would then be:
      <literal> AND name LIKE 'foobar'</literal>.
     </para>
     <para>
      In the dollar-quoting approach, this becomes:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>10 quotation marks</term>
    <listitem>
     <para>
      When you want two single quotation marks in a string constant (which
      accounts for 8 quotation marks) and this is adjacent to the end of that
      string constant (2 more).  You will probably only need that if
      you are writing a function that generates other functions, as in
      <xref linkend="plpgsql-porting-ex2"/>.
      For example:
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      The value of <literal>a_output</literal> would then be:
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
     <para>
      In the dollar-quoting approach, this becomes:
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      where we assume we only need to put single quote marks into
      <literal>a_output</literal>, because it will be re-quoted before use.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
  <title>Porting from <productname>Oracle</productname> PL/SQL</title>

  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>porting from PL/SQL to PL/pgSQL</secondary>
  </indexterm>

  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>porting to PL/pgSQL</secondary>
  </indexterm>

  <para>
   This section explains differences between
   <productname>PostgreSQL</productname>'s <application>PL/pgSQL</application>
   language and Oracle's <application>PL/SQL</application> language,
   to help developers who port applications from
   <trademark class="registered">Oracle</trademark> to <productname>PostgreSQL</productname>.
  </para>

  <para>
   <application>PL/pgSQL</application> is similar to PL/SQL in many
   aspects. It is a block-structured, imperative language, and all
   variables have to be declared.  Assignments, loops, conditionals
   are similar.  The main differences you should keep in mind when
   porting from <application>PL/SQL</application> to
   <application>PL/pgSQL</application> are:

    <itemizedlist>
     <listitem>
      <para>
       If a name used in a SQL command could be either a column name of a
       table or a reference to a variable of the function,
       <application>PL/SQL</application> treats it as a column name.  This corresponds
       to <application>PL/pgSQL</application>'s
       <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>
       behavior, which is not the default,
       as explained in <xref linkend="plpgsql-var-subst"/>.
       It's often best to avoid such ambiguities in the first place,
       but if you have to port a large amount of code that depends on
       this behavior, setting <literal>variable_conflict</literal> may be the
       best solution.
      </para>
     </listitem>

     <listitem>
      <para>
       In <productname>PostgreSQL</productname> the function body must be written as
       a string literal.  Therefore you need to use dollar quoting or escape
       single quotes in the function body. (See <xref
       linkend="plpgsql-quote-tips"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
       Instead of packages, use schemas to organize your functions
       into groups.
      </para>
     </listitem>

     <listitem>
      <para>
       Since there are no packages, there are no package-level variables
       either. This is somewhat annoying.  You can keep per-session state
       in temporary tables instead.
      </para>
     </listitem>

     <listitem>
      <para>
       Integer <command>FOR</command> loops with <literal>REVERSE</literal> work
       differently: <application>PL/SQL</application> counts down from the second
       number to the first, while <application>PL/pgSQL</application> counts down
       from the first number to the second, requiring the loop bounds
       to be swapped when porting.  This incompatibility is unfortunate
       but is unlikely to be changed. (See <xref
       linkend="plpgsql-integer-for"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
       <command>FOR</command> loops over queries (other than cursors) also work
       differently: the target variable(s) must have been declared,
       whereas <application>PL/SQL</application> always declares them implicitly.
       An advantage of this is that the variable values are still accessible
       after the loop exits.
      </para>
     </listitem>

     <listitem>
      <para>
       There are various notational differences for the use of cursor
       variables.
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
   <title>Porting Examples</title>

   <para>
    <xref linkend="pgsql-porting-ex1"/> shows how to port a simple
    function from <application>PL/SQL</application> to <application>PL/pgSQL</application>.
   </para>

   <example id="pgsql-porting-ex1">
    <title>Porting a Simple Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>

    <para>
     Here is an <productname>Oracle</productname> <application>PL/SQL</application> function:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURN varchar IS
BEgin
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

    <para>
     Let's go through this function and see the differences compared to
     <application>PL/pgSQL</application>:

     <itemizedlist>
      <listitem>
       <para>
        The <literal>RETURN</literal> key word in the function
        prototype (not the function body) becomes
        <literal>RETURNS</literal> in
        <productname>PostgreSQL</productname>.
        Also, <literal>IS</literal> becomes <literal>AS</literal>, and you need to
        add a <literal>LANGUAGE</literal> clause because <application>PL/pgSQL</application>
        is not the only possible function language.
       </para>
      </listitem>

      <listitem>
       <para>
        In <productname>PostgreSQL</productname>, the function body is considered
        to be a string literal, so you need to use quote marks or dollar
        quotes around it.  This substitutes for the terminating <literal>/</literal>
        in the Oracle approach.
       </para>
      </listitem>

      <listitem>
       <para>
        The <literal>show errors</literal> command does not exist in
        <productname>PostgreSQL</productname>, and is not needed since errors are
        reported automatically.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     This is how this function would look when ported to
     <productname>PostgreSQL</productname>:

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEgin
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex2"/> shows how to port a
    function that creates another function and how to handle the
    ensuing quoting problems.
   </para>

   <example id="plpgsql-porting-ex2">
    <title>Porting a Function that Creates Another Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>

    <para>
     The following procedure grabs rows from a
     <command>SELECT</command> statement and builds a large function
     with the results in <literal>IF</literal> statements, for the
     sake of efficiency.
    </para>

    <para>
     This is the Oracle version:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEgin
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEgin';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

    <para>
     Here is how this function would end up in <productname>PostgreSQL</productname>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEgin
    func_body := 'BEgin';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     Notice how the body of the function is built separately and passed
     through <literal>quote_literal</literal> to double any quote marks in it.  This
     technique is needed because we cannot safely use dollar quoting for
     defining the new function: we do not know for sure what strings will
     be interpolated from the <structfield>referrer_key.key_string</structfield> field.
     (We are assuming here that <structfield>referrer_key.kind</structfield> can be
     trusted to always be <literal>host</literal>, <literal>domain</literal>, or
     <literal>url</literal>, but <structfield>referrer_key.key_string</structfield> might be
     anything, in particular it might contain dollar signs.) This function
     is actually an improvement on the Oracle original, because it will
     not generate broken code when <structfield>referrer_key.key_string</structfield> or
     <structfield>referrer_key.referrer_type</structfield> contain quote marks.
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex3"/> shows how to port a function
    with <literal>OUT</literal> parameters and string manipulation.
    <productname>PostgreSQL</productname> does not have a built-in
    <function>instr</function> function, but you can create one
    using a combination of other
    functions.<indexterm><primary>instr</primary></indexterm> In <xref
    linkend="plpgsql-porting-appendix"/> there is a
    <application>PL/pgSQL</application> implementation of
    <function>instr</function> that you can use to make your porting
    easier.
   </para>

   <example id="plpgsql-porting-ex3">
    <title>Porting a Procedure With String Manipulation and
    <literal>OUT</literal> Parameters from <application>PL/SQL</application> to
    <application>PL/pgSQL</application></title>

    <para>
     The following <productname>Oracle</productname> PL/SQL procedure is used
     to parse a URL and return several elements (host, path, and query).
    </para>

    <para>
     This is the Oracle version:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- This will be passed back
    v_path OUT VARCHAR,  -- This one too
    v_query OUT VARCHAR) -- And this one
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEgin
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

    <para>
     Here is a possible translation into <application>PL/pgSQL</application>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- This will be passed back
    v_path OUT VARCHAR,  -- This one too
    v_query OUT VARCHAR) -- And this one
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEgin
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     This function could be used like this:
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex4"/> shows how to port a procedure
    that uses numerous features that are specific to Oracle.
   </para>

   <example id="plpgsql-porting-ex4">
    <title>Porting a Procedure from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>

    <para>
     The Oracle version:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma"/>
BEgin
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable"/>

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- free lock<co id="co.plpgsql-porting-commit"/>
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEgin
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>

   <para>
    Procedures like this can easily be converted into <productname>PostgreSQL</productname>
    functions returning <type>void</type>. This procedure in
    particular is interesting because it can teach us some things:

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-pragma">
      <para>
       There is no <literal>PRAGMA</literal> statement in <productname>PostgreSQL</productname>.
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-locktable">
      <para>
       If you do a <command>LOCK TABLE</command> in <application>PL/pgSQL</application>,
       the lock will not be released until the calling transaction is
       finished.
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-commit">
      <para>
       You cannot issue <command>COMMIT</command> in a
       <application>PL/pgSQL</application> function.  The function is
       running within some outer transaction and so <command>COMMIT</command>
       would imply terminating the function's execution.  However, in
       this particular case it is not necessary anyway, because the lock
       obtained by the <command>LOCK TABLE</command> will be released when
       we raise an error.
      </para>
     </callout>
    </calloutlist>
   </para>

   <para>
    This is how we could port this procedure to <application>PL/pgSQL</application>:

<programlisting>
CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEgin
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEgin
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <co id="co.plpgsql-porting-exception"/>
            -- don't worry if it already exists
    END;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       The syntax of <literal>RAISE</literal> is considerably different from
       Oracle's statement, although the basic case <literal>RAISE</literal>
       <replaceable class="parameter">exception_name</replaceable> works
       similarly.
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       The exception names supported by <application>PL/pgSQL</application> are
       different from Oracle's.  The set of built-in exception names
       is much larger (see <xref linkend="errcodes-appendix"/>).  There
       is not currently a way to declare user-defined exception names,
       although you can throw user-chosen SQLSTATE values instead.
      </para>
     </callout>
    </calloutlist>

    The main functional difference between this procedure and the
    Oracle equivalent is that the exclusive lock on the <literal>cs_jobs</literal>
    table will be held until the calling transaction completes.  Also, if
    the caller later aborts (for example due to an error), the effects of
    this procedure will be rolled back.
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
   <title>Other Things to Watch For</title>

   <para>
    This section explains a few other things to watch for when porting
    Oracle <application>PL/SQL</application> functions to
    <productname>PostgreSQL</productname>.
   </para>

   <sect3 id="plpgsql-porting-exceptions">
    <title>Implicit Rollback after Exceptions</title>

    <para>
     In <application>PL/pgSQL</application>, when an exception is caught by an
     <literal>EXCEPTION</literal> clause, all database changes since the block's
     <literal>BEgin</literal> are automatically rolled back.  That is, the behavior
     is equivalent to what you'd get in Oracle with:

<programlisting>
BEgin
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;
</programlisting>

     If you are translating an Oracle procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in this style,
     your task is easy: just omit the <command>SAVEPOINT</command> and
     <command>ROLLBACK TO</command>.  If you have a procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in a different way
     then some actual thought will be required.
    </para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para>
     The <application>PL/pgSQL</application> version of
     <command>EXECUTE</command> works similarly to the
     <application>PL/SQL</application> version, but you have to remember to use
     <function>quote_literal</function> and
     <function>quote_ident</function> as described in <xref
     linkend="plpgsql-statements-executing-dyn"/>.  Constructs of the
     type <literal>EXECUTE 'SELECT * FROM $1';</literal> will not work
     reliably unless you use these functions.
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
    <title>Optimizing <application>PL/pgSQL</application> Functions</title>

    <para>
     <productname>PostgreSQL</productname> gives you two function creation
     modifiers to optimize execution: <quote>volatility</quote> (whether
     the function always returns the same result when given the same
     arguments) and <quote>strictness</quote> (whether the function
     returns null if any argument is null).  Consult the <xref
     linkend="sql-createfunction"/>
     reference page for details.
    </para>

    <para>
     When making use of these optimization attributes, your
     <command>CREATE FUNCTION</command> statement might look something
     like this:

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
   <title>Appendix</title>

   <para>
    This section contains the code for a set of Oracle-compatible
    <function>instr</function> functions that you can use to simplify
    your porting efforts.
   </para>

<programlisting>
--
-- instr functions that mimic Oracle's counterpart
-- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.
--
-- Searches string1 beginning at the nth character for the mth occurrence
-- of string2.  If n is negative, search backwards.  If m is not passed,
-- assume 1 (search starts at first character).
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEgin
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEgin
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEgin
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
  </sect2>

 </sect1>

</chapter>

<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="user-manag">
 <title>Privilegi e ruoli del database</title>

 <para>
<productname>PostgreSQL</productname> gestisce i permessi di accesso al database
usando il concetto di <firstterm>ruoli</firstterm>. Un ruolo può essere pensato sia come  
un utente del database, sia come gruppo di utenti del database, a seconda di come 
è impostato il ruolo. I ruoli possono possedere gli oggetti del database (per esempio,
tabelle) e possono assegnare privilegi su quegli oggetti ad altri ruoli per 
controllare chi ha accesso a quali oggetti. Inoltre, è possibile 
garantire l'<firstterm>appartenenza</firstterm> a un ruolo a un altro ruolo, permettendo in questo modo
al membro del ruolo di usare i privilegi assegnati a un altro ruolo.
 </para>

 <para>
Il concetto di ruoli comprende i concetti di <quote>utenti</quote> e 
<quote>gruppi</quote>. Nelle versioni di <productname>PostgreSQL</productname>
precedenti la 8.1, utenti e gruppi erano entità diverse, ma adesso ci sono solo 
ruoli. Qualsiasi ruolo può comportarsi come un utente, un gruppo, o entrambi.
 </para>

 <para>
Questo capitolo descrive come creare e gestire i ruoli e introduce
il sistema dei privilegi. Maggiori informazioni sui diversi tipi di 
oggetti del database e gli effetti dei privilegi possono essere trovati in
<xref linkend="ddl"/>.
 </para>

 <sect1 id="database-roles">
  <title>Ruoli del database Database Roles</title>

  <indexterm zone="database-roles">
   <primary>ruolo</primary>
  </indexterm>

  <indexterm zone="database-roles">
   <primary>utente</primary>
  </indexterm>

  <indexterm>
   <primary>CREATE ROLE</primary>
  </indexterm>

  <indexterm>
   <primary>DROP ROLE</primary>
  </indexterm>

  <para>
I ruoli del database sono completamente separati concettualmente dagli 
utenti del sistema operativo. In pratica potrebbe essere conveniente 
mantenere una corrispondenza, ma questo non è richiesto. I ruoli del database
sono globali attraverso l'installazione di un cluster di database (e non 
per singoli database). Per creare un ruolo usare il comando SQL  <xref
linkend="sql-createrole"/>:
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
<replaceable>name</replaceable> segue le regole per gli identificatori SQL: 
sia non adornati senza caratteri speciali, oppore tra doppi apici.
(In pratica, di solito si vorrà aggiungere opzioni addizionali al comando, tipo 
<literal>LOgin</literal>. Maggiori dettagli appaiono sotto.
Per rimuovere un ruolo esistente, usare l'analogo
comando   <xref linkend="sql-droprole"/>:
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
  </para>

  <indexterm>
   <primary>createuser</primary>
  </indexterm>

  <indexterm>
   <primary>dropuser</primary>
  </indexterm>

  <para>
Per convenienza, i programmi <xref linkend="app-createuser"/> 
e <xref linkend="app-dropuser"/> sono fornite come wrapper 
per quei comandi SQL che possono essere lanciati dalla shell:
<synopsis>
createuser <replaceable>name</replaceable>
dropuser <replaceable>name</replaceable>
</synopsis>
  </para>

  <para>
Per determinare l'insieme di ruoli esistenti, esaminare il catalogo di sistema
<structname>pg_roles</structname>, per esempio
<synopsis>
SELECT rolname FROM pg_roles;
</synopsis>
Il meta comando <literal>\du</literal> del programma <xref linkend="app-psql"/>
è utile per elencare i ruoli esistenti.
  </para>

  <para>
Per fare il bootstrap di unsistema di database, un sistema appena installato  
contiene un ruolo predefinito. Questo ruolo è sempre un <quote>superuser</quote>,   
e in maniera predefinita (a meno che non sia stato cambiato con l'<command>initdb</command>)
avrà lo stesso nome dell'utente del sistema operativo che ha inizializzato il cluster di database.
Di norma, questo ruolo sarà chiamato <literal>postgres</literal>. 
Per creare altri ruoli si deve prima connettersi come questo ruolo iniziale.
  </para>

  <para>
Ogni connessione al server di database è fatta usando il nome di qualche ruolo particolare,
e questo ruolo determina i privilegi d'accesso iniziali per i comandi
emessi in quella connessione.
Il nome del ruolo da usare per un particolare connessione al database
è indicato dal client che inizia la richiesta di connessione nel modo specifico
dell'applicazione. Per esempio, 
il programma <command>psql</command> usa l'opzione a linea di comando
<option>-U</option> per indicare il ruolo con cui connettersi.
Molte applicazioni assumono il nome dell'utente corrente del sistema operativo
come predefinito (incluse <command>createuser</command> e <command>psql</command>).
Comunque spesso è conveniente mantenere una corrispondenza di nomi tra 
i ruoli e gli utenti del sistema operativo.
  </para>

  <para>
L'insieme dei ruoli del database coi quali un dato client può connettersi 
è determinato dall'impostazione dell'autenticazione del client, come spiegato in
<xref linkend="client-authentication"/>. (In più, un client non è 
limitato alla possibilità di connettersi come il ruolo corrispondente
al suo utente del sistema operativo, esattamente come il nome di login di una persona 
non deve corrispondere al suo nome reale). Dato che l'identità del ruolo
determina l'insieme di privilegi disponibili a un client connesso,
è importante configurare con cura i privilegi quando si mette su un ambiente multiutente.
  </para>
 </sect1>

 <sect1 id="role-attributes">
  <title>Attributi del ruolo</title>

   <para>
Un ruolo del database può avere un numero di attributi che definisce i suoi 
privilegi e interagisce con il sistema di sutenticazione del client.

    <variablelist>
     <varlistentry>
      <term>privilegio di login<indexterm><primary>privilegio di login</primary></indexterm></term>
      <listitem>
       <para>
Solo i ruoli che hanno l'attributo <literal>LOgin</literal> possono essere usati
come nome del ruolo iniziale di una connessione al database. Un ruolo con
l'attributo <literal>LOgin</literal> può essere considerato come un 
<quote>utente del database</quote>. Per creare un ruolo con i privilegi di login,
usare:
<programlisting>
CREATE ROLE <replaceable>name</replaceable> LOgin;
CREATE USER <replaceable>name</replaceable>;
</programlisting>
(<command>CREATE USER</command> è equivalente a <command>CREATE ROLE</command>
ad eccezione che <command>CREATE USER</command> assume <literal>LOgin</literal> come predefinito,
mentre <command>CREATE ROLE</command> no).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>superuser status<indexterm><primary>superuser</primary></indexterm></term>
      <listitem>
       <para>
Un superutente del database scavalca tutti i controlli di permesso. Questo è un privilegio pericoloso
e non dovrebbe essere usato imprudentemente; è meglio 
fare la maggior parte del lavoro con un ruolo che non è di superutente.
Per creare un nuovo superutente del database, usare <literal>CREATE ROLE
<replaceable>name</replaceable> SUPERUSER</literal>. Questo va fatto
usando un ruolo che è già di superutente.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
        <term>
            creazione del database
            <indexterm>
                <primary>database</primary>
                <secondary>privilegio di creazione</secondary>
            </indexterm>
        </term>
        <listitem>
       <para>
A un ruolo devono essere dati esplicitamente i permessi per creare database
(ad eccezione del superutente, dato che scavalca tutti i controlli di permessi).
Per creare tale ruolo, usare <literal>CREATE ROLE
<replaceable>name</replaceable> CREATEDB</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>creazione di ruolo<indexterm><primary>role</primary><secondary>privilege di creazione</secondary></indexterm></term>
      <listitem>
       <para>
A un ruolo deve essere dato esplicitamente il permesso di creare altri ruoli
(ad eccezione dei superutenti, dato che questi scavalcano tutti i controlli dei permessi).
Per creare tale ruolo,  usare <literal>CREATE ROLE
<replaceable>name</replaceable> CREATEROLE</literal>.
Un ruolo con privilegio <literal>CREATEROLE</literal> può modificare ed eliminare
altri ruoli, anche, così come garantire o revocare l'appartenenza ad essi.
Comunque, per creare, modificare, eliminare o cambiare l'appartenenza a
un ruolo di superutente, è richiesto lo status di superutente;
<literal>CREATEROLE</literal> è insufficiente a fare ciò.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>password<indexterm><primary>password</primary></indexterm></term>
      <listitem>
       <para>
Una password è significativa solo se il metodo di autenticazione del client
richiede che l'utente fornisca una password quando si connette
al database. I metodi di autenticazione <option>password</option> e
<option>md5</option> fanno uso delle password. Le password di database sono separate
dalle password del sistema operativo. Specificare una password durante la creazione di un ruolo con
<literal>CREATE ROLE <replaceable>name</replaceable> PASSWORD '<replaceable>string</replaceable>'</literal>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

Gli attributi di un ruolo possono essere modificati dopo la creazione con
<command>ALTER ROLE</command>.<indexterm><primary>ALTER ROLE</primary></indexterm>
Si vedano le pagine di riferimento dei comandi <xref linkend="sql-createrole" />
e <xref linkend="sql-alterrole"/> per dettagli.
   </para>

  <tip>
   <para>
È buona prassi creare un ruolo che ha i privilegi <literal>CREATEDB</literal>
e <literal>CREATEROLE</literal>, ma che non è un superutente, e quindi usare questo ruolo 
per tutte le operazioni di gestione dei database e dei ruoli. Questo approccio
evita i pericoli di operare come un superutente per compiti che in realtà non lo 
necessitano.
   </para>
  </tip>

  <para>
Un ruolo può anche avere valori predefiniti per molte impostazioni di configurazione 
descritte in <xref
linkend="runtime-config"/>.  Per esempio, se per qualche ragione 
si vogliono disabilitare le scansioni di indice (consiglio: non è una buona idea) ogni volta che ci si connette,
è possibile usare:
<programlisting>
ALTER ROLE myname SET statement_timeout = '5min';
</programlisting>
Questo salverà le impostazioni (ma non le renderà effettive immediatamente). In
connessioni successive di questo ruolo apparirà come se 
<literal>SET statement_timeout = '5min'</literal> fosse stato eseguito 
appena prima che la sessione cominciasse.
È comunque possibile modificare questa impostazione durante la sessione; essa sarà solo la predefinita. 
Per rimuovere un'impostazione predefinita specifica di un ruolo, usare
<literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>.
Notare che i valori predefiniti specifici di un ruolo attaccatti a ruoli senza il privilegio di 
<literal>LOgin</literal> sono abbastanza inutili, dato che non saranno mai invocati.
  </para>
 </sect1>

 <sect1 id="privileges">
  <title>Privileges</title>

  <indexterm zone="privileges">
   <primary>privilege</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>owner</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>REVOKE</primary>
  </indexterm>

  <para>
   When an object is created, it is assigned an owner. The
   owner is normally the role that executed the creation statement.
   For most kinds of objects, the initial state is that only the owner
   (or a superuser) can do anything with the object. To allow
   other roles to use it, <firstterm>privileges</firstterm> must be
   granted.
   There are several different kinds of privilege: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
   <literal>EXECUTE</literal>, and <literal>USAGE</literal>.
   For more information on the different types of privileges supported by
   <productname>PostgreSQL</productname>, see the
   <xref linkend="sql-grant"/> reference page.
  </para>

  <para>
   To assign privileges, the <command>GRANT</command> command is
   used. So, if <literal>joe</literal> is an existing role, and
   <literal>accounts</literal> is an existing table, the privilege to
   update the table can be granted with:
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   The special name <literal>PUBLIC</literal> can
   be used to grant a privilege to every role on the system. Writing
   <literal>ALL</literal> in place of a specific privilege specifies that all
   privileges that apply to the object will be granted.
  </para>

  <para>
   To revoke a privilege, use the fittingly named
   <xref linkend="sql-revoke"/> command:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
  </para>

  <para>
   The special privileges of an object's owner (i.e., the right to modify
   or destroy the object) are always implicit in being the owner,
   and cannot be granted or revoked.  But the owner can choose
   to revoke his own ordinary privileges, for example to make a
   table read-only for himself as well as others.
  </para>

  <para>
   An object can be assigned to a new owner with an <command>ALTER</command>
   command of the appropriate kind for the object.  Superusers can always do
   this; ordinary roles can only do it if they are both the current owner
   of the object (or a member of the owning role) and a member of the new
   owning role.
  </para>
 </sect1>

 <sect1 id="role-membership">
  <title>Role Membership</title>

  <indexterm zone="role-membership">
   <primary>role</primary><secondary>membership in</secondary>
  </indexterm>

  <para>
   It is frequently convenient to group users together to ease
   management of privileges: that way, privileges can be granted to, or
   revoked from, a group as a whole.  In <productname>PostgreSQL</productname>
   this is done by creating a role that represents the group, and then
   granting <firstterm>membership</firstterm> in the group role to individual user
   roles.
  </para>

  <para>
   To set up a group role, first create the role:
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
   Typically a role being used as a group would not have the <literal>LOgin</literal>
   attribute, though you can set it if you wish.
  </para>

  <para>
   Once the group role exists, you can add and remove members using the
   <xref linkend="sql-grant"/> and
   <xref linkend="sql-revoke"/> commands:
<synopsis>
GRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis>
   You can grant membership to other group roles, too (since there isn't
   really any distinction between group roles and non-group roles).  The
   database will not let you set up circular membership loops.  Also,
   it is not permitted to grant membership in a role to
   <literal>PUBLIC</literal>.
  </para>

  <para>
   The members of a group role can use the privileges of the role in two
   ways.  First, every member of a group can explicitly do
   <xref linkend="sql-set-role"/> to
   temporarily <quote>become</quote> the group role.  In this state, the
   database session has access to the privileges of the group role rather
   than the original login role, and any database objects created are
   considered owned by the group role not the login role.  Second, member
   roles that have the <literal>INHERIT</literal> attribute automatically inherit the
   privileges of roles of which they are members, including their
   <literal>INHERIT</literal> attributes.  As an example, suppose we have
   done:
<programlisting>
CREATE ROLE joe LOgin INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
</programlisting>
   Immediately after connecting as role <literal>joe</literal>, a database
   session will have use of privileges granted directly to <literal>joe</literal>
   plus any privileges granted to <literal>admin</literal>, because <literal>joe</literal>
   <quote>inherits</quote> <literal>admin</literal>'s privileges.  However, privileges
   granted to <literal>wheel</literal> are not available, because even though
   <literal>joe</literal> is indirectly a member of <literal>wheel</literal>, the
   membership is via <literal>admin</literal> which has the <literal>NOINHERIT</literal>
   attribute.  After:
<programlisting>
SET ROLE admin;
</programlisting>
   the session would have use of only those privileges granted to
   <literal>admin</literal>, and not those granted to <literal>joe</literal>.  After:
<programlisting>
SET ROLE wheel;
</programlisting>
   the session would have use of only those privileges granted to
   <literal>wheel</literal>, and not those granted to either <literal>joe</literal>
   or <literal>admin</literal>.  The original privilege state can be restored
   with any of:
<programlisting>
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
</programlisting>
  </para>

  <note>
   <para>
    The <command>SET ROLE</command> command always allows selecting any role
    that the original login role is directly or indirectly a member of.
    Thus, in the above example, it is not necessary to become
    <literal>admin</literal> before becoming <literal>wheel</literal>.
   </para>
  </note>

  <note>
   <para>
    In the SQL standard, there is a clear distinction between users and roles,
    and users do not automatically inherit privileges while roles do.  This
    behavior can be obtained in <productname>PostgreSQL</productname> by giving
    roles being used as SQL roles the <literal>INHERIT</literal> attribute, while
    giving roles being used as SQL users the <literal>NOINHERIT</literal> attribute.
    However, <productname>PostgreSQL</productname> defaults to giving all roles
    the <literal>INHERIT</literal> attribute, for backwards compatibility with pre-8.1
    releases in which users always had use of permissions granted to groups
    they were members of.
   </para>
  </note>

  <para>
   The role attributes <literal>LOgin</literal>, <literal>SUPERUSER</literal>,
   <literal>CREATEDB</literal>, and <literal>CREATEROLE</literal> can be thought of as
   special privileges, but they are never inherited as ordinary privileges
   on database objects are.  You must actually <command>SET ROLE</command> to a
   specific role having one of these attributes in order to make use of
   the attribute.  Continuing the above example, we might choose to
   grant <literal>CREATEDB</literal> and <literal>CREATEROLE</literal> to the
   <literal>admin</literal> role.  Then a session connecting as role <literal>joe</literal>
   would not have these privileges immediately, only after doing
   <command>SET ROLE admin</command>.
  </para>

  <para>
  </para>

  <para>
   To destroy a group role, use <xref
   linkend="sql-droprole"/>:
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
   Any memberships in the group role are automatically revoked (but the
   member roles are not otherwise affected).  Note however that any objects
   owned by the group role must first be dropped or reassigned to other
   owners; and any permissions granted to the group role must be revoked.
  </para>
 </sect1>

 <sect1 id="perm-functions">
  <title>Function and Trigger Security</title>

  <para>
   Functions and triggers allow users to insert code into the backend
   server that other users might execute unintentionally. Hence, both
   mechanisms permit users to <quote>Trojan horse</quote>
   others with relative ease. The only real protection is tight
   control over who can define functions.
  </para>

  <para>
   Functions run inside the backend
   server process with the operating system permissions of the
   database server daemon.  If the programming language
   used for the function allows unchecked memory accesses, it is
   possible to change the server's internal data structures.
   Hence, among many other things, such functions can circumvent any
   system access controls.  Function languages that allow such access
   are considered <quote>untrusted</quote>, and
   <productname>PostgreSQL</productname> allows only superusers to
   create functions written in those languages.
  </para>
 </sect1>

</chapter>

<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="indexes">
 <title>Indici</title>

 <indexterm zone="indexes">
  <primary>indice</primary>
 </indexterm>

 <para>
  Gli indici sono un comune mezzo per migliorare le prestazioni del database. Un
  indice consente al server di database di trovare e recuperare le righe specifiche molto
  più velocemente di quanto potrebbe fare senza un indice. Ma essi rappresentano anche
  un carico aggiuntivo all'intero sistema di database, per cui dovrebbero essere usati 
  assennatamente.
 </para>


 <sect1 id="indexes-intro">
  <title>Introduzione</title>

  <para>
   Supponendo di avere una tabella simile a questa:
<programlisting>
CREATE TABLE test1 (
    id integer,
    content varchar
);
</programlisting>
   e che l'applicazione richiede molte query della forma:
<programlisting>
SELECT content FROM test1 WHERE id = <replaceable>constant</replaceable>;
</programlisting>
   Senza una preparazione avanzata, il sistema dovrebbe scandire l'intera
   tabella <structname>test1</structname>, riga per riga, per cercare tutte
   le corrispondenze. Se ci sono molte righe in <structname>test1</structname>
   e solo alcune di esse (forse solo zero o una) verrebbero restituite da una
   tale query, questo sarebbe chiaramente un metodo inefficiente. Ma se il
   sistema è stato istruito per mantenere un indice sulla colonna
   <structfield>id</structfield>, esso potrà usare un metodo più
   efficiente per localizzare le righe corrispondenti. Per esempio, è
   probabile che esso debba scorrere solo qualche livello in un albero di ricerca.
  </para>

  <para>
   Un approccio simile è usato nei libri non-romanzeschi: i termini e
   i concetti che sono cercati frequentemente dai lettori sono raccolti in
   un indice alfabetico alla fine del libro. Il lettore interessato
   può scandire l'indice e andare alla pagina appropriata,
   senza dover leggere l'intero libro per trovare il
   materiale interessato. Come è incarico dell'autore
   prevedere gli elementi che i lettori ricercheranno,
   è compito del programmatore di database prevedere quali
   indici saranno vantaggiosi.
  </para>

  <para>
   Per creare l'indice nella colonna <structfield>id</structfield>,
   come discusso sopra, si potrà usare il seguente comando:
<programlisting>
CREATE INDEX test1_id_index ON test1 (id);
</programlisting>
   Il nome <structname>test1_id_index</structname> può essere scelto
   liberamente, ma bisogna scegliere qualcosa che consenta di ricordare
   in seguito per cosa è stato creato l'indice.
  </para>

  <para>
   Per rimuovere un indice, usare il comando <command>DROP INDEX</command>.
   Gli indici possono essere aggiunti e rimossi dalle tabelle in qualsiasi momento.
  </para>

  <para>
   
Una volta creato l'indice, nessun intervento ulteriore è richiesto: Il
   sistema aggiornerà l'indice quando la tabella viene modificata, e lo
   utilizzerà nelle query quando pensa che il suo utilizzo sarà
   più efficiente rispetto ad una scansione sequenziale della tabella. 
   Ma potreste dover attivare regolarmente il comando <command>ANALYZE</command>
   per aggiornare le statistiche in modo che il planner delle query prenda decisioni
   erudite. Consultare il <xref linkend="performance-tips" /> per aver informazioni
   su come scoprire se un indice è usato e quando e perchè il 
   planner potrebbe scegliere di <emphasis>non</emphasis> usare un indice.
  </para>

  <para>
   Gli indici possono trarre beneficio dai comandi <command>UPDATE</command> e
   <command>DELETE</command> con le condizioni di ricerca. Gli indici
   possono essere inoltre usati nelle ricerche join. Per cui, un indice
   definito su una colonna che è parte di una condizione join può
   aumentare significativamente la velocità della query con join.
  </para>

  <para>
   
    Creare un indice in una grande tabella può richiedere molto tempo. Per impostazione
   predefinita,<productname>PostgreSQL</productname> consente che le letture (select) avvengano
   sulla tabella in parallelo con la creazione di un indice, mentre le scritture (insert,
   update, delete) saranno bloccate fino a che la costruzione dell'indice non è finita.
   In ambienti di produzione questo è spesso inaccettabile. 
   È possibile consentire alle scritture di verificarsi in parallelo con la creazione
   dell'indice, ma bisogna considerare diversi avvertimenti &mdash;
   per ulteriori informazioni consultare <xref linkend="sql-createindex-CONCURRENTLY"
   endterm="sql-createindex-CONCURRENTLY-title" />.
  </para>

  <para>
   Dopo aver creato un indice, il sistema deve mantenerlo sincronizzato con la
   tabella. Questo aggiunge un carico alle operazioni di manipolazione dei dati.
   Per cui gli indici che vengono usati raramente o mai nelle query,
   dovrebbero essere rimossi.
  </para>
 </sect1>


 <sect1 id="indexes-types">
  <title>Tipi di indice</title>

  <para>
   
    <productname>PostgreSQL</productname> fornisce diversi tipi di indici:
   B-tree, Hash, gist and gin. Ogni tipo di indice utilizza differenti
   algoritmi che si adattano ai diversi tipi di query. Per impostazione
   predefinita, il comando <command>CREATE INDEX</command> crea un
   indice B-tree, che è adatto alle situazioni più comuni.
  </para>

  <para>
   <indexterm>
    <primary>indice</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <see>indice</see>
   </indexterm>
   
   I  B-tree possono gestire query di uguaglianza e di intervallo sui dati
   che possono essere ordinati qualsiasi modo. In particolare, il planner
   delle query di <productname>PostgreSQL</productname> considera la
   possibilità di usare un indice B-tree quando una colonna indicizzata
   è coinvolta in un confronto utilizzando uno di questi operatori:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   
    Strutture equivalenti a combinazioni di questi operatori, quali
   <literal>BETWEEN</literal> e <literal>IN</literal>, possono anche essere implementate con
   un indice di ricerca B-tree. Anche una condizione <literal>IS NULL</literal> su
   una colonna indicizzata può essere usata con un indice B-tree.
  </para>

  <para>
   
    L'ottimizzatore può anche usare un indice B-tree per query che
   coinvologono gli operatori di corrispondenza di modello <literal>LIKE</literal>
   e <literal>~</literal> <emphasis>se</emphasis> il modello è una
   costante ed è ancorato all'inizio della stringa &mdash; per esempio,
   <literal>col LIKE 'foo%'</literal> o <literal>col ~ '^foo'</literal>, ma
   non <literal>col LIKE '%bar'</literal>. Tuttavia, se il proprio server non
   usa il C locale bisognerà creare l'indice con una speciale classe
   di operatore per supportare l'indicizzazione delle query di
   corrispondenza-modelli. Consultare <xref linkend="indexes-opclass" /> sotto.
   È anche possibile usare gli indici B-tree per <literal>ILIKE</literal>
   and <literal>~*</literal>, ma solo se il modello inizia con caratteri
   non-alfabetici, cioè caratteri che non sono interessati dalla
   conversione maisucolo/minuscolo.   
  </para>


  <para>
   <indexterm>
    <primary>indice</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>indice</see>
   </indexterm>
   Gli indici hash possono gestire solo semplici confronti di uguaglianza.
   Il planner delle query considererà l'utilizzo di un indice hash quando una
   colonna indicizzata viene coinvolta in un confronto che utilizza
   l'operatore <literal>=</literal>. (Ma gli indici hash non supportano
   ricerche <literal>IS NULL</literal>).
   Il seguente comando viene utilizzato per creare un indice hash:
  
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING hash (<replaceable>column</replaceable>);
</synopsis>
  </para>

  <note>
   <para>
    
    Le operazioni sugli indici
    hash non sono attualmente registrate da WAL, per cui gli indici hash potrebbero
    aver bisogno di essere ricostruiti con <command>REINDEX</command>
    dopo un crash del database.
    Per questi motivi, l'uso degli indici hash è attualmente sconsigliato. 
   </para>
  </note>

  <para>
   <indexterm>
    <primary>indice</primary>
    <secondary>gist</secondary>
   </indexterm>
   <indexterm>
    <primary>gist</primary>
    <see>indice</see>
   </indexterm>

   Gli indici gist non sono un singolo tipo di indice, ma piuttosto una infrastruttura
   nella quale diverse strategie di indicizzazione possono essere implementate.
   Di conseguenza, i particolari operatori con i quali l'indice gist può
   essere usato variano secondo la strategia di indicizzazione (la
   <firstterm>classe operatore</firstterm>). Come esempio, la distribuzione standard di
   <productname>PostgreSQL</productname> include la classe operatore gist
   per diversi tipi di dati geometrici bidimensionali, essa supporta le query
   indicizzate che utilizzano questi operatori:
   
   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   
    (Consultare <xref linkend="functions-geometry" /> per il significato di
   questi operatori).
   Diverse altre classi di operatori gist
   sono disponibili nel gruppo <literal>contrib</literal> o come progetti
   separati. Per ulteriori informazioni consultare il <xref linkend="gist" />.
  </para>
  <para>
   <indexterm>
    <primary>indice</primary>
    <secondary>gin</secondary>
   </indexterm>
   <indexterm>
    <primary>gin</primary>
    <see>indice</see>
   </indexterm>

   Gli indici gin sono indici invertiti che possono gestire valori che contengono
   più di una chiave, per esempio gli array. Come per gist, gin può supportare
   molte differenti strategie di indicizzazione definite dall'utente, ed i particolari
   operatori con i quali un indice gin può essere usato, variano in dipendenza
   della strategia di indicizzazione.
   Come esempio, la distribuzione standard di
   <productname>PostgreSQL</productname> include classi di operatore gin
   per array mono-dimensionali, le quali supportano query indicizzate
   che utilizzano questi operatori: 
   
   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   
    (Consultare <xref linkend="functions-array" /> per trovare il significato di
   questi operatori).
   Diverse altre classi di operatori gin
   sono disponibili nel gruppo <literal>contrib</literal> o come progetti
   separati. Per ulteriori informazioni consultare il <xref linkend="gin" />.
  </para>
 </sect1>


 <sect1 id="indexes-multicolumn">
  <title>Indici multicolonna</title>

  <indexterm zone="indexes-multicolumn">
   <primary>indice</primary>
   <secondary>multicolonna</secondary>
  </indexterm>

  <para>
   Un indice può essere definito su più di una colonna di una tabella. Per esempio,
   avendo una tabella di questo tipo:
<programlisting>
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</programlisting>
   (Supponendo di avere la propria directory <filename class="directory">/dev</filename>
   in un database....) ed effettuando frequentemente query del tipo:
<programlisting>
SELECT name FROM test2 WHERE major = <replaceable>constant</replaceable> AND minor = <replaceable>constant</replaceable>;
</programlisting>
   then it might be appropriate to define an index on the columns
   <structfield>major</structfield> and
   <structfield>minor</structfield> together, e.g.:
<programlisting>
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</programlisting>
  </para>

  <para>
   
    Attualmente, solo gli indici di tipo B-tree e gist supportano gli indici multicolonna.
   Possono essere specificate fino a 32 colonne. (Questo limite può essere
   modificato quando si configura <productname>PostgreSQL</productname>; Consultare
   il file <filename>pg_config_manual.h</filename>.)
  </para>

  <para>
    Un indice B-tree multicolonna può essere usato con query che coinvolgono
   qualsiasi sottoinsieme delle colonne dell'indice, ma l'indice è molto
   più efficiente quando ci sono vincoli sulle colonne in testa (all'estrema
   sinistra). La regola esatta è che vincoli di uguaglianza sulle colonne in
   testa, più tutti i vincoli di diseguaglianza sulla prima colonna che non
   ha un vincolo di uguaglianza, saranno usati per limitare la porzione dell'indice
   che viene scandita. I vincoli sulle colonne alla destra di queste colonne sono
   controllati nell'indice, per cui essi risparmiano consultazioni alla propria tabella,
   ma non riducono la porzione dell'indice che deve essere scandita. Per esempio,
   dato un indice su <literal>(a, b, c)</literal> e una condizione della query
   <literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</literal>, l'indice dovrebbe essere
   scandito dalla prima voce con <literal>a</literal> = 5 e <literal>b</literal> = 42 e
   superiori fino all'ultima voce con <literal>a</literal> = 5. Le voci dell'indice con
   <literal>c</literal> &gt;= 77 verrebbero saltate, ma dovranno tuttavia essere scandite.
   Questo indice potrebbe in linea di principio essere usato per query che hanno
   vincoli su <literal>b</literal> e/o <literal>c</literal> e senza nessun vincolo su <literal>a</literal>
   &mdash; ma l'intero indice dovrà essere scandito, per cui nella maggior
   parte dei casi il planner preferirebbe una scansione sequenziale della tabella  
   all'utilizzo dell'indice.

  </para>

  <para>
    Un indice gist multicolonna può essere usato con query che
   coinvolgono qualunque sottoinsieme delle colonne dell'indice. Condizioni su colonne
   supplementari restringono le voci restituite dall'indice, ma la condizione sulla
   prima colonna è quella più importante per determinare quanta parte
   dell'indice deve essere scandita. Un indice gist sarà relativamente
   inefficace se la sua prima colonna ha solo alcuni valori distinti, anche se
   ci sono molti valori distinti nelle colonne supplementari.
  </para>

  <para>
        Un indice gin multicolonna può essere usato con  query che 
        coinvolgono qualsiasi sottoinsieme di colonne di indice. A differenza dei B-Tree o dei gist,
        l'efficienza dell'indice di ricerca è la stessa qualunque colonna/e indice  
        venga usata dalla query.
  </para>

  <para>
    Naturalmente, ogni colonna dovrà essere usata con operatori appropriati al tipo
    di indice; Clausule che coinvolgono altri operatori non dovranno essere considerate.
  </para>

  <para>
   Gli indici multicolonna dovranno essere usati con parsimonia. Nella maggiorf parte delle
   situazioni, un indice su una singola colonna è sufficiente e salva spazio e tempo.
   Gli indici con più di tre colonne è improbabile che vengano usati a meno
   che l'utilizzo della tabella non sia estremamente stilizzato. Consultare anche
   <xref linkend="indexes-bitmap-scans" /> per ulteriori discussioni in merito alle
   diverse impostazioni degli indici.
  </para>
 </sect1>


 <sect1 id="indexes-ordering">
  <title>Indici e <literal>ORDER BY</literal></title>

  <indexterm zone="indexes-ordering">
   <primary>indice</primary>
   <secondary>e <literal>ORDER BY</literal></secondary>
  </indexterm>

  <para>
    In aggiunta alla semplice ricerca delle righe che saranno restituite da una query,
   un indice può essere in grado di fornirle ordinate in una specificata maniera.
   Questo consente che una specificazione <literal>ORDER BY</literal> di una query sia
   soddisfatta senza una separata fase di ordinamento. Dei tipi di indice attualmente
   supportati da <productname>PostgreSQL</productname>, solo i B-tree possono produrre
   uscite ordinate &mdash; gli altri tipi di indice restituiscono le righe corrispondenti
   in un ordine non specificato e dipendente dall'implementazione. 
  </para>

  <para>
   
    Il planner considererà soddisfatta una specificazione <literal>ORDER BY</literal>
   o tramite la scansione di tutti gli indici disponibili che soddisfano la specificazione
   oppure tramite la scansione della tabella nell'ordine fisico e facendo un ordinamento
   esplicito. Per una query che richiede di scansionare una grande frazione della tabella,
   l'ordinamento esplicito sarà probabilmente più veloce perchè 
   richiede meno accessi I/O su disco dovuti ad un modello di accesso meglio-ordinato, Gli
   indici sono più utili quando solo poche righe hanno bisogno di essere prelevate.
   Un caso particolarmente importante è <literal>ORDER BY</literal> in combinazione con
   <literal>LIMIT</literal> <replaceable>n</replaceable>: un ordinamento esplicito che dovrà processare
   tutti i dati per identificare le prime <replaceable>n</replaceable> righe, ma se c'è
   un indice che abbina l'<literal>ORDER BY</literal> allora le prime <replaceable>n</replaceable>
   righe  possono essere recuperate direttamente, senza scandire per niente il resto. 
  </para>

  <para>
   
    Per impostazione predefinita, gli indici B-tree memorizzano le loro voci in ordine
   ascendente con i null in fondo. Questo significa che una scansione in avanti di un
   indice su una colonna <literal>x</literal> produce un uscita che soddisfa <literal>ORDER BY x</literal>
   (o più verbosamente, <literal>ORDER BY x ASC NULLS LAST</literal>). L'indice
   può anche essere scandito all'indietro, producendo un uscita che soddisfa
   <literal>ORDER BY x DESC</literal>
   (o più verbosamente, <literal>ORDER BY x DESC NULLS FIRST</literal>, dato che
   <literal>NULLS FIRST</literal> è l'impostazione predefinita 
    per <literal>ORDER BY DESC</literal>).
  </para>

  <para>
   È possibile modificare l'ordinamento di un indice B-tree includendo
   le opzioni <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</literal>,
   e/o <literal>NULLS LAST</literal> quando si crea l'indice; Per esempio:
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</programlisting>
   Un indice memorizzato in ordine ascendente con i null in testa può essere
   soddisfatto sia da <literal>ORDER BY x ASC NULLS FIRST</literal> che da
   <literal>ORDER BY x DESC NULLS LAST</literal> in dipendenza della direzione nella quale
   esso viene scansionato.
  </para>

  <para>
   
    È lecito domandarsi perchè fornire tutte le quattro opzioni, quando due
   opzioni insieme con le possibilità di scansione a rovescio coprirebbero
   tutte le varianti di <literal>ORDER BY</literal>. Negli indici a singola colonna 
   le opzioni sono veramente rindondanti, ma negli indici multicolonna essi possono essere
   utili. Considerare un indice a due-colonne su <literal>(x, y)</literal>: questo può
   soddisfare <literal>ORDER BY x, y</literal> se si scandisce in avanti, oppure
   <literal>ORDER BY x DESC, y DESC</literal> se si scandisce all'indietro.
   Ma è probabile che l'applicazione necessita di usare frequentemente
   <literal>ORDER BY x ASC, y DESC</literal>. Non c'è alcun modo per ottenere quell'ordinamento
   da un indice regolare, ma sarà possibile se l'indice viene definito come
   <literal>(x ASC, y DESC)</literal> o <literal>(x DESC, y ASC)</literal>.
  </para>

  <para>
   
    Ovviamente, gli indici con un ordinamento di tipo non-predefinito sono una
   caratteristica avanzata, ma qualche volta possono produrre
   notevoli velocizzazioni per certe query. Se conviene mantenere un tale indice
   dipende da quanto spesso si utilizzano le query che richiedono uno speciale
   tipo di ordinamento. 
  </para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
  <title>Combinare indici multipli</title>

  <indexterm zone="indexes-bitmap-scans">
   <primary>indice</primary>
   <secondary>combinare infici multipli</secondary>
  </indexterm>

  <indexterm zone="indexes-bitmap-scans">
   <primary>bitmap scan</primary>
  </indexterm>

  <para>
   
    Una singola scansione di indice può usare solamente clausule di query che utilizzano
   le colonne dell'indice con operatori della sua classe di operatori e che sono unite con
   <literal>AND</literal>. Per esempio, dato un indice su <literal>(a, b)</literal>
   una condizione di query tipo <literal>WHERE a = 5 AND b = 6</literal> potrebbe
   utilizzare l'indice, ma una query tipo <literal>WHERE a = 5 OR b = 6</literal> non potrebbe
   utilizzare direttamente l'indice.
  </para>

  <para>
    Forunatamente,
   <productname>PostgreSQL</productname> ha la capacità di combinare indici multipli
   (compresi usi multipli dello stesso indice) per gestire casi che non possono essere
   implementati con una singola scansione dell'indice. Il sistema può formare
   condizioni <literal>AND</literal> e <literal>OR</literal> tramite diverse scansioni dell'indice.
   Per esempio, una query tipo <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal>
   può essere suddivisa in quattro separate scansioni di un indice su <literal>x</literal>,
   ogni scansione userà una delle quattro clausule. I risultati di queste scansioni
   vengono poi sottoposti ad OR per produrre il risultato. Un altro esempio è che,
   se si hanno indici separati su <literal>x</literal> e <literal>y</literal>, una possibile implementazione
   di una query tipo <literal>WHERE x = 5 AND y = 6</literal> è di usare ogni indice con la
   appropriata clausula della query e quindi sottoporre a AND i due risultati di indice per
   identificare le righe risultanti.
  </para>

  <para>
Per combinare indici multipli, il sistema scansiona ogni indice necessario e
pepara una <firstterm>mappa di bit</firstterm> in memoria con le locazioni delle
righe della tabella che sono riportate come corrispondenti alle condizioni di quell'indice.
Le mappe di bit sono quindi sottoposte a AND od OR come richiesto dalla query.
Infine, le righe effettive della tabella sono visitate e restituite. Le righe della tabella
sono visitate in ordine fisico, perchè così è descritta la mappa di bit; 
Questo significa che ogni ordinamento degli indici originali viene perso, e
quindi un passo di ordinamento separato sarà necessario se la query ha una clausola <literal>ORDER
BY</literal>. Per questa ragione, e siccome ogni scansione di indice addizionale 
aggiunge tempo extra, il planner a volte sceglierà di usare una scansione di indice semplice, 
sebbene indici addizionali siano disponibili e possono essere stati usati. 
   
  </para>

  <para>
   In tutte le applicazioni, ci sono diverse combinazioni di indici che possono
   essere utilizzate e lo sviluppatore del database deve accettare un compromesso
   per decidere quali indici utilizzare. A volte gli indici multicolonna sono i
   migliori, altre volte è meglio creare indici separati e contare sulla
   caratteristica di combinazione degli indici. Per esempio, se il proprio carico di
   lavoro comprende un insieme di query che qualche volta coinvolgono solo la
   colonna <literal>x</literal>, qualche volta solo la colonna <literal>y</literal> ed altre
   volte ambedue le colonne, si potrebbe scegliere di creare due indici separati
   su <literal>x</literal> e <literal>y</literal>, contando sulla combinazione di indici per
   trattare le query che utilizzano ambedue le colonne. Si potrebbe anche creare un
   indice multicolonna su <literal>(x, y)</literal>. Questo indice sarebbe normalmente 
   più efficace della combinazione di indici per le query che coinvolgono
   entrambe le colonne, ma come spiegato in <xref linkend="indexes-multicolumn" />,
   sarebbe quasi inutile per le query che coinvologono solo <literal>y</literal>, per
   cui non dovrebbe  essere l'unico indice. Una combinazione di un indice multicolonna
   e di un indice separato su <literal>y</literal> funzionerebbe abbastanza bene. Per le query
   che coinvolgono solo <literal>x</literal>, si potrebbe anche usare l'indice multicolonna,
   nonstante sia più grande e quindi più lento di un indice sulla sola
   <literal>x</literal>. L'ultima alternativa è di creare tutti e tre gli indici, ma
   questo è probabilmente accettabile solo se la tabella viene cercata molto
   più spesso di quanto viene aggiornata e se tutti e tre i tipi di query sono
   comuni. Se uno dei tre tipi di query è molto meno comune degli altri,
   probabilmente basterà creare solo i due indici che meglio confronteranno i
   tipi comuni.   

  </para>

 </sect1>


 <sect1 id="indexes-unique">
  <title>Indici unique</title>

  <indexterm zone="indexes-unique">
   <primary>indice</primary>
   <secondary>unique</secondary>
  </indexterm>

  <para>
   Gli indici possono ache essere usati per imporre l'unicità del valore di una
   colonna, o l'unicità dei valori combinati di più di una colonna. 
<synopsis>
CREATE UNIQUE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <optional>, ...</optional>);
</synopsis>
   Attualmente, possono essere dichiarati unique solo gli indici B-tree.
  </para>

  <para>
   
    Quando un indice è dichiarato unique,  non è consentito che valori di
   indice uguali siano presenti su più di una riga. I valori null non sono
   considerati uguali. Un indice unique multicolonna può rifiutare solamente i
   casi dove tutte le colonne dell'indice sono uguali in righe multiple.  
  </para>

  <para>
   Quando per una tabella si definisce un vincolo unique o una chiave primaria,
   <productname>PostgreSQL</productname> crea automaticamente un indice unique.
   L'indice comprende le colonne che fanno parte della chiave primaria o le
   colonne unique (un indice multicolonna, se adatto), ed è il meccanismo
   che impone il vincolo.  
  </para>

  <note>
   <para>
    
    Il modo migliore per aggiungere un vincolo unique ad una tabella è
    <literal>ALTER TABLE ... ADD CONSTRAINT</literal>. L'uso di indici
    per imporre vincoli unique potrebbe essere considerato un dettaglio
    di implementazione che non dovrebbe essere acceduto direttamente.
    Bisognerebbe, comunque, essere consapevoli che non c'è
    bisogno di creare manualmente indici su colonne unique; Facendo questo,
    si duplicherebbe solamente l'indice creato automaticamente.
   </para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
  <title>Indici sulle espressioni</title>

  <indexterm zone="indexes-expressional">
   <primary>indice</primary>
   <secondary sortas="expressions">sulle espressioni</secondary>
  </indexterm>

  <para>
   Una colonna indice non deve necessariamente essere una colonna della tabella sottostante,
   ma può essere una funzione o una espressione scalare calcolata da una o
   più colonne della tabella. Questa caratteristica è utile per ottenere accesso
   veloce alle tabelle basate sui risultati dei calcoli.
  </para>

  <para>
   Per esempio, un modo comune per effettuare un confronto non sensibile alle maiuscole è
   quello di usare la funzione <function>lower</function>:
<programlisting>
SELECT * FROM test1 WHERE lower(col1) = 'value';
</programlisting>
   Questa query può usare un indice, se è stato
   definito sul risultato della funzione
   <literal>lower(col1)</literal>:
<programlisting>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</programlisting>
  </para>

  <para>
   
    Dichiarando questo indice <literal>UNIQUE</literal>, si impedisce la creazione di righe in
   cui i valori di <literal>col1</literal> differiscono solo nel tipo di carattere (maiuscolo o
   minuscolo), oltre a quelle in cui i valori di <literal>col1</literal> sono veramente identici.
   Per cui, gli indici nelle espressioni possono essere usati per far rispettare vincoli
   che non sono definibili come semplici vincoli unique.
  </para>

  <para>
   Come ulteriore esempio, se si utilizzano spesso query come questa:
<programlisting>
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
</programlisting>
   potrebbe essere utile la creazione di un indice come questo:
<programlisting>
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
</programlisting>
  </para>

  <para>
   La sintassi del comando <command>CREATE INDEX</command> richiede normalmente
   di racchiudere tra parentesi le espressioni indice, come mostrato nel secondo
   esempio. Le parentesi possono essere omesse quando l'espressione è 
   solo una chiamata di funzione, come nel primo esempio.
  </para>

  <para>
   
    Le espressioni indice sono relativamente dispendiose da mantenere, perchè le
   espressioni derivate devono essere calcolate per ogni riga negli inserimenti ed ogni
   volta che c'è un aggiornamento. Tuttavia, le espressioni indice <emphasis>non</emphasis>
   vengono ricalcolate durante una ricerca indicizzata, dato che sono già
   memorizzate nell'indice. In ambedue gli esempi visti sopra, il sistema vede la query
   come <literal>WHERE colonnaindicizzata = 'costante'</literal> e quindi la velocità della
   ricerca è equivalente a qualsiasi altra semplice query indice. Per cui, gli
   indici nelle espressioni sono utili quando la velocità della ricerca è
   più importante della velocità di inserimento e di aggiornamento.
  </para>
 </sect1>


 <sect1 id="indexes-partial">
  <title>Indici parziali</title>

  <indexterm zone="indexes-partial">
   <primary>index</primary>
   <secondary>parziale</secondary>
  </indexterm>

  <para>
   
    Un <firstterm>indice parziale</firstterm> è un indice costruito su un
   sottoinsieme di una tabella; il sottoinsieme è definito da una espressione
   condizionale (chiamata <firstterm>predicato</firstterm> dell'indice
   parziale). L'indice contiene le voci di quelle righe della tabella
   che soddisfano il predicato. Gli indici parziali sono una caratteristica
   specializzata, ma ci sono diverse situazioni in cui possono risultare utili.
  </para>

  <para>
    La ragione principale per usare un indice parziale è di evitare l'indicizzazione
   di valori comuni. Dato che una query di ricerca di un valore comune (un valore che si
   ripete per più di una certa percentuale di tutte le righe della tabella) 
   non userà comunque l'indice, non c'è motivo di tenere quelle righe
   nell'indice. Questo riduce la dimensione dell'indice, che velocizzerà
   le query che usano l'indice. Esso potrà velocizzare anche molte operazioni
   di aggiornamento di tabelle perchè l'indice non deve essere
   aggiornato in tutti i casi. La <xref linkend="indexes-partial-ex1" /> mostra
   una possibile applicazione di questa idea.
  </para>

  <example id="indexes-partial-ex1">
   <title>Impostare un indice parziale per escludere valori comuni.</title>

   <para>
    Supporre di dover immagazzinare i log di accesso al server in un database.
    La maggior parte degli accessi proviene dalla gamma di indirizzi IP della propria
    organizzazione ma alcuni provengono da altre parti (vedi impiegati su connessioni
    dial-up). Se le ricerche per IP servono principalmente per gli accessi esterni,
    probabilmente non ci sarà bisogno di indicizzare la gamma di IP che corrisponde
    alla subnet della propria organizzazione.      
   </para>

   <para>
    Assumere una tabella come la seguente:
<programlisting>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</programlisting>
   </para>

   <para>
    Per creare un  indice parziale che soddisfi questo esempio, utilizzare un comando
    come questo:
<programlisting>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');
</programlisting>
   </para>

   <para>
    Una tipica query che può utilizzare questo indice sarà:
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</programlisting>
    Una query che non può usare questo indice è:
<programlisting>
SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';
</programlisting>
   </para>

   <para>
Osservare che questo tipo di indice parziale richiede che i valori comuni 
siano predeterminati, perciò gli indici parziali sono usati per distribuzioni di 
dati che non cambiano. Gli indici possono essere ricreati 
occasionalmente per adattarsi a nuove distribuzioni di dati, ma questo
aggiunge sforzi di manutenzione.
    
   
    </para>
  </example>

  <para>
   Un altro possibile uso di un indice parziale è quello di escludere
   dall'indice i valori
   che non sono interessanti nelle normali query di
   lavoro; questo è mostrato nell'<xref linkend="indexes-partial-ex2" />.
   Esso ottiene gli stessi vantaggi elencati sopra, ma impedisce che i valori
   <quote>non interessanti</quote> siano raggiunti dall'indice, anche se
   è probabile che una scansione di indice potrebbe essere vantaggiosa
   in quel caso. Ovviamente, impostare indici parziali per questo tipo di
   scenario richiederà molta cura e sperimentazione.
   
  </para>

  <example id="indexes-partial-ex2">
   <title>Impostare di un indice parziale per escludere valori non interessanti</title>

   <para>
    
    Se si ha una tabella che contiene sia ordini fatturati che non fatturati,
    dove gli ordini non fatturati rappresentano una piccola porzione della tabella
    totale ma anche le righe con i maggiori accessi, è possibile
    incrementare la prestazioni creando un indice sulle sole righe non fatturate. Il
    comando per creare l'indice somiglierebbe a questo:
<programlisting>
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
</programlisting>
   </para>

   <para>
    Una possibile query per utilizzare questo indice potrebbe essere:
<programlisting>
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;
</programlisting>
    Tuttavia, l'indice potrà anche essere usato nelle query che non coinvolgono
    per nulla <structfield>order_nr</structfield>, p.e.:
<programlisting>
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;
</programlisting>
    Questo non è efficiente come potrebbe essere un indice parziale sulla
    colonna <structfield>amount</structfield>, dato che il sistema deve scandire
    l'intero indice. Tuttavia, se ci sono relativamente pochi ordini
    non fatturati, usando questo indice parziale solo per trovare gli ordini non fatturati
    potrebbe essere vincente.
   </para>

   <para>
    Notare che questa query non può usare questo indice:
<programlisting>
SELECT * FROM orders WHERE order_nr = 3501;
</programlisting>
    L'ordine 3501 potrebbe essere negli ordini fatturati o in quelli non
    fatturati.
   </para>
  </example>

  <para>
   La <xref linkend="indexes-partial-ex2" /> spiega anche che la colonna
   indice e la colonna usata nel predicato non devono abbinarsi.
   <productname>PostgreSQL</productname> supporta indici parziali con
   predicato arbitrario, a condizione che siano implicate soltanto le
   colonne della tabella indicizzata. Tuttavia, ricordarsi che il
   predicato deve abbinare le condizioni usate nelle query che si suppone
   debbano deneficiare dell'indice. Per essere precisi, un indice parziale
   può essere usato in una query solo se il sistema può riconoscere che
   la condizione <literal>WHERE</literal> della query implica matematicamente
   il predicato dell'indice.
   <productname>PostgreSQL</productname> non ha un sofisticato dimostratore
   di teoremi che può riconoscere le espressioni matematicamente
   equivalenti che sono scritte nelle diverse forme.  (Non solo
   un simile dimostratore generale di teoremi sarebbe estremamente difficile da
   creare, esso molto probabilmente sarebbe troppo lento per un reale utilizzo).
   Il sistema può riconoscere semplici implicazioni di disuguaglianza, per esempio
   <quote>x &lt; 1</quote> implica che <quote>x &lt; 2</quote>; altrimenti
   la condizione predicato dovrebbe abbinare esattamente la parte della condizione
   <literal>WHERE</literal> della query
   o l'indice non sarebbe riconosciuto come utilizzabile. L'abbinamento avviene durante
   la pianificazione della query, non durante l'esecuzione. Di conseguenza,
   le clausule delle query parametrizzate non funzioneranno con un indice parziale. Per
   esempio una query preparata con un parametro potrebbe specificare 
   <quote>x &lt; ?</quote> che non implicherà mai  
   <quote>x &lt; 2</quote> per tutti i possibili valori del parametro. 
  </para>

  <para>
   Un terzo possibile uso degli indici parziali non richiede che
   l'indice sia usato nelle query. L'idea è di creare
   un indice unique in un sottoinsieme di tabella, come nella <xref
   linkend="indexes-partial-ex3" />. Questo impone l'unicità nel
   complesso delle righe che soddisfano l'indice predicato, senza vincolare
   quelle che non lo soddisfano.
  </para>

  <example id="indexes-partial-ex3">
   <title>Impostare un indice parziale unique</title>

   <para>
    Supporre di avere una tabella che descriva i risultati di una prova. Volendo
    assicurarsi che ci sia una sola voce <quote>successo</quote> per una determinata
    combinazione soggetto e obiettivo, in un certo numero di voci
    <quote>insuccesso</quote>. Questo è un modo per farlo:
<programlisting>
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
    Questo è un modo particolarmente efficiente quando ci sono poche
    prove "successo" e molte "insuccesso".
   </para>
  </example>

  <para>
   
    Per concludere, un indice parziale può anche essere usato per avere la priorità
   sul queryplan scelto dal sistema. Inoltre, insiemi di dati con particolari
   distribuzioni possono indurre il sistema ad usare un indice quando non è realmente
   necessario. In quel caso l'indice può essere impostato in modo che non sia
   disponibile per query dannose. Normalmente,
   <productname>PostgreSQL</productname> effettua scelte ragionevoli circa l'utilizzo degli
   indici (p.e., li evita quando recupera valori comuni, per cui il primo esempio 
   salva realmente soltanto la dimensione dell'indice, esso non è necessario per evitare l'utilizzo
   dell'indice), e le scelte di piani grossolanamente scorrette sono causa
   di segnalazioni di bug.
  </para>

  <para>
   Ricordarsi che l'impostazione di un indice parziale indica che si conosce
   almeno quanto conosce il pianificatore delle query, in particolare che si
   conosce quando l'uso di un indice potrebbe essere vantaggioso. La formazione
   di questa conoscenza richiede esperienza e anche di capire come gli indici
   lavorano in <productname>PostgreSQL</productname>. Nella maggior parte dei casi, il
   vantaggio di un indice parziale su un indice regolare sarà minimo.
  </para>

  <para>
   Ulteriori informazioni su indici parziali possono essere trovate in <xref
   linkend="STON89b" />, <xref linkend="OLSON93" />, e in <xref
   linkend="SESHADRI95" />.
  </para>
 </sect1>


 <sect1 id="indexes-opclass">
  <title>Classi operatore e famiglie di operatori</title>

  <indexterm zone="indexes-opclass">
   <primary>classe operatore</primary>
  </indexterm>

  <indexterm zone="indexes-opclass">
   <primary>famiglia operatore</primary>
  </indexterm>

  <para>
   Una definizione di indice può specificare una <firstterm>classe
   operatore</firstterm> per ogni colonna di un indice.
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <replaceable>opclass</replaceable> <optional><replaceable>sort options</replaceable></optional> <optional>, ...</optional>);
</synopsis>
   Le classe operatore identifica gli operatori che saranno usati dall'indice
   per quella colonna. Per esempio, un indice B-tree sul tipo <type>int4</type>
   userebbe la classe <literal>int4_ops</literal>; questa classe 
   operatore include funzioni di confronto per valori di tipo <type>int4</type>.
   In pratica la classe operatore predefinita per il tipo dato della colonna è
   normalmente sufficiente. Il motivo principale per avere le classi operatore è
   che per certi tipi di dato, ci potrebbero essere più di un comportamento
   significativo per l'indice. Per esempio, si porebbe voler ordinare un tipo dato numerico
   complesso o per il suo valore assoluto oppure per la sua parte reale. Si potrebbe
   fare questo definendo per il tipo dato due classi operatore e quindi selezionare
   la classe appropriata quando si imposta un indice. La classe operatore determina
   il tipo di ordinamento di base (che potrà essere modificato aggiungendo le
   opzione di ordinamento <literal>ASC</literal>/<literal>DESC</literal> e/o
   <literal>NULLS FIRST</literal>/<literal>NULLS LAST</literal>).
    </para>    

  <para>
   Inoltre, ci sono altre classi operatore incorporate oltre quella predefinita:

   <itemizedlist>
    <listitem>
     <para>
      Le classi operatore <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal>,
      <literal>bpchar_pattern_ops</literal>, e
      <literal>name_pattern_ops</literal> supportano indici
      B-tree, rispettivamente, sui tipi <type>text</type>,
      <type>varchar</type>, <type>char</type>, e <type>name</type>. La
      diffferenza dalle classi operatore preimpostate è che i valori
      sono confrontati carattere per carattere piuttosto che
      seguendo le regole di collazione specificate localmente. Ciò 
      rende queste classi operatore adatte per l'uso in query che coinvolgono
      espressioni di corrispondenza modelli (<literal>LIKE</literal> o
      espressioni regolari POSIX) quando il server non usa lo standard
      <quote>C</quote> locale. Come esempio, si potrebbe indicizzare una
      colonna <type>varchar</type> come questa:
<programlisting>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</programlisting>
      Notare che bisognerebbe creare un indice con la classe operatore
      predefinita se si vogliono query che comportano confronti comuni
      nell'uso di un indice. Tali query non possono usare le classi operatore 
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>.
      È consentito creare indici multipli sulla stessa colonna con
      diverse classi operatore. Se si utilizza il C locale, non ci
      sarà bisogno delle classi operatore
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>,
      perchè per query di corrispondenza modelli nel C locale,
      si può utilizzare un indice con la classe operatore predefinita.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
    La query seguente mostra tutte le classi operatore definite:

<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>

  <para>
   Una classe operatore è semplicemente  un sottoinsieme di una struttura maggiore chiamata
   <firstterm>famiglia dell'operatore</firstterm>. Nei casi in cui diversi tipi di dato hanno
   comportamenti simili, è spesso utile definire operatori per tipi-dato-incrociati
   e consentirgli di lavorare con indici. Per fare questo, le classi operatore
   per ciascun tipo dovranno essere raggruppate dentro la stessa famiglia di operatori.
   Gli operatori di tipo-incrociato sono membri della famiglia, ma non sono
   associati con nessuna singola classe all'interno della famiglia.
  </para>

  <para>
    This query shows all defined operator families and all
    the operators included in each family:
<programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-examine">
  <title>Controllare l'utilizzo dell'indice</title>

  <indexterm zone="indexes-examine">
   <primary>indice</primary>
   <secondary>esaminare l'utilizzo</secondary>
  </indexterm>

  <para>
   
    Anche se in <productname>PostgreSQL</productname> gli indici non richiedono manutenzione
   o messa a punto, è comunque importante controllare
   quali indici vengono realmente usati nei cicli di lavoro delle query.
   L'esame di utilizzo degli indici per una singola query viene fatto con il comando
   <xref linkend="sql-explain" endterm="sql-explain-title" />;
   la sua applicazione per questo scopo è illustrata
   in <xref linkend="using-explain" />.
   È anche possibile raggruppare statistiche complessive circa l'utilizzo degli indici
   in un server in funzione, come descritto in <xref linkend="monitoring-stats" />.
  </para>

  <para>
   È difficile formulare una procedura generale per determinare
   quali indici impostare. Ci sono un certo numero di casi tipici che
   sono stati mostrati negli esempi illustrati nelle sezioni precedenti.
   Nella maggior parte dei casi sarà necessaria molta sperimentazione.  
   Il resto di questa sezione fornisce un certo numero di consigli per questo:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     
        Eseguire sempre <xref linkend="sql-analyze"/> prima.
        Questo comando
        raccoglie le statistiche circa la distribuzione dei valori nelle
        tabelle. Questa informazione è richiesta per calcolare il numero di
        righe restituite da una query, che sono necessarie al planner per assegnare
        costi realistici per ogni possibile queryplan. In assenza di reali
        statistiche, vengono assunti valori predefiniti, che sono quasi certamente
        inaccurati. Esaminare l'utilizzo dell'indice in una applicazione senza aver
        utilizzato <command>ANALYZE</command> è perciò
        una causa persa.
        Vedere <xref linkend="vacuum-for-statistics"/>
        e <xref linkend="autovacuum"/> per maggiori informazioni.
    </para>
   </listitem>

   <listitem>
    <para>
     Nelle sperimentazioni utilizzare dati reali. Utilizzare dati di prova per
     l'impostazione degli indici vi dirà solo di quali indici avrete bisogno
     per i dati di prova e nient'altro.
    </para>

    <para>
     
    È particolarmente disastroso usare insiemi di dati di prova molto ridotti.
     Mentre selezionare di 1000 righe da 100000 righe può essere un candidato per
     un indice, la selezione di 1 riga da 100 righe potrà difficilmente esserlo, perchè
     le 100 righe entreranno probabilmente in una singola pagina di disco, e non esiste un piano che 
     può girare recuperando sequenzialmente 1 pagina di disco.
    </para>

    <para>
     
    Fare inoltre attenzione quando si selezionano i dati di prova, il cui utilizzo
     è spesso inevitabile quando l'applicazione non è in produzione.
     Valori molto simili, completamente casuali, o inseriti in modo ordinato daranno
     alle statistiche una indicazione diversa rispetto alla distribuzione che i
     dati avrebbero avuto in realtà.
    </para>
   </listitem>

   <listitem>
    <para>
     When indexes are not used, it can be useful for testing to force
     their use.  There are run-time parameters that can turn off
     various plan types (see <xref linkend="runtime-config-query-enable"/>).
     For instance, turning off sequential scans
     (<varname>enable_seqscan</varname>) and nested-loop joins
     (<varname>enable_nestloop</varname>), which are the most basic plans,
     will force the system to use a different plan.  If the system
     still chooses a sequential scan or nested-loop join then there is
     probably a more fundamental reason why the index is not being
     used; for example, the query condition does not match the index.
     (What kind of query can use what kind of index is explained in
     the previous sections.)
     
     Quando gli indici non sono usati, può essere utile per i test provare a forzare il
     loro utilizzo. Ci sono parametri che in fase di esecuzione possono bloccare
     diversi tipi di piani (consultare <xref linkend="runtime-config-query-enable" />).
     Per esempio, escludendo la scansione sequenziale
     (<varname>enable_seqscan</varname>) e le join nested-loop
     (<varname>enable_nestloop</varname>), che sono i piani fondamentali,
     si forzerà il sistema ad utilizzare un piano differente. Se il sistema
     sceglie tuttavia una scansione sequenziale o una join nested-loop ci sarà
     probabilmente una diversa ragione per cui l'indice non viene 
     usato; Per esempio, se la condizione della query non uguaglia l'indice.
     (Che tipo di query può utilizzare un certo tipo di indice è spiegato
     nelle sezioni precedenti).
    </para>
   </listitem>

   <listitem>
    <para>
     
    Se forzando l'uso dell'indice esso viene utilizzato, ci sono due
     possibilità: o il sistema ha ragione e l'utilizzo dell'indice è
     davvero inappropriato, oppure i costi stimati dal queryplan
     non riflettono la realtà. Si dovrebbe misurare il tempo della
     query con e senza l'indici. Il comando <command>EXPLAIN ANALYZE</command>
     potrebbe quì essere utile.
    </para>
   </listitem>

   <listitem>
    <para>
<note>
    <para>
        Nota per il revisore: oddio....
    </para>
</note>
     Se risulta che i costi stimati sono sbagliati, ci sono,
     ancora, due possibilità. Il costo totale viene calcolato dal costo
     per-riga di ogni periodo di nodo di piano stimato selettivamente dal
     nodo di piano. I costi stimati per i nodi di piano possono essere modificati
     tramite parametri durante l'esecuzionevia (descritti in <xref
     linkend="runtime-config-query-constants" />).
     Una valutazione di selettività inesatta è dovuta a 
     insufficienti statistiche. È possibile migliorarla, regolando i
     parametri di riunione-statistiche (vedere
     <xref linkend="sql-altertable" endterm="sql-altertable-title" />).
     </para>

    <para>
     
    Se non si riuscirà ad adeguare il costo in modo più
     appropriato, potrebbe essere necessario forzare esplicitamente l'utilizzo
     dell'indice. Si potrebbe anche contattare gli sviluppatori
     <productname>PostgreSQL</productname> per esaminare il problema.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>

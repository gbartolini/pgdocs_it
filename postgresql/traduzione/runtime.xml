<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL$ -->

<chapter id="runtime">
 <title>Setup e operatività del server</title>

 <para>
Questo capitolo discute come impostare ed eseguire il server database
e le sue interazioni con il sistema operativo.
 </para>

 <sect1 id="postgres-user">
  <title>L'account utente <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>utente postgres</primary>
  </indexterm>

  <para>
Come con qualsiasi demone server che è accessibile al mondo esterno,
è consigliabile eseguire <productname>PostgreSQL</productname>  con 
un account utente separato. Questo account dovrebbe possedere solo i dati che 
sono gestiti dal server, e non dovrebbe essere condiviso con altri demoni.
(Per esempio, usare l'utente <literal>nobody</literal> è una cattiva idea).
Non è consigliabile installare eseguibili posseduti da questo utente 
dato che sistemi compromessi potrebbero modificare i propri
binari.
  </para>

  <para>
Per aggiungere un account utente Unix al proprio sistema, cercare un comando 
<command>useradd</command> o <command>adduser</command>. Il nome utente 
<systemitem>postgres</systemitem> è usato spesso, e assunto per tutto questo libro,
ma si può usare un altro nome se lo si desidera.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Creare un cluster di database</title>

  <indexterm>
   <primary>cluster di database</primary>
  </indexterm>

  <indexterm>
   <primary>area dati</primary>
   <see>cluster di database</see>
  </indexterm>

  <para>
Prima che si possa fare qualsiasi cosa, si deve inizializzare un'area di immagazzinamento dei 
database su disco. Chiameremo questo <firstterm>cluster di database</firstterm>. 
(<acronym>SQL</acronym> usa il termina cluster di catalogo). Un
cluster di database è una collezione di database gestiti da una 
singola istanza di un server database in esecuzione. Dopo l'installazione, un 
cluster di database conterrà un database chiamato <literal>postgres</literal>,
chè viene inteso come database predefinito per l'uso da parte di utilità, utenti e 
applicazioni di terze parti. Il server database stesso non richiede che il database
<literal>postgres</literal> esista, ma molte utilità esterne danno per scontato che esista.
Un altro database creato all'interno di ogni cluster
durante l'inizializzazione è chiamato
<literal>template1</literal>. Come suggerisce il nome, questo sarà usato 
come template per i database creati successivamente; non dovrebbe essere 
usato per il lavoro effettivo. (Si veda <xref linkend="managing-databases"/> per
informazioni circa la creazione di nuovi database all'interno del cluster). 
  </para>

  <para>
In termini di file system, un cluster di database sarà una singola directory
nella quale tutti i dati saranno salvati. La chiameremo <firstterm>
directory dei dati</firstterm> o <firstterm>area dei dati</firstterm>. Si è
completamente liberi di scegliere dove immagazzinare i dati. Non c'è un valore
predefinito, anche se posizioni come 
<filename>/usr/local/pgsql/data</filename> o
<filename>/var/lib/pgsql/data</filename> sono popolari. Per inizializzare un cluster
di database, usare il comando <xref
linkend="app-initdb"/>,<indexterm><primary>initdb</primary></indexterm> che viene 
installato con <productname>PostgreSQL</productname>. La posizione nel 
file system del proprio cluster di database è indicata dall'opzione 
<option>-D</option>, per esempio:
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
Notare che questo comando va eseguito mentre si è loggati con l'account utente 
<productname>PostgreSQL</productname>, che è stato descritto nella sezione 
precedente.
  </para>

  <tip>
   <para>
Un'alternativa all'opzione <option>-D</option> è di impostare 
la variabile d'ambiente <envar>PGDATA</envar>.
<indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
  </tip>

  <para>
Alternativamente, si può eseguire <command>initdb</command> attraverso 
il programma  <xref linkend="app-pg-ctl"/>
    <indexterm><primary>pg_ctl</primary></indexterm> in questo modo:
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
Questo potrebbe essere più intuitivo se si sta usando 
<command>pg_ctl</command> per avviare e fermare il server  
(si veda <xref linkend="server-start"/>), così che
<command>pg_ctl</command> sarebbe il solo comando usato per 
gestire l'istanza del server database.
  </para>

  <para>
<command>initdb</command>  tenterà di creare la directory specificata,
se non esiste già. È probabile che non avrà i permessi di farlo
(se si è seguito il consiglio di creare un account non privilegiato).
In questo caso si dovrebbe creare a mano la directory (come root) 
e cambiare il proprietario in modo che sia l'utente <productname>PostgreSQL</productname>.
Ecco come potrebbe essere fatto:
<screen>
root# <userinput>mkdir /usr/local/pgsql/data</userinput>
root# <userinput>chown postgres /usr/local/pgsql/data</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>

  <para>
<command>initdb</command> fallirà se la directory dei dati è già stata 
inizializzata.</para>

  <para>
Dato che la directory dei dati contiene tutti i dati salvati nel database,
è essenziale che sia sicura rispetto ad accessi non autorizzati.
<command>initdb</command> revoca inoltre i permessi di accesso 
a chiunque tranne che all'utente <productname>PostgreSQL</productname>.
  </para>

  <para>
Comunque, mentre i contenuti della directory sono sicuri, l'impostazione di autenticazione 
predefinita del client permette a qualsiasi utente locale di connettersi al
database e anche di diventare superutente del database. Se non ci si fida
degli utenti locali, si raccomanda di usare una delle opzioni di <command>initdb</command> 
<option>-W</option>, <option>--pwprompt</option> o <option>--pwfile</option>
per assegnare una password al superutente del database.
<indexterm><primary>password</primary><secondary>del 
superutente</secondary></indexterm>  Inoltre, specificare <option>-A md5</option> o 
<option>-A password</option> così che la modalità di autenticazione <literal>trust</literal>
predefinita non sia usata; o modificare il file <filename>pg_hba.conf</filename>
generato dopo aver lanciato <command>initdb</command>, ma
<emphasis>prima</emphasis> che si avvii il server per la prima volta. (Altri approcci 
ragionevoli includono l'utilizzo dell'autenticazione <literal>ident</literal>
o i permessi del file system per restringere le connessioni. Si veda <xref
linkend="client-authentication"/> per maggiori informazioni).
  </para>

  <para>
<command>initdb</command> inizializza anche la localizzazione <indexterm><primary>localizzazione</primary></indexterm> 
predefinita per il cluster di database.
Normalmente, prenderà semplicemente le impostazioni locali dell'ambiente 
e le applicherà al database inizializzato. È possibile specificare 
una localizzazione diversa per il database; maggiori informazioni su questo possono 
essere trovate in <xref linkend="locale"/>. L'ordine predefinito usato all'interno 
di un particolare cluster è impostato da
<command>initdb</command>, e mentre si possono creare nuovi database usando 
differenti ordinamenti, l'ordine usato nei database template che crea initdb
non può essere cambiato senza eliminarli e ricrearli.
C'è anche un impatto di prestazioni nell'usare localizzazioni diverse da
<literal>C</literal> o <literal>POSIX</literal>. Inoltre, è importante 
prendere la scelta giusta correttamente la prima  volta.
  </para>

  <para>
<command>initdb</command> imposta anche la codifica del set di caratteri predefinita
per il cluster di database. Normalmente questa dovrebbe essere scelta per corrispondere 
all'impostazione locale. Per dettagli si veda <xref linkend="multibyte"/>.
  </para>

  <sect2 id="creating-cluster-nfs">
   <title>Network File System</title>

   <indexterm zone="creating-cluster-nfs">
    <primary>Network File System</primary>
   </indexterm>
   <indexterm><primary><acronym>NFS</acronym></primary><see>Network File System</see></indexterm>
   <indexterm><primary>Network Attached Storage (<acronym>NAS</acronym>)</primary><see>Network File System</see></indexterm>

   <para>
Molte installazioni creano cluster di database su file system di rete.
A volte questo viene fatto direttamente attraverso <acronym>NFS</acronym>, o usando un dispositivo
<acronym>NAS</acronym> (Network Attached Storage) che usa
<acronym>NFS</acronym> internamente. <productname>PostgreSQL</productname> non fa niente di 
speciale per file system <acronym>NFS</acronym>, cioè presume che 
<acronym>NFS</acronym> si comporti esattamente come volumi connessi localmente
(<acronym>DAS</acronym>, Direct Attached Storage). Se le implementazioni del client e del server
<acronym>NFS</acronym> hanno semantica non standard, questo può causare 
problemi di affidabilità (si veda <ulink
url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>).
Nello specifico, scritture ritardate (asincrone) verso il server <acronym>NFS</acronym>
possono causare problemi di affidabilità; se possibile, montare 
i file system <acronym>NFS</acronym> in modo sincrono (senza il caching) per evitare 
questo. Inoltre, il montaggio soft di <acronym>NFS</acronym> non è raccomandato.
(Storage Area Networks (<acronym>SAN</acronym>) usano un protocollo di comunicazione 
a basso livello rispetto a <acronym>NFS</acronym>).
   </para>

  </sect2>

 </sect1>

 <sect1 id="server-start">
  <title>Starting the Database Server</title>

  <para>
Prima che qualcuno possa accedere al database, si deve avviare il server database.
Il programma server è chiamato 
<command>postgres</command>.<indexterm><primary>postgres</primary></indexterm>
Il programma <command>postgres</command> deve sapere dove 
trovare i dati da usare. Questo è fatto con l'opzione 
<option>-D</option>. Così, il modo più semplice di avviare il server è:
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
che lascerà il server in esecuzione in primo piano. Questo dev'essere fatto 
mentre si è loggati come utente <productname>PostgreSQL</productname>.
Senza <option>-D</option>, il server proverà a usare 
la directory dei dati definita dalla variabile d'ambiente <envar>PGDATA</envar>.
Se la variabile non è fornitam, fallirà.
  </para>

  <para>
Normalmente è meglio lanciare <command>postgres</command> in 
background. Per questo, usare la sintassi usuale della shell Unix:
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
È importante salvare lo <systemitem>stdout</systemitem> e lo <systemitem>stderr</systemitem>
del server da qualche parte, come mostrato sopra. Aiuterà 
per scopi di monitoraggio e per diagnosticare problemi. (Si veda <xref
linkend="logfile-maintenance"/> per una discussione più approfondita sulla 
gestione dei file di log).
  </para>

  <para>
Il programma <command>postgres</command> inoltre accetta un certo numero di altre 
opzioni a linea di comando. Per maggiori informazioni, si veda
la pagina di riferimento <xref linkend="app-postgres"/> e  
<xref linkend="runtime-config"/> sotto.
  </para>

  <para>
Questa sintassi di shell può diventare tediosa velocemente. Perciò è disponibile il programma wrapper
<xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
per semplificare alcuni compiti. Per esempio:
<programlisting>
pg_ctl start -l logfile
</programlisting>
avvierà il server in background e metterà l'output nel file di log indicato. 
L'opzione <option>-D</option> ha lo stesso significato 
qui come per <command>postgres</command>. <command>pg_ctl</command>
è anche capace di fermare il server.
  </para>

  <para>
Normalmente, si vorrà avviare il server database all'avvio del computer.
<indexterm><primary>avvio</primary><secondary>avviare il server</secondary></indexterm>
Gli script di avvio automatico sono specifici al sistema operativo.
Ce ne sono un po' distribuiti con 
<productname>PostgreSQL</productname> nella directory 
<filename>contrib/start-scripts</filename>. Installarne uno richiederà privilegi di root.
  </para>

  <para>
Sistemi diversi hanno convenzioni diverse per avviare i demoni all'avvio.
Molti sistemi hanno un file
<filename>/etc/rc.local</filename> o
<filename>/etc/rc.d/rc.local</filename>. Altri usano
directory <filename>rc.d</filename>. Qualsiasi cosa si faccia, il server deve essere
eseguito dall'account utente <productname>PostgreSQL</productname>
<emphasis>e non da root</emphasis> o da qualsiasi altro utente. Perciò 
probabilmente si dovranno fornire i comandi usando <literal>su -c '...'
postgres</literal>.  Per esempio:
<programlisting>
su -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog' postgres
</programlisting>
  </para>

  <para>
Ecco alcuni ulteriori suggerimenti specifici del sistema operativo. (In ogni 
caso assicurarsi di usare la directory di installazione e il nome utente appropriati 
dove vengono mostrati valori generici).

   <itemizedlist>
    <listitem>
     <para>
      For <productname>FreeBSD</productname>, look at the file
Per <productname>FreeBSD</productname>, si veda il file  
<filename>contrib/start-scripts/freebsd</filename> nella distribuzione del sorgente 
<productname>PostgreSQL</productname>.
<indexterm><primary>FreeBSD</primary><secondary>script d'avvio</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
Su <productname>OpenBSD</productname>, aggiungere le seguenti linee
al file  <filename>/etc/rc.local</filename>:
      <indexterm><primary>OpenBSD</primary><secondary>script d'avvio</secondary></indexterm>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su - -c '/usr/local/pgsql/bin/pg_ctl start -l /var/postgresql/log -s' postgres
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
Su sistemi <productname>Linux</productname> aggiungere 
<indexterm><primary>Linux</primary><secondary>script d'avvio</secondary></indexterm>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
a <filename>/etc/rc.d/rc.local</filename> o si veda il file 
<filename>contrib/start-scripts/linux</filename> nella distribuzione del 
sorgente <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      On <productname>NetBSD</productname>, either use the
Su <productname>NetBSD</productname>, usare lo script d'avvio di 
<productname>FreeBSD</productname> o
di <productname>Linux</productname>, a seconda dei propri gusti.
<indexterm><primary>NetBSD</primary><secondary>script d'avvio</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
Su <productname>Solaris</productname>, creare un file chiamato 
<filename>/etc/init.d/postgresql</filename> che contiene
la seguente linea:
<indexterm><primary>Solaris</primary><secondary>script d'avvio</secondary></indexterm>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
Quindi, creare un link simbolico ad esso in <filename>/etc/rc3.d</filename> come 
<filename>S99postgresql</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
Mentre il server è in esecuzione, il suo 
<acronym>PID</acronym> è salvato nel file 
<filename>postmaster.pid</filename> nella directory dei dati. Questo viene fatto per
prevenire che molteplici istanze del server siano in esecuzione
nella stessa directory di dati e può essere usato anche per 
arrestare il server.
   </para>

   <sect2 id="server-start-failures">
    <title>Fallimenti dell'avvio del server</title>

    <para>
Ci sono diverse ragioni comuni per cui il server potrebbe fallire 
nel tentativo di avviarsi. Controllare il file di log del server, o avviarlo a mano (senza
redirigere lo standard output o lo standard error) e controllare quali messaggi di errore
appaiono. Sotto vengono spiegato alcuni dei messaggi di errore più comuni 
in dettaglio.
    </para>

    <para>
<screen>
LOG:  could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
Questo di solito significa esattamente cosa suggerisce: si è provato ad avviare
un altro server sulla stessa porta in cui uno è già in esecuzione. 
Comunque, se il messaggio di errore del kernel non è <computeroutput>Address
already in use</computeroutput> o qualche variante di questo, ci potrebbe essere 
un problema diverso. Per esempio, provare ad avviare un server
su una numero di porta riservata potrebbe genereare qualcosa simile a:
<screen>
$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
    </para>

    <para>
un messaggio come:
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
probabilmente significa che il limite del kernel sulla dimensione della memoria condivisa
è più piccolo rispetto all'area di lavoro che <productname>PostgreSQL</productname>
sta tentando di creare (4011376640 byte in questo esempio). O potrebbe significare
che non si ha il supporto alla memoria condivisa System-V nel kernel.
Come soluzione temporanea, si può provare ad avviare il server con un numero 
più piccolo del normale di buffer (<xref linkend="guc-shared-buffers"/>).
Eventualmente si vorrà configurare di nuovo il kernel per incrementare la dimensione della memoria condivisa
permessa. Si potrebbe anche incontrare questo messaggio quando si tentano di avviare 
molteplici server sulla stessa macchina, se il loro spazio totale richiesto
eccede il limite del kernel.
    </para>

    <para>
Un errore come:
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
<emphasis>non</emphasis> significa che si è ecceduto lo spazio su disco.
Significa che il limite del proprio kernel sul numero di semafori <systemitem
class="osname">System V</systemitem> è più piccolo rispetto al numero
che <productname>PostgreSQL</productname> vuole creare. Come sopra,
si potrebbe risolvere il problema avviando il servere con un numero ridotto 
di connessioni permesse 
(<xref linkend="guc-max-connections"/>) ma eventualmente è preferibile incrementare 
il limite del kernel.
    </para>

    <para>
Se si riceve un errore <quote>illegal system call</quote>, probabilmente la 
memoria condivisa o i semafori non sono supportati per niente dal proprio kernel.
In questo caso la sola opzione disponibile è di riconfigurare il kernel 
per abilitare queste caratteristiche.
    </para>

    <para>
Dettagli sulla configurazione delle caratteristiche <acronym>IPC</acronym> di 
<systemitem class="osname">System V</systemitem> sono presentati di <xref linkend="sysvipc"/>.

    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problemi di connessione al client</title>

    <para>
Anche se le condizioni di possili errori lato client sono abbastanza
varie è dipendono dall'applicazione, alcune di queste potrebbero essere 
collegate direttamente al modo in cui il server è stato lanciato. Condizioni 
diverse da quelle mostrate sotto dovrebbero essere documentate con la 
rispettiva applicazione. 
    </para>

    <para>
<screen>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?
</screen>
     This is the generic <quote>I couldn't find a server to talk
Questo è il fallimento  generico <quote>Non riesco a trovare un server con cui comunicare</quote>. 
     It looks like the above when TCP/IP
     communication is attempted. A common mistake is to forget to
     configure the server to allow TCP/IP connections.
    </para>

    <para>
Alternativamente, si otterrò questo quando si tenta una comunicazione con Unix-domain socket
a un server locale:
<screen>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
    </para>

    <para>
L'ultima linea è utile per verificare che il client stia tentando di connettersi 
nel posto giusto. Se effettivamente non c'è un server in esecuzione là,
il messaggio di errore del kernel tipicamente sarà o 
<computeroutput>Connection refused</computeroutput> o
<computeroutput>No such file or directory</computeroutput>, come 
illustrato. (È importante rendersi conto che 
<computeroutput>Connection refused</computeroutput> in questo contesto
<emphasis>non</emphasis> significa che il server ha ottenuto la richiesta
di connessione e l'ha rifiutata. Quel caso produrrà un messaggio diverso, 
come mostrato in <xref
linkend="client-authentication-problems"/>). Altri messaggi d'errore
tipo <computeroutput>Connection timed out</computeroutput> potrebbero
indicare problemi più gravi, come carenza di connettività.
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <title>Gestire le risorse del Kernel</title>

  <para>
Un'installazione grande di <productname>PostgreSQL</productname> può esaurire velocemente
i limiti di varie risorse del sistema operativo. (Su alcuni sistemi, 
i valori predefiniti sono talmente bassi che non si ha nemmeno bisogno di un'installazione
molto <quote>grande</quote>). Se si è riscontrato questo tipo di problemi, 
continuare a leggere.
  </para>

  <sect2 id="sysvipc">
   <title>Memoria condivisa e semafori</title>

   <indexterm zone="sysvipc">
    <primary>memoria condivisa</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>semafori</primary>
   </indexterm>

   <para>
    Shared memory and semaphores are collectively referred to as
    <acronym>IPC</acronym></quote> (together with message queues, which are not
    relevant for <productname>PostgreSQL</productname>). Almost all modern
    operating systems provide these features, but many of them don't have
    them turned on or sufficiently sized by default, especially as
    available RAM and the demands of database applications grow.
(Su <systemitem class="osname">Windows</systemitem>,
<productname>PostgreSQL</productname> fornisce la  propria implementazione come rimpiazzo 
di queste caratteristiche, quindi la maggior parte di questa sezione
può essere trascurata).
   </para>

   <para>
La completa mancanza di queste caratteristiche è di solito manifestata da un errore 
<errorname>Illegal system call</errorname> all'avvio del server. In quel caso 
non c'è alternativa se non riconfigurare il kernel. <productname>PostgreSQL</productname>
non funzionerà senza di loro.
In ogni caso, questa situazione è rara tra i sistemi operativi moderni.
   </para>

   <para>
Quando <productname>PostgreSQL</productname> eccede uno dei vari limiti <acronym>IPC</acronym>,
il server rifiuterà di avviarsi e dovrebbe generare un errore informativo che descrive il problema
e cosa fare. (Si veda anche <xref
linkend="server-start-failures"/>). I parametri rilevanti del kernel 
sono chiamati consistentemente tra i vari sistemi; <xref
linkend="sysvipc-parameters"/> fornisce una fanoramica. I metodi per impostarli,
comunque, variano. Suggerimenti per alcune piattaforme sono presentati sotto.
   </para>


   <table id="sysvipc-parameters">
    <title>Parametri <acronym>IPC</acronym> <systemitem class="osname">System V</systemitem></title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nome</entry>
       <entry>Descrizione</entry>
       <entry>Valori ragionevoli</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</varname></entry>
       <entry>Dimensione massima del segmento di memoria condivisa (byte)</entry>
       <entry>almeno diversi megabyte (si veda text)</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</varname></entry>
       <entry>Dimensione minima del segmento di memoria condivisa (byte)</entry>
       <entry>1</entry>
      </row>

      <row>
       <entry><varname>SHMALL</varname></entry>
       <entry>Quantità totale della memoria condivisa disponibile (byte o pagine)</entry>
       <entry>se byte, lo stesso di <varname>SHMMAX</varname>; se pagine, <literal>ceil(SHMMAX/PAGE_SIZE)</literal></entry>
      </row>

      <row>
       <entry><varname>SHMSEG</varname></entry>
       <entry>Il massimo numero di segmenti di memoria condivisa per processo</entry>
       <entry>solo 1 segmento è necessario, ma il valore predefinito è molto maggiore</entry>
      </row>

       <row>
        <entry><varname>SHMMNI</varname></entry>
        <entry>Il massimo numero di segmenti di memeoria condivisa a livello di sistema</entry>
        <entry>come <varname>SHMSEG</varname> più spazione per altre applicazioni</entry>
       </row>

       <row>
        <entry><varname>SEMMNI</varname></entry>
        <entry>Il massimo numero di identificatori di semaforo (per es., sets)</entry>
        <entry>almeno <literal>ceil((max_connections + autovacuum_max_workers) / 16)</literal></entry>
       </row>

       <row>
        <entry><varname>SEMMNS</varname></entry>
        <entry>Il massimo numero di semafori a livello di sistema</entry>
        <entry><literal>ceil((max_connections + autovacuum_max_workers) / 16) * 17</literal>  
        più spazio per altre applicazioni</entry>
       </row>

       <row>
        <entry><varname>SEMMSL</varname></entry>
        <entry>Il massimo numero di sema Maximum number of semaphores per insieme</entry>
        <entry>almeno 17</entry>
       </row>

       <row>
        <entry><varname>SEMMAP</varname></entry>
        <entry>Numero di voci nella mappa dei semafori</entry>
        <entry>si veda text</entry>
       </row>

       <row>
        <entry><varname>SEMVMX</varname></entry>
        <entry>Il massimo valore del semaforo</entry>
        <entry>almeno 1000 (Il valore predefiniro spesso è 32767; non cambiarlo a meno che non sia necessario)</entry>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
<indexterm><primary>SHMMAX</primary></indexterm> Il parametro più importante
riguardante la memoria condivisa è <varname>SHMMAX</varname>, cioè la dimensione massima, 
in byte, di un segmento di memoria condivisa. Se si ottiene un messaggio di errore da
<function>shmget</function> tipo <quote>Invalid argument</quote>, è 
probabile che questo limite sia stato superato. La dimensione del segmento di  
memoria condivisa richiesta varia dipendentemente da diveri parametri di configurazione 
di <productname>PostgreSQL</productname>, come mostrato in  
<xref linkend="shared-memory-parameters"/>. (Qualsiasi messaggio di errore che si potrebbe 
ottenere includeranno la dimensione esatta della richiesta di allocazione fallita).
È possibile, come soluzione temporanea, abbassare alcune di queste impostazioni per 
evitare il fallimento. Mentre è possibile avviare  
<productname>PostgreSQL</productname> con <varname>SHMMAX</varname> grande 2 MB,
probabilmente si avrà bisogno di più per prestazioni accettabili. Impostazioni 
auspicabili sono da centinaia di megabyte a pochi gigabyte.
   </para>

   <para>
Alcuni sistemi hanno anche un limite sulla quantità totale di memeoria condivisa
nel sistema (<varname>SHMALL</varname>).  Assicurarsi che sia grande abbastanza 
per <productname>PostgreSQL</productname>  più qualsiasi altra applicazione che
stia usando segmenti di memoria condivisa. Notare che <varname>SHMALL</varname>
viene misurata in pagine invece di byte su molti sistemi.
   </para>

   <para>
È meno probabile che a causare problemi sia la dimensione minima per i segmenti
di memoria condivisa (<varname>SHMMIN</varname>), che dovrebbero essere tutt'al più
500 kB approssimativamente per <productname>PostgreSQL</productname> (di solito è 
1). Il massimo numero di segmenti a livello di sistema
(<varname>SHMMNI</varname>) o per processo (<varname>SHMSEG</varname>) probabilmente non 
causeranno problemi a meno che il sistema non li abbia impostati a zero.
   </para>

   <para>
<productname>PostgreSQL</productname> usa un semaforo per ogni connessione permessa 
(<xref linkend="guc-max-connections"/>) e processo worker dell'autovacuum consentito
(<xref linkend="guc-autovacuum-max-workers"/>), in gruppi di 16.
Ognuno di questi gruppi conterrà anche
un 17esimo semaforo che contiene un <quote>numero magico</quote>,
per accorgersi di collisioni con insiemi di semafori usati da altre applicazioni.
Il massimo numero di semafori nel sistema è impostato da 
<varname>SEMMNS</varname>, che di conseguenza deve essere grande almeno
quanto <varname>max_connections</varname> più
<varname>autovacuum_max_workers</varname>, più uno aggiuntivo per ogni 16
connessioni più worker consentite (si veda la formula in <xref
linkend="sysvipc-parameters"/>).  Il parametro <varname>SEMMNI</varname>
determina il limite sul numero di gruppi di semafori che possono 
esistere nel sistema in un dato istante. Da adesso questo parametro deve essere 
almeno <literal>ceil((max_connections + autovacuum_max_workers) / 16)</literal>.
Abbassare il numero di 
connessioni permesse è una soluzione temporanea per fallimenti, 
che di solito sono espressi confusamente come  <quote>No space
left on device</quote>, dalla funzione <function>semget</function>.
   </para>

   <para>
In alcuni casi potrebbe essere necessario anche incrementare 
<varname>SEMMAP</varname> per essere almeno nell'ordine di 
<varname>SEMMNS</varname>. Questo parametro definisce la dimensione della mappa
delle risorse del semaforo, nella quale qualsiasi blocco contiguo di semafori disponibili
necessita una voce. Quando un insieme di semafori viene liberato o è aggiunto 
a una voce esistente che è adiacente al blocco liberato oppure viene registrata 
con una nuova voce di mappa. Se la mappa è piena, i semafori liberati
vengono persi (fino al riavvio). La frammentazione dello spazio dei semafori 
potrebbe portare nel tempo ad avere meno semafori disponibili rispetto 
a quanti ce ne dovrebbero essere.
   </para>

   <para>
Il parametro <varname>SEMMSL</varname>, che determina quanti semafori 
possono esserci in un insieme, dev'essere almeno 17 per
<productname>PostgreSQL</productname>.
   </para>

   <para>
    Various other settings related to <quote>semaphore undo</quote>, such as
    <varname>SEMMNU</varname> and <varname>SEMUME</varname>, do not affect
    <productname>PostgreSQL</productname>.
   </para>


    <variablelist>
     <varlistentry>
      <term><systemitem class="osname">AIX</systemitem></term>
      <indexterm><primary>AIX</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Almeno dalla versione 5.1, non dovrebbe essere necessario fare 
nessuna configurazione speciale per parametri come <varname>SHMMAX</varname>,
per come appare questo è configurato per  permettere
a tutta la memoria di essere usata come memoria condivisa. Che è una sorta di 
configurazione usata comunemente in altri database tipo 
<application>DB/2</application>.</para>

<para>potrebbe comunque essere necessario modificare l'informazione
globale <command>ulimit</command> in 
<filename>/etc/security/limits</filename>, dato che il limite predefinito per 
la dimensione dei file (<varname>fsize</varname>) e il numero di file 
(<varname>nofiles</varname>) potrebbe essere troppo basso. 
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">BSD/OS</systemitem></term>
      <indexterm><primary>BSD/OS</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <formalpara>
        <title>Memoria condivisa</title>
        <para>
In modo predefinito, solo 4 MB di memoria condivisa sono supportati. Tenere a 
mente che la memeoria condivisa non è paginabile; è bloccata in RAM.
Per incrementare la quantità di memoria condivisa supportata dal sistema,
aggiungere qualcosa di simile al seguente al file di configurazione del kernel:
<programlisting>
options "SHMALL=8192"
options "SHMMAX=\(SHMALL*PAGE_SIZE\)"
</programlisting>
<varname>SHMALL</varname> viene misurato in pagine da 4 kB, quindi un valore di 
1024 rappresenta 4 MB di memoria condivisa. Inoltre l'esempio sopra aumenta 
l'area di massima memoria condivisa a 32 MB.
         For those running 4.3 or later, you will probably also need to increase
         <varname>KERNEL_VIRTUAL_MB</varname> above the default <literal>248</literal>.
         Once all changes have been made, recompile the kernel, and reboot.
        </para>
       </formalpara>

       <formalpara>
        <title>Semafori</title>
        <para>
Probabilmente si vorrà incrementare anche il numero di semafori;
il valore 60 predefinito di sistema permetterà solo cira 50 connessioni 
<productname>PostgreSQL</productname>. Impostare i valori 
che si vogliono nel file di configurazione del kernel, per es.:
<programlisting>
options "SEMMNI=40"
options "SEMMNS=240"
</programlisting>
        </para>
       </formalpara>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">FreeBSD</systemitem></term>
      <indexterm><primary>FreeBSD</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Le impostazioni predefinite sono adatte solo a installazioni piccole
(per esempio, il valore predefinito di <varname>SHMMAX</varname> è 32 MB).
Possono essere fatti cambiamenti attraverso le interfaccie <command>sysctl</command> o 
<command>loader</command>. I seguenti parametri
possono essere impostati usando <command>sysctl</command>:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmall=32768</userinput>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=134217728</userinput>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.semmap=256</userinput>
</screen>
Per rendere queste impostazioni persistenti al riavvio, modificare 
<filename>/etc/sysctl.conf</filename>.
       </para>

       <para>
Le impostazioni dei semafori rimanenti sono a sola lettura per come 
è pensato <command>sysctl</command>, ma può essere cambiato 
prima dell'avvio usando il prompt <command>loader</command>:
<screen>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmni=256</userinput>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmns=512</userinput>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmnu=256</userinput>
</screen>
Similmente questi possono essere salvati in 
<filename>/boot/loader.conf</filename>.
       </para>

       <para>
Si potrebbe anche voler configurare il kernel per bloccare la memoria condivisa
nella RAM e prevenire che venga paginata fuori dalla swap.
Questo può essere fatto usando l'impostazione <literal>kern.ipc.shm_use_phys</literal>
di <command>sysctl</command>.
       </para>

       <para>
        If running in FreeBSD jails by enabling <application>sysctl</application>'s
        <literal>security.jail.sysvipc_allowed</literal>, <application>postmaster</application>s
        running in different jails should be run by different operating system
        users.  This improves security because it prevents non-root users
        from interfering with shared memory or semaphores in different jails,
        and it allows the PostgreSQL IPC cleanup code to function properly.
        (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect
        processes in other jails, preventing the running of postmasters on the
        same port in different jails.)
       </para>

       <para>
Le versioni di <systemitem class="osname">FreeBSD</systemitem> precedenti la 4.0 funzionano come  
<systemitem class="osname">NetBSD</systemitem> e <systemitem class="osname">OpenBSD</systemitem> 
(si veda sotto).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">NetBSD</systemitem></term>
      <term><systemitem class="osname">OpenBSD</systemitem></term>
      <indexterm><primary>NetBSD</primary><secondary>configurazione IPC</secondary></indexterm>
      <indexterm><primary>OpenBSD</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Le opzioni <varname>SYSVSHM</varname> e <varname>SYSVSEM</varname> devono
essere abilitate quando viene compilato il kernel. (E lo sono in maniera predefinita).
La dimensione massima della memoria condivisa è determinata dall'opzione
<varname>SHMMAXPGS</varname> (in pagine). L'esempio seguente mostra 
un esempio di come impostare i vari parametri su
<systemitem class="osname">NetBSD</systemitem>
(<systemitem class="osname">OpenBSD</systemitem> invece usa <literal>option</literal>):
<programlisting>
options        SYSVSHM
options        SHMMAXPGS=4096
options        SHMSEG=256

options        SYSVSEM
options        SEMMNI=256
options        SEMMNS=512
options        SEMMNU=256
options        SEMMAP=256
</programlisting>
       </para>

       <para>
Si potrebbe voler configurare il kernel  anche per bloccare la memoria 
condivisa nella RAM e prevenire che venga paginata fuori dalla swap.
Questo può essere fatto usando l'impostazione <literal>kern.ipc.shm_use_phys</literal>
di <command>sysctl</command>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">HP-UX</systemitem></term>
      <indexterm><primary>HP-UX</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Le impostazioni predefinite tendono ad essere sufficenti per installazioni normali.
Su <productname>HP-UX</productname> 10, il valore predefinito di  
<varname>SEMMNS</varname> è 128, che potrebbe essere troppo basso per database
più grandi.
       </para>
       <para>
I parametri <acronym>IPC</acronym> possono essere impostati nel  <application>System
Administration Manager</application> (<acronym>SAM</acronym>) in
<menuchoice><guimenu>Kernel
Configuration</guimenu><guimenuitem>Configurable Parameters</guimenuitem></menuchoice>. Scegliere
<guibutton>Create A New Kernel</guibutton> quando si è fatto.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</systemitem></term>
      <indexterm><primary>Linux</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
La dimensione massima predefinita del segmento è 32 MB, che è adeguata solo
per installazioni molto piccole di <productname>PostgreSQL</productname>.
La dimensione massima totale è 2097152 pagine.
Una pagina è quasi sempre 4096 byte ad eccezione di configurazioni del kernel insolite con 
<quote>pagine enormi</quote> (usare 
<literal>getconf PAGE_SIZE</literal> per verificare). Questo genera un limite
predefinito di 8 GB, che spesso è sufficiente, ma non sempre.
       </para>

       <para>
Le impostazioni per la dimensione della memoria condivisa possono essere cambiate
attraverso l'interfaccia <command>sysctl</command>. Per esempio, per permettere 16 GB:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
In più queste impostazioni possono essere preservate nel file 
<filename>/etc/sysctl.conf</filename>. Farlo è altamente raccomandato. 
       </para>

       <para>
Distribuzioni molto vecchie potrebbero non avere il programma <command>sysctl</command>, 
ma le modifiche equivalenti possono essere fatte manipolando il 
file system <filename>/proc</filename>: 
<screen>
<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
</screen>
       </para>

       <para>
I valori predefiniti rimanenti sono abbastanza grandi, e di solito non richiedono cambiamenti.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">MacOS X</systemitem></term>
      <indexterm><primary>MacOS X</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Il metodo raccomandato per configurare la memoria condivisa in OS X
è di creare un file chiamato <filename>/etc/sysctl.conf</filename>,
contenente assegnamenti di variabili tipo:
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
Si noti che in alcune versioni di OS X,
<emphasis>tutti e cinque</emphasis> i parametri della memoria condivisa devono essere impostati
in <filename>/etc/sysctl.conf</filename>, altrimenti i valori saranno ignorati. 
       </para>

       <para>
Fare attenzione al fatto che le versioni recenti di OS X ignoraro i tentativi di impostare
<varname>SHMMAX</varname> a un valore che non è un multiplo esatto di 4096. 
       </para>

       <para>
<varname>SHMALL</varname> è misurato in pagine da 4 kB su questa piattaforma. 
       </para>

       <para>
In vecchie versioni di OS X, si dovrà riavviare per rendere effettivi i cambiamenti
ai parametri della memoria condivisa. Dalla 10.5 è possibile cambiare 
tutto tranne <varname>SHMMNI</varname> al volo, usando
<application>sysctl</application>. Ma è sempre meglio impostare i valori preferiti  
attraverso  <filename>/etc/sysctl.conf</filename>, in modo che i valori saranno mantenuti  
anche dopo i riavvi.
       </para>

       <para>
Il file <filename>/etc/sysctl.conf</filename> viene considerato solo in OS X 
10.3.9 e successivi. Se si sta eseguendo una versione precedente alla 10.3.x, 
si deve modificare il file <filename>/etc/rc</filename>
e cambiare i valori nei seguenti comandi:
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
Si noti che 
<filename>/etc/rc</filename> di solito viene sovrascritto da aggiornamenti di OS X, 
quindi ci si dovrebbe aspettare di diver rifare queste modifiche dopo ogni aggiornamento.
       </para>

       <para>
In OS X 10.2 e precedenti, modificare questi comandi nel file 
<filename>/System/Library/StartupItems/SystemTuning/SystemTuning</filename>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">SCO OpenServer</systemitem></term>
      <indexterm><primary>SCO OpenServer</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Nella configurazione predefinita, sono permessi solo 512 kB per segmento.
Per aumentare l'impostazione, entrare nella directory 
<filename>/etc/conf/cf.d</filename>. Per visualizzare il valore corrente di  
<varname>SHMMAX</varname>, lanciare:
<programlisting>
./configure -y SHMMAX
</programlisting>
Per impostare un nuovo valore per <varname>SHMMAX</varname>, eseguire: 
<programlisting>
./configure SHMMAX=<replaceable>value</replaceable>
</programlisting>
dove <replaceable>value</replaceable> è il nuovo valore che si vuole usare (in byte).
Dopo aver impostato <varname>SHMMAX</varname>, ricompilare il kernel: 
<programlisting>
./link_unix
</programlisting>
e riavviare.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Solaris</systemitem></term>
      <indexterm><primary>Solaris</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Almeno nella versione 2.6, la dimensione massima predefinita di un segmento di memoria
condivisa è troppo basso per  <productname>PostgreSQL</productname>. Le impostazioni  
rilevanti possono essere cambiate in  <filename>/etc/system</filename>,
per esempio:
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
Si deve riavviare per rendere effettive le modifiche.
       </para>

       <para>
    
Si veda anche <ulink
url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
per informazioni sulla memoria condivisa su
<productname>Solaris</productname>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">UnixWare</systemitem></term>
      <indexterm><primary>UnixWare</primary><secondary>configurazione IPC</secondary></indexterm>
      <listitem>
       <para>
Su <productname>UnixWare</productname> 7, la dimensione massima per i segmenti di memoria  
condivisa è solamente 512 kB nella configurazione predefinita.
Per visualizzare il valore corrente di  <varname>SHMMAX</varname>, eseguire: 
<programlisting>
/etc/conf/bin/idtune -g SHMMAX
</programlisting>
che mostra i valori attuale, predefinito, minimo e massimo.
Per impostare un nuovo valore per  <varname>SHMMAX</varname>,
eseguire:
<programlisting>
/etc/conf/bin/idtune SHMMAX <replaceable>value</replaceable>
</programlisting>
dove <replaceable>value</replaceable> è il nuovo valore che si vuole usare (in byte). 
Dopo aver impostato  <varname>SHMMAX</varname>, ricompilare il  
kernel:
<programlisting>
/etc/conf/bin/idbuild -B
</programlisting>
e riavviare. 
       </para>
      </listitem>
     </varlistentry>

    </variablelist>


   <table id="shared-memory-parameters">
    <title>Utilizzo della memoria condivisa da parte di <productname>PostgreSQL</productname></title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Utilizzo</entry>
       <entry>Byte di memoria condivisa approssimati richiesti  (dalla 8.3)</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>Connessioni</entry>
       <entry>(1800 + 270 * <xref
       linkend="guc-max-locks-per-transaction"/>) * <xref
       linkend="guc-max-connections"/></entry>
      </row>

      <row>
       <entry>Worker autovacuum</entry>
       <entry>(1800 + 270 * <xref
       linkend="guc-max-locks-per-transaction"/>) * <xref
       linkend="guc-autovacuum-max-workers"/></entry>
      </row>

      <row>
       <entry>Transazioni preparate</entry>
       <entry>(770 + 270 * <xref
       linkend="guc-max-locks-per-transaction"/>) * <xref linkend="guc-max-prepared-transactions"/></entry>
      </row>

      <row>
       <entry>Buffer disco condivisi</entry>
       <entry>(<xref linkend="guc-block-size"/> + 208) * <xref linkend="guc-shared-buffers"/></entry>
      </row>

      <row>
       <entry>Buffer WAL</entry>
       <entry>(<xref linkend="guc-wal-block-size"/> + 8) * <xref linkend="guc-wal-buffers"/></entry>
      </row>

      <row>
       <entry>Richieste fisse di spazio</entry>
       <entry>770 kB</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2>
   <title>Limiti delle risorse</title>

   <para>
I sistemi operativi della famiglia Unix stabiliscono vari tipi di limiti di risorse
che potrebbero interferire con le operazioni del server
<productname>PostgreSQL</productname>. I limiti sul numero di processi  
per utente, sul numero di file aperti per processo
e sulla quantità di memoria disponibile per ogni processo sono di particolare importanza.
Ognuno di questi ha un limite <quote>hard</quote> e uno  <quote>soft</quote>. 
Il limite soft è quello che conta effettivamente ma può essere cambiato 
dall'utente fino al limite hard. Il limite hard può essere cambiato solo dall'utente root.
La chiamata di sistema <function>setrlimit</function> è responsabile  
di impostare questi parametri. Il comando <command>ulimit</command> incorporato della shell
(shell Bourne) o <command>limit</command>   (<application>csh</application>) è 
usato per controllare i limiti delle risorse dalla linea di comando. Su 
sistemi derivati da BSD il file <filename>/etc/login.conf</filename>
controlla i vari limiti delle risorse impostati durante il login. Si veda 
la documentazione del sistema operativo per dettagli. I parametri rilevanti 
sono <varname>maxproc</varname>,
<varname>openfiles</varname> e <varname>datasize</varname>. Per 
esempio:
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
(<literal>-cur</literal> è il limite soft.  Aggiungere 
<literal>-max</literal> per impostare il limite hard).
   </para>

   <para>
Il kernel può avere anche limiti a livello di sistema su alcuni risorse.
    <itemizedlist>
     <listitem>
      <para>
Su  <productname>Linux</productname>
<filename>/proc/sys/fs/file-max</filename> determina il 
numero masssimo di file aperti che il kernel supporterà. Può essere
cambiato scrivendo un numero diverso nel file o aggiungendo
un assegnazione in <filename>/etc/sysctl.conf</filename>.
Il limite massimo di file per processo è specificato nel momento in cui 
il kernel viene compilato; si veda 
<filename>/usr/src/linux/Documentation/proc.txt</filename> per
maggiori informazioni.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
Il server <productname>PostgreSQL</productname> usa un processo per connessione
quindi si dovrebbe fornire un numero di processi almeno quanto il numero di 
connessioni permesse, in aggiunta a quello di cui si ha bisogno per il resto del sistema.
Questo di solito non è un problema ma se si eseguono 
diversi server su una macchina le cose potrebbero diventare strettine. 
   </para>

   <para>
Il limite predefinito sui file aperti spesso è impostato a valori 
<quote>socialmente amichevoli</quote> che permettono a molti utenti di coesistere
su una macchina senza usare una frazione inappropriata di 
risorse di sistema. Se si eseguono molti server su una macchina forse è quello che si vuole,
ma su server dedicati si potrebbe voler incrementare questo limite.
   </para>

   <para>
Dall'altro lato della medaglia, alcuni sistemi permettono a processi individuali di 
aprire un grande numero di file; se più di pochi processi fanno questo allora
il limite a livello di sistema può facilmente essere superato.
Se si scopre che succede ciò, e non si vuole modificare
il limite a livello di sistema, si  può impostare il parametro di configurazione <xref
linkend="guc-max-files-per-process"/> di <productname>PostgreSQL</productname> per limitare
il consumo di file aperti.
   </para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
   <title>Linux Memory Overcommit</title>

   <para>
In Linux 2.4 e successivi, il comportamento predefinito della memoria virtuale  non 
è ottimale per  <productname>PostgreSQL</productname>. A causa del modo 
in cui il kernel implementa l'overcommit della memoria, il kernel potrebbe 
terminare il serve <productname>PostgreSQL</productname> (il processo server 
principale) se le richieste di memoria di 
un altro processo causano che il sistema ecceda la memoria virtuale.
   </para>

   <para>
Se succede questo, si vedrà un messaggio del kernel che somiglia a questo
(consultare la documentazionei e la configurazione  del proprio sistema per vedere
dove cercare tale messaggio):
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
Questo indica che il processo <filename>postgres</filename> è stato 
terminato a causa della memoria. 
Anche se le connessioni al database esistenti continueranno a funzionare 
normalmente, nessuna nuova connessione sarà accettata. Per risolvere la situazione,
<productname>PostgreSQL</productname> dovrà essere riavviato. 
   </para>

   <para>
Un modo di evitare questo problema è di lanciare
<productname>PostgreSQL</productname> su una macchina dove si può  
essere sicuri che altri processi non daranno problemi di memoria.
Se la memoria è stretta, incrementare lo spazio di swap del sistema operativo
può aiutare a evitare il problema, dato che il killer out-of-memory (OOM)
viene invocato solo quando la memoria fisica e lo spazio di swap sono 
terminati.
   </para>

   <para>
Su Linux 2.6 e successivi, è possibile modificare il comportamento del
kernel così che non faccia l'<quote>overcommit</quote> della memoria. 
Anche se quest'impostazione non preverrà del tutto l'invocazione di <ulink
url="http://lwn.net/Articles/104179/">OOM killer</ulink>,
abbasserà significativamente tale possibilità e porterà inoltre a una maggiore
robustezza del sistema. Questo è fatto selezionando la modalità strict
per l'overcommit con  <command>sysctl</command>:
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
o posizionando una voce equivalente in  <filename>/etc/sysctl.conf</filename>.
Si potrebbe desiderare anche modificare l'impostazione correlata
<varname>vm.overcommit_ratio</varname>. Per dettagli si veda il file di  documentazione del kernel  
<filename>Documentation/vm/overcommit-accounting</filename>.

   </para>

   <para>
Un altro approccio, che può essere usato modificando o meno 
<varname>vm.overcommit_memory</varname>, è di impostare il valore 
<varname>oom_adj</varname> specifico del processo postmaster a  <literal>-17</literal>,
garantendo in tal modo che non sarà considerato dal killer OOM. Il modo più 
semplice per fare ciò è di eseguire
<programlisting>
echo -17 > /proc/self/oom_adj
</programlisting>
nello script di avvio di postmaster appena prima di invocare il postmaster.
Notare che questa azione deve essere fatta come root, altrimenti non avrà effetti;
quindi uno script di avvio in possesso di root è il posto più semplice dove farlo. Se si fa questo,
si potrebbe voler anche compilare  <productname>PostgreSQL</productname>
con  <literal>-DLINUX_OOM_ADJ=0</literal> aggiunta a <varname>CFLAGS</varname>.
Questo farà si che i processi figli di postmaster andranno in esecuzione con il 
valore normale (zero) di <varname>oom_adj</varname>, quindi il killer OOM può ancora  
riferirsi a loro se necessario.
   </para>

   <note>
   <para>
    Some vendors' Linux 2.4 kernels are reported to have early versions
    of the 2.6 overcommit <command>sysctl</command> parameter.  However, setting
    <literal>vm.overcommit_memory</literal> to 2
    on a 2.4 kernel that does not have the relevant code will make
    things worse, not better.  It is recommended that you inspect
    the actual kernel source code (see the function
    <function>vm_enough_memory</function> in the file <filename>mm/mmap.c</filename>)
    to verify what is supported in your kernel before you try this in a 2.4
    installation.  The presence of the <filename>overcommit-accounting</filename>
    documentation file should <emphasis>not</emphasis> be taken as evidence that the
    feature is there.  If in any doubt, consult a kernel expert or your
    kernel vendor.
   </para>
   </note>
  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
  <title>Arrestare il server</title>

  <indexterm zone="server-shutdown">
   <primary>arrestare</primary>
  </indexterm>

  <para>
Ci sono diversi modi per arrestare il server database. Si controlla 
il tipo di arresto mandando differenti segnali al processo principale 
<command>postgres</command>.

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</primary></indexterm></term>
     <listitem>
      <para>
Questa è la modalità <firstterm>Smart Shutdown</firstterm>.
Dopo aver ricevuto <systemitem>SIGTERM</systemitem>, il server 
non permette nuove connessioni, ma lascia che le sessioni esistenti finiscano 
il lavoro normalmente. Si arresta solo dopo che tutte le sessioni sono terminate.
Se il server è in modalità di backup online, aspetta finchè 
la modalità di backup online non è più attiva. Mentre la modalità backup è 
attiva, le nuove connessioni saranno comunque permesse, ma solo a superutenti 
(questa eccezione permette ad un superutente di connettersi per terminare 
la modalità di backup online). Se il server è in modalità recupero quando 
viene richiesto l'arresto, il recupero e la replica streaming saranno 
fermati solo dopo che tutte le regolari sessioni sono terminate.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIginT</systemitem><indexterm><primary>SIginT</primary></indexterm></term>
     <listitem>
      <para>
Questa è la modalità <firstterm>Fast Shutdown</firstterm>.
Il server non permette nuove connessioni e manda <systemitem>SIGTERM</systemitem>
a tutti i processi server esistenti, che causerà la fine delle loro 
transazioni correnti e l'uscita al prompt. Quindi aspetta che tutti  
i processi server escano e quindi si arresta.
Se il server è in modalità backup online, la modalità backup sarà 
terminata, rendendo il backup inutile.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</primary></indexterm></term>
     <listitem>
      <para>
Questa è la modalità <firstterm>Immediate Shutdown</firstterm>.
Il processo  <command>postgres</command> principale manderà un 
<systemitem>SIGQUIT</systemitem> a tutti i processi figli ed uscirà 
immediatamente, senza arrestarsi correttamente. I processi figlio allo stesso modo
escono immediatamente quando ricevono <systemitem>SIGQUIT</systemitem>. 
Questo porterà al recupero (riusando il log WAL) al successivo avvio.
Questo è raccomandato solo in casi d'emergenza.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
Il programma <xref linkend="app-pg-ctl"/> fornisce un'interfaccia conveniente
per mandare questi segnali per arrestare il server.
Alternativamente, si può mandare il segnale direttamente usando <command>kill</command>
su sistemi non Windows.
Il <acronym>PID</acronym> dei processi <command>postgres</command> può essere
trovato usando il programma <command>ps</command>, o dal file 
<filename>postmaster.pid</filename> nella directory dei dati. Per esempio,
per fare un arresto veloce:
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>

  <important>
   <para>
È meglio non usare <systemitem>SIGKILL</systemitem> per arrestare il server.
Fare ciò eviterà che il server rilasci 
memeoria condivisa e semafori, che quindi potrebbe essere fatto
manualmente prima che un nuovo server possa essere avviato. Inoltre,
<systemitem>SIGKILL</systemitem> termina il processo <command>postgres</command>
senza lasciargli propagare il segnale ai suoi sottoprocessi,
quindi sarà necessario anche terminare i sottoprocessi individuali a mano. 
   </para>
  </important>

  <para>
Per terminare una sessione individuale permettendo comunque alle altre sessioni di continuare,
usare <function>pg_terminate_backend()</function> (si veda <xref
linkend="functions-admin-signal-table"/>) o mandare un segnale
<systemitem>SIGTERM</systemitem> al processo figlio associato con la sessione.
  </para>
 </sect1>

 <sect1 id="preventing-server-spoofing">
  <title>Prevenire lo spoofing del server</title>

  <indexterm zone="preventing-server-spoofing">
   <primary>spoofing del server</primary>
  </indexterm>

  <para>
Mentre il server è in esecuzione, non è possibile per un utente malizioso
prendere il posto del server database normale. Comunque, quando il server 
non è in esecuzione, è possibile per un utente locale aggirare il server normale
avviando il proprio server. Il server "spoof" può leggere 
le password e le query mandate dai client, ma potrebbe non restituire dati 
dato che la directory <varname>PGDATA</varname> sarebbe comunque sicura a causa dei permessi
della directory. Lo spoofing è possibile dato che qualsiasi utente può
avviare un server database; un client non può identificare un server non valido
a meno che non sia configurato in maniera speciale. 
  </para>

  <para>
Il modo più semplice di prevenire lo spoofing per connessioni <literal>locali</literal>
è di usare una directory di socket di dominio Unix (<xref
linkend="guc-unix-socket-directory"/>)  che ha permessi di scrittura solo per 
un utente locale fidato. Questo previene che utenti maliziosi creino 
i loro file socket in quella directory. Se si è preoccupati che alcune applicazioni 
potrebbero comunque fare riferimento a <filename>/tmp</filename> per 
il file socket e quindi essere vulnerabili allo spoofing, creare un link simbolico 
<filename>/tmp/.s.PGSQL.5432</filename> durante l'avvio del sistema operativo che punta 
al file socket trasferito. Si potrebbe inoltre aver bisogno di modificare lo script 
di pulizia di <filename>/tmp</filename> per prevenire la rimozione del link simbolico.
  </para>

  <para>
Per prevenire lo spoofing su connessioni TCP, la soluzione migliore è di usare
certificati SSL e assicurarsi che i client controllino il certificato del server.
Per fare ciò, il server
deve essere configurato per accettare solo connessioni <literal>hostssl</literal> (<xref
linkend="auth-pg-hba-conf"/>) ed avere i file SSL (chiave) 
<filename>server.key</filename> (chiave) e
<filename>server.crt</filename> (certificato) (<xref
linkend="ssl-tcp"/>). Il client TCP deve connettersi usando
<literal>sslmode=verify-ca</literal> o
<literal>verify-full</literal> ed avere il file certificato root appropriato installato
(<xref linkend="libpq-connect"/>).
  </para>
 </sect1>
  
 <sect1 id="encryption-options">
  <title>Opzioni di criptazione</title>

  <indexterm zone="encryption-options">
   <primary>criptazione</primary>
  </indexterm>

  <para>
<productname>PostgreSQL</productname> offre la criptazione a diversi livelli,
e fornisce flessibilità nel proteggere i dati dalla divulgazione,
a causa di un furto del server, amministratori non scrupolosi, o 
reti non sicure. La criptazione potrebbe anche essere richiesta per 
dati delicati come record medici o transazioni finanziarie.
  </para>
   
  <variablelist>

  <varlistentry>
   <term>Criptazione della memorizzazione delle password</term>
   <listitem>

    <para>
In maniera predefinita, le password dell'utente del database vengono salvate
come hash MD5, quindi l'amministratore non può determinare l'effettiva password 
assegnata all'utente. Se la criptazione MD5 viene usata per l'autenticazione del 
client, la password non criptata non è mai nemmeno temporaneamente presente 
sul server dato che il client la encripta con MD5 prima di mandarla 
attraverso la rete.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Criptazione per colonne specifiche</term>

   <listitem>
    <para>
La libreria di funzioni <filename>contrib</filename> 
<link linkend="pgcrypto"><function>pgcrypto</function></link>
permette a certi campi di essere salvati criptati.
Questo è utile se solo alcuni dei dati sono sensibili.
Il client fornisce la chiave di decriptazione e il dato viene decriptato
sul server e quindi mandato al client.
    </para>
     
    <para>
I dati decriptati e la chiave di decriptazione sono presenti sul server 
per un istante di tempo mentre vengono decriptate e trasmesse
dal client al server. Questo genera un breve periodo 
in cui i dati e le chiavi possono essere intercettati da qualcuno con 
accesso completo al server database,  tipo l'amministratore di sistema.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Criptazione di una partizione dati</term>

   <listitem>
    <para>
Su linux, la criptazione può essere stratificata in cima ad un file system
usando un <quote>apparecchio di loopback</quote>. Questo permette che un'intera
partizione del file system venga criptata su disco, e decriptata dal 
sistema operativo. Su FreeBSD, la caratteristica equivalente viene chiamata
 GEOM Based Disk Encryption  (<acronym>gbde</acronym>), e molti altri 
sistemi oprativi supportano questa funzionalità, includo Windows.
    </para>

    <para>
Questo meccanismo previene il fatto che dati non criptati siano letti dai volumi
se i volumi o l'intero computer vengono rubati. Questo non protegge
contro attacchi mentre il file system è montato, dato che quando 
montato, il sistema oprativo fornisce una vista non criptata dei dati.
Comunque, per montare il file system, si ha bisogno di qualche modo 
per passare la chiave di criptazione al sistema operativo, 
ed a volte la chiave è salvata da qualche parte sull'host che monta il disco.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Criptare le password attraverso la rete</term>

   <listitem>
     <para>
Il metodo di autenticazione <literal>MD5</literal> cripta doppiamente
le password sul client prima di mandarle al server. Prima la cripta  
con MD5 in base al nome utente, e quindi la cripta basandosi su un salt casuale 
mandato dal server quando è stata realizzata la connessione al database. 
Questo valore doppiamente criptato viene mandato al server attraverso la rete.
La doppia criptazione non previene solo che venga scoperta la password, 
previene anche che successivamente altre connessioni usino la stessa password criptata 
per connettersi al server database.
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>Dati criptati attraverso la rete</term>

    <listitem>
     <para>
Le connessioni SSL criptano tutti i dati mandati attraverso la rete:
la password, le query, e i dati restituiti. Il file 
<filename>pg_hba.conf</filename> permette agli amministratori di specificare
quali host possono usare connessioni non criptate (<literal>host</literal>)
e quali richiedono connessioni criptate SSL (<literal>hostssl</literal>).
Inoltre, i  client possono specificare che si connettono al server solo attraverso
SSL. Possono anche essere usati <application>Stunnel</application> o
<application>SSH</application> per criptare le trasmissioni.
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>Autenticazione Host SSL</term>

   <listitem>
    <para>
È possibile sia per il client che per il server scambiarsi certificati SSL.  
Richiede qualche configurazione aggiuntiva su ogni lato, ma fornisce 
una verifica più sicura delle identità rispetto al mero utilizzo delle password.
Previene che un computer pretenda di essere il server abbastanza a lungo
da leggere la password mandata al client. Aiuta inoltre a prevenire 
attacchi di tipo <quote>man in the middle</quote>
in cui un computer tra il client e il server pretende di essere il server
e legge e passa tutti i dati tra il client e il server.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Criptazione lato client</term>

   <listitem>
    <para>
Se l'amministratore di sistema del server non può essere fidato,
è necessario 
che il client cripti i dati; in questo modo, i dati non criptati
non appaiono mai sul server. I dati vengono criptati sul client 
prima di essere mandati al server, e i risultati del database 
devono essere decriptati sul client prima di essere usati.
    </para>
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
  <title>Connessioni TCP/IP sicure con SSL</title>

  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
  </indexterm>

  <para>
<productname>PostgreSQL</productname> ha il supporto nativo per l'utilizzo di 
connessioni <acronym>SSL</acronym> per criptare le comunicazioni client/server
aumentando la sicurezza. Questo richiede che 
<productname>OpenSSL</productname> sia installato sia sul client che sul server
e che il supporto in <productname>PostgreSQL</productname> sia abilitato 
al momento della compilazione (si veda <xref linkend="installation"/>).
  </para>

  <para>
Con il supporto <acronym>SSL</acronym> compilato, il server 
<productname>PostgreSQL</productname> può essere avviato con 
<acronym>SSL</acronym> abilitato impostando il parametro 
<xref linkend="guc-ssl"/> a <literal>on</literal> nel 
<filename>postgresql.conf</filename>. Il server ascolterà sia connessioni normali che 
<acronym>SSL</acronym> sulla stessa porta TCP, e negozierà con qualsiasi client
che si connette se usa <acronym>SSL</acronym>. In modo predefinito,
questa è un'opzione del client; si veda <xref
linkend="auth-pg-hba-conf"/> per informazioni su come impostare il server per richiedere 
l'uso di <acronym>SSL</acronym> per alcune o tutte le connessioni.

  <para>
   <productname>PostgreSQL</productname> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</literal>.
   This default can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration file.
  </para>

  <para>
   <productname>OpenSSL</productname> supports a wide range of ciphers
   and authentication algorithms, of varying strength.  While a list of
   ciphers can be specified in the <productname>OpenSSL</productname>
   configuration file, you can specify ciphers specifically for use by
   the database server by modifying <xref linkend="guc-ssl-ciphers"/> in
   <filename>postgresql.conf</filename>.
  </para>

  <note>
   <para>
    It is possible to have authentication without encryption overhead by
    using <literal>NULL-SHA</literal> or <literal>NULL-MD5</literal> ciphers.  However,
    a man-in-the-middle could read and pass communications between client
    and server.  Also, encryption overhead is minimal compared to the
    overhead of authentication.  For these reasons NULL ciphers are not
    recommended.
   </para>
  </note>

  <para>
   To start in <acronym>SSL</acronym> mode, the files <filename>server.crt</filename>
   and <filename>server.key</filename> must exist in the server's data directory.
   These files should contain the server certificate and private key,
   respectively.
   On Unix systems, the permissions on <filename>server.key</filename> must
   disallow any access to world or group; achieve this by the command
   <command>chmod 0600 server.key</command>.
   If the private key is protected with a passphrase, the
   server will prompt for the passphrase and will not start until it has
   been entered.
  </para>

  <para>
   In some cases, the server certificate might be signed by an
   <quote>intermediate</quote> certificate authority, rather than one that is
   directly trusted by clients.  To use such a certificate, append the
   certificate of the signing authority to the <filename>server.crt</filename> file,
   then its parent authority's certificate, and so on up to a <quote>root</quote>
   authority that is trusted by the clients.  The root certificate should
   be included in every case where <filename>server.crt</filename> contains more than
   one certificate.
  </para>

  <sect2 id="ssl-client-certificates">
   <title>Using client certificates</title>

   <para>
   To require the client to supply a trusted certificate, place
   certificates of the certificate authorities (<acronym>CA</acronym>s)
   you trust in the file <filename>root.crt</filename> in the data
   directory, and set the <literal>clientcert</literal> parameter
   to <literal>1</literal> on the appropriate <literal>hostssl</literal> line(s) in
   <filename>pg_hba.conf</filename>.
   A certificate will then be requested from the client during
   SSL connection startup.  (See <xref linkend="libpq-ssl"/> for a
   description of how to set up certificates on the client.)  The server will
   verify that the client's certificate is signed by one of the trusted
   certificate authorities.  Certificate Revocation List (CRL) entries
   are also checked if the file <filename>root.crl</filename> exists.
   <!-- If this URL changes replace it with a URL to www.archive.org. -->
   (See <ulink
   url="http://h71000.www7.hp.com/DOC/83final/BA554_90007/ch04s02.html"></ulink>
   for diagrams showing SSL certificate usage.)
  </para>

  <para>
   The <literal>clientcert</literal> option in <filename>pg_hba.conf</filename> is
   available for all authentication methods, but only for rows specified as
   <literal>hostssl</literal>.  When <literal>clientcert</literal> is not specified
   or is set to <literal>0</literal>, the server will still verify presented client
   certificates against <filename>root.crt</filename> if that file exists
   &mdash; but it will not insist that a client certificate be presented.
  </para>

  <para>
   Note that <filename>root.crt</filename> lists the top-level CAs that are
   considered trusted for signing client certificates.  In principle it need
   not list the CA that signed the server's certificate, though in most cases
   that CA would also be trusted for client certificates.
  </para>

  <para>
   If you are setting up client certificates, you may wish to use
   the <literal>cert</literal> authentication method, so that the certificates
   control user authentication as well as providing connection security.
   See <xref linkend="auth-cert"/> for details.
  </para>
  </sect2>

  <sect2 id="ssl-server-files">
   <title>SSL Server File Usage</title>
  <para>
   The files <filename>server.key</filename>, <filename>server.crt</filename>,
   <filename>root.crt</filename>, and <filename>root.crl</filename>
   are only examined during server start; so you must restart
   the server for changes in them to take effect.
  </para>

  <table id="ssl-file-usage">
   <title>SSL Server File Usage</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><filename>server.crt</filename></entry>
      <entry>server certificate</entry>
      <entry>sent to client to indicate server's identity</entry>
     </row>

     <row>
      <entry><filename>server.key</filename></entry>
      <entry>server private key</entry>
      <entry>proves server certificate was sent by the owner; does not indicate
      certificate owner is trustworthy</entry>
     </row>

     <row>
      <entry><filename>root.crt</filename></entry>
      <entry>trusted certificate authorities</entry>
      <entry>checks that client certificate is
      signed by a trusted certificate authority</entry>
     </row>

     <row>
      <entry><filename>root.crl</filename></entry>
      <entry>certificates revoked by certificate authorities</entry>
      <entry>client certificate must not be on this list</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
  </sect2>

  <sect2 id="ssl-certificate-creation">
   <title>Creating a Self-Signed Certificate</title>

   <para>
    To create a quick self-signed certificate for the server, use the
    following <productname>OpenSSL</productname> command:
<programlisting>
openssl req -new -text -out server.req
</programlisting>
    Fill out the information that <application>openssl</application> asks for. Make sure
    you enter the local host name as <quote>Common Name</quote>; the challenge
    password can be left blank. The program will generate a key that is
    passphrase protected; it will not accept a passphrase that is less
    than four characters long. To remove the passphrase (as you must if
    you want automatic start-up of the server), run the commands:
<programlisting>
openssl rsa -in privkey.pem -out server.key
rm privkey.pem
</programlisting>
    Enter the old passphrase to unlock the existing key. Now do:
<programlisting>
openssl req -x509 -in server.req -text -key server.key -out server.crt
</programlisting>
    to turn the certificate into a self-signed certificate and to copy
    the key and certificate to where the server will look for them.
    Finally do:
<programlisting>
chmod og-rwx server.key
</programlisting>
    because the server will reject the file if its permissions are more
    liberal than this.
    For more details on how to create your server private key and
    certificate, refer to the <productname>OpenSSL</productname> documentation.
   </para>

   <para>
    A self-signed certificate can be used for testing, but a certificate
    signed by a certificate authority (<acronym>CA</acronym>) (either one of the
    global <acronym>CAs</acronym> or a local one) should be used in production
    so that clients can verify the server's identity. If all the clients
    are local to the organization, using a local <acronym>CA</acronym> is
    recommended.
   </para>

  </sect2>

 </sect1>

 <sect1 id="ssh-tunnels">
  <title>Secure TCP/IP Connections with <application>SSH</application> Tunnels</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
   It is possible to use <application>SSH</application> to encrypt the network
   connection between clients and a
   <productname>PostgreSQL</productname> server. Done properly, this
   provides an adequately secure network connection, even for non-SSL-capable
   clients.
  </para>

  <para>
   First make sure that an <application>SSH</application> server is
   running properly on the same machine as the
   <productname>PostgreSQL</productname> server and that you can log in using
   <command>ssh</command> as some user. Then you can establish a secure
   tunnel with a command like this from the client machine:
<programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
   The first number in the <option>-L</option> argument, 63333, is the
   port number of your end of the tunnel; it can be any unused port.
   (IANA reserves ports 49152 through 65535 for private use.)  The
   second number, 5432, is the remote end of the tunnel: the port
   number your server is using. The name or IP address between the
   port numbers is the host with the database server you are going to
   connect to, as seen from the host you are logging in to, which
   is <literal>foo.com</literal> in this example. In order to connect
   to the database server using this tunnel, you connect to port 63333
   on the local machine:
<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
   To the database server it will then look as though you are really
   user <literal>joe</literal> on host <literal>foo.com</literal>
   connecting to <literal>localhost</literal> in that context, and it
   will use whatever authentication procedure was configured for
   connections from this user and host.  Note that the server will not
   think the connection is SSL-encrypted, since in fact it is not
   encrypted between the
   <application>SSH</application> server and the
   <productname>PostgreSQL</productname> server.  This should not pose any
   extra security risk as long as they are on the same machine.
  </para>

  <para>
   In order for the
   tunnel setup to succeed you must be allowed to connect via
   <command>ssh</command> as <literal>joe@foo.com</literal>, just
   as if you had attempted to use <command>ssh</command> to create a
   terminal session.
  </para>

  <para>
   You could also have set up the port forwarding as
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
   but then the database server will see the connection as coming in
   on its <literal>foo.com</literal> interface, which is not opened by
   the default setting <literal>listen_addresses =
   'localhost'</literal>.  This is usually not what you want.
  </para>

  <para>
   If you have to <quote>hop</quote> to the database server via some
   login host, one possible setup could look like this:
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
   Note that this way the connection
   from <literal>shell.foo.com</literal>
   to <literal>db.foo.com</literal> will not be encrypted by the SSH
   tunnel.
   SSH offers quite a few configuration possibilities when the network
   is restricted in various ways.  Please refer to the SSH
   documentation for details.
  </para>

  <tip>
   <para>
    Several other applications exist that can provide secure tunnels using
    a procedure similar in concept to the one just described.
   </para>
  </tip>

 </sect1>

</chapter>
